// ignore_for_file: camel_case_types, non_constant_identifier_names, unused_field, constant_identifier_names

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// Bindings for the Nuklear immediate mode GUI library.
class NuklearBindings {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  NuklearBindings(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  NuklearBindings.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// # nk_init_default
  /// Initializes a `nk_context` struct with a default standard library allocator.
  /// Should be used if you don't want to be bothered with memory management in nuklear.
  ///
  /// ```c
  /// nk_bool nk_init_default(struct nk_context *ctx, const struct nk_user_font *font);
  /// ```
  ///
  /// Parameter   | Description
  /// ------------|---------------------------------------------------------------
  /// \param[in] ctx     | Must point to an either stack or heap allocated `nk_context` struct
  /// \param[in] font    | Must point to a previously initialized font handle for more info look at font documentation
  ///
  /// \returns either `false(0)` on failure or `true(1)` on success.
  int nk_init_default(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<nk_user_font> arg1,
  ) {
    return _nk_init_default(
      arg0,
      arg1,
    );
  }

  late final _nk_init_defaultPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(ffi.Pointer<nk_context>,
              ffi.Pointer<nk_user_font>)>>('nk_init_default');
  late final _nk_init_default = _nk_init_defaultPtr.asFunction<
      int Function(ffi.Pointer<nk_context>, ffi.Pointer<nk_user_font>)>();

  /// # nk_init_fixed
  /// Initializes a `nk_context` struct from single fixed size memory block
  /// Should be used if you want complete control over nuklear's memory management.
  /// Especially recommended for system with little memory or systems with virtual memory.
  /// For the later case you can just allocate for example 16MB of virtual memory
  /// and only the required amount of memory will actually be committed.
  ///
  /// ```c
  /// nk_bool nk_init_fixed(struct nk_context *ctx, void *memory, nk_size size, const struct nk_user_font *font);
  /// ```
  ///
  /// !!! Warning
  /// make sure the passed memory block is aligned correctly for `nk_draw_commands`.
  ///
  /// Parameter   | Description
  /// ------------|--------------------------------------------------------------
  /// \param[in] ctx     | Must point to an either stack or heap allocated `nk_context` struct
  /// \param[in] memory  | Must point to a previously allocated memory block
  /// \param[in] size    | Must contain the total size of memory
  /// \param[in] font    | Must point to a previously initialized font handle for more info look at font documentation
  ///
  /// \returns either `false(0)` on failure or `true(1)` on success.
  int nk_init_fixed(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<ffi.Void> memory,
    int size,
    ffi.Pointer<nk_user_font> arg3,
  ) {
    return _nk_init_fixed(
      arg0,
      memory,
      size,
      arg3,
    );
  }

  late final _nk_init_fixedPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Void>,
              nk_size, ffi.Pointer<nk_user_font>)>>('nk_init_fixed');
  late final _nk_init_fixed = _nk_init_fixedPtr.asFunction<
      int Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Void>, int,
          ffi.Pointer<nk_user_font>)>();

  /// # nk_init
  /// Initializes a `nk_context` struct with memory allocation callbacks for nuklear to allocate
  /// memory from. Used internally for `nk_init_default` and provides a kitchen sink allocation
  /// interface to nuklear. Can be useful for cases like monitoring memory consumption.
  ///
  /// ```c
  /// nk_bool nk_init(struct nk_context *ctx, const struct nk_allocator *alloc, const struct nk_user_font *font);
  /// ```
  ///
  /// Parameter   | Description
  /// ------------|---------------------------------------------------------------
  /// \param[in] ctx     | Must point to an either stack or heap allocated `nk_context` struct
  /// \param[in] alloc   | Must point to a previously allocated memory allocator
  /// \param[in] font    | Must point to a previously initialized font handle for more info look at font documentation
  ///
  /// \returns either `false(0)` on failure or `true(1)` on success.
  int nk_init(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<nk_allocator> arg1,
    ffi.Pointer<nk_user_font> arg2,
  ) {
    return _nk_init(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _nk_initPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(ffi.Pointer<nk_context>, ffi.Pointer<nk_allocator>,
              ffi.Pointer<nk_user_font>)>>('nk_init');
  late final _nk_init = _nk_initPtr.asFunction<
      int Function(ffi.Pointer<nk_context>, ffi.Pointer<nk_allocator>,
          ffi.Pointer<nk_user_font>)>();

  /// \brief Initializes a `nk_context` struct from two different either fixed or growing buffers.
  ///
  /// \details
  /// The first buffer is for allocating draw commands while the second buffer is
  /// used for allocating windows, panels and state tables.
  ///
  /// ```c
  /// nk_bool nk_init_custom(struct nk_context *ctx, struct nk_buffer *cmds, struct nk_buffer *pool, const struct nk_user_font *font);
  /// ```
  ///
  /// \param[in] ctx    Must point to an either stack or heap allocated `nk_context` struct
  /// \param[in] cmds   Must point to a previously initialized memory buffer either fixed or dynamic to store draw commands into
  /// \param[in] pool   Must point to a previously initialized memory buffer either fixed or dynamic to store windows, panels and tables
  /// \param[in] font   Must point to a previously initialized font handle for more info look at font documentation
  ///
  /// \returns either `false(0)` on failure or `true(1)` on success.
  int nk_init_custom(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<nk_buffer> cmds,
    ffi.Pointer<nk_buffer> pool,
    ffi.Pointer<nk_user_font> arg3,
  ) {
    return _nk_init_custom(
      arg0,
      cmds,
      pool,
      arg3,
    );
  }

  late final _nk_init_customPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(
              ffi.Pointer<nk_context>,
              ffi.Pointer<nk_buffer>,
              ffi.Pointer<nk_buffer>,
              ffi.Pointer<nk_user_font>)>>('nk_init_custom');
  late final _nk_init_custom = _nk_init_customPtr.asFunction<
      int Function(ffi.Pointer<nk_context>, ffi.Pointer<nk_buffer>,
          ffi.Pointer<nk_buffer>, ffi.Pointer<nk_user_font>)>();

  /// \brief Resets the context state at the end of the frame.
  ///
  /// \details
  /// This includes mostly garbage collector tasks like removing windows or table
  /// not called and therefore used anymore.
  ///
  /// ```c
  /// void nk_clear(struct nk_context *ctx);
  /// ```
  ///
  /// \param[in] ctx  Must point to a previously initialized `nk_context` struct
  void nk_clear(
    ffi.Pointer<nk_context> arg0,
  ) {
    return _nk_clear(
      arg0,
    );
  }

  late final _nk_clearPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<nk_context>)>>(
          'nk_clear');
  late final _nk_clear =
      _nk_clearPtr.asFunction<void Function(ffi.Pointer<nk_context>)>();

  /// \brief Frees all memory allocated by nuklear; Not needed if context was initialized with `nk_init_fixed`.
  ///
  /// \details
  /// ```c
  /// void nk_free(struct nk_context *ctx);
  /// ```
  ///
  /// \param[in] ctx  Must point to a previously initialized `nk_context` struct
  void nk_free(
    ffi.Pointer<nk_context> arg0,
  ) {
    return _nk_free(
      arg0,
    );
  }

  late final _nk_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<nk_context>)>>(
          'nk_free');
  late final _nk_free =
      _nk_freePtr.asFunction<void Function(ffi.Pointer<nk_context>)>();

  /// \brief Begins the input mirroring process by resetting text, scroll
  /// mouse, previous mouse position and movement as well as key state transitions.
  ///
  /// \details
  /// ```c
  /// void nk_input_begin(struct nk_context*);
  /// ```
  ///
  /// \param[in] ctx Must point to a previously initialized `nk_context` struct
  void nk_input_begin(
    ffi.Pointer<nk_context> arg0,
  ) {
    return _nk_input_begin(
      arg0,
    );
  }

  late final _nk_input_beginPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<nk_context>)>>(
          'nk_input_begin');
  late final _nk_input_begin =
      _nk_input_beginPtr.asFunction<void Function(ffi.Pointer<nk_context>)>();

  /// \brief Mirrors current mouse position to nuklear
  ///
  /// \details
  /// ```c
  /// void nk_input_motion(struct nk_context *ctx, int x, int y);
  /// ```
  ///
  /// \param[in] ctx   Must point to a previously initialized `nk_context` struct
  /// \param[in] x     Must hold an integer describing the current mouse cursor x-position
  /// \param[in] y     Must hold an integer describing the current mouse cursor y-position
  void nk_input_motion(
    ffi.Pointer<nk_context> arg0,
    int x,
    int y,
  ) {
    return _nk_input_motion(
      arg0,
      x,
      y,
    );
  }

  late final _nk_input_motionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<nk_context>, ffi.Int, ffi.Int)>>('nk_input_motion');
  late final _nk_input_motion = _nk_input_motionPtr
      .asFunction<void Function(ffi.Pointer<nk_context>, int, int)>();

  /// \brief Mirrors the state of a specific key to nuklear
  ///
  /// \details
  /// ```c
  /// void nk_input_key(struct nk_context*, enum nk_keys key, nk_bool down);
  /// ```
  ///
  /// \param[in] ctx      Must point to a previously initialized `nk_context` struct
  /// \param[in] key      Must be any value specified in enum `nk_keys` that needs to be mirrored
  /// \param[in] down     Must be 0 for key is up and 1 for key is down
  void nk_input_key(
    ffi.Pointer<nk_context> arg0,
    int arg1,
    int down,
  ) {
    return _nk_input_key(
      arg0,
      arg1,
      down,
    );
  }

  late final _nk_input_keyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<nk_context>, ffi.Int32, nk_bool)>>('nk_input_key');
  late final _nk_input_key = _nk_input_keyPtr
      .asFunction<void Function(ffi.Pointer<nk_context>, int, int)>();

  /// \brief Mirrors the state of a specific mouse button to nuklear
  ///
  /// \details
  /// ```c
  /// void nk_input_button(struct nk_context *ctx, enum nk_buttons btn, int x, int y, nk_bool down);
  /// ```
  ///
  /// \param[in] ctx     Must point to a previously initialized `nk_context` struct
  /// \param[in] btn     Must be any value specified in enum `nk_buttons` that needs to be mirrored
  /// \param[in] x       Must contain an integer describing mouse cursor x-position on click up/down
  /// \param[in] y       Must contain an integer describing mouse cursor y-position on click up/down
  /// \param[in] down    Must be 0 for key is up and 1 for key is down
  void nk_input_button(
    ffi.Pointer<nk_context> arg0,
    int arg1,
    int x,
    int y,
    int down,
  ) {
    return _nk_input_button(
      arg0,
      arg1,
      x,
      y,
      down,
    );
  }

  late final _nk_input_buttonPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_context>, ffi.Int32, ffi.Int,
              ffi.Int, nk_bool)>>('nk_input_button');
  late final _nk_input_button = _nk_input_buttonPtr
      .asFunction<void Function(ffi.Pointer<nk_context>, int, int, int, int)>();

  /// \brief Copies the last mouse scroll value to nuklear.
  ///
  /// \details
  /// Is generally a scroll value. So does not have to come from mouse and could
  /// also originate from balls, tracks, linear guide rails, or other programs.
  ///
  /// ```c
  /// void nk_input_scroll(struct nk_context *ctx, struct nk_vec2 val);
  /// ```
  ///
  /// \param[in] ctx     | Must point to a previously initialized `nk_context` struct
  /// \param[in] val     | vector with both X- as well as Y-scroll value
  void nk_input_scroll(
    ffi.Pointer<nk_context> arg0,
    nk_vec2 val,
  ) {
    return _nk_input_scroll(
      arg0,
      val,
    );
  }

  late final _nk_input_scrollPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<nk_context>, nk_vec2)>>(
      'nk_input_scroll');
  late final _nk_input_scroll = _nk_input_scrollPtr
      .asFunction<void Function(ffi.Pointer<nk_context>, nk_vec2)>();

  /// \brief Copies a single ASCII character into an internal text buffer
  ///
  /// \details
  /// This is basically a helper function to quickly push ASCII characters into
  /// nuklear.
  ///
  /// \note
  /// Stores up to NK_INPUT_MAX bytes between `nk_input_begin` and `nk_input_end`.
  ///
  /// ```c
  /// void nk_input_char(struct nk_context *ctx, char c);
  /// ```
  ///
  /// \param[in] ctx     | Must point to a previously initialized `nk_context` struct
  /// \param[in] c       | Must be a single ASCII character preferable one that can be printed
  void nk_input_char(
    ffi.Pointer<nk_context> arg0,
    int arg1,
  ) {
    return _nk_input_char(
      arg0,
      arg1,
    );
  }

  late final _nk_input_charPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<nk_context>, ffi.Char)>>('nk_input_char');
  late final _nk_input_char = _nk_input_charPtr
      .asFunction<void Function(ffi.Pointer<nk_context>, int)>();

  /// \brief Converts an encoded unicode rune into UTF-8 and copies the result into an
  /// internal text buffer.
  ///
  /// \note
  /// Stores up to NK_INPUT_MAX bytes between `nk_input_begin` and `nk_input_end`.
  ///
  /// ```c
  /// void nk_input_glyph(struct nk_context *ctx, const nk_glyph g);
  /// ```
  ///
  /// \param[in] ctx     | Must point to a previously initialized `nk_context` struct
  /// \param[in] g       | UTF-32 unicode codepoint
  void nk_input_glyph(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<ffi.Char> arg1,
  ) {
    return _nk_input_glyph(
      arg0,
      arg1,
    );
  }

  late final _nk_input_glyphPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_context>,
              ffi.Pointer<ffi.Char>)>>('nk_input_glyph');
  late final _nk_input_glyph = _nk_input_glyphPtr.asFunction<
      void Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>)>();

  /// \brief Converts a unicode rune into UTF-8 and copies the result
  /// into an internal text buffer.
  ///
  /// \details
  /// \note
  /// Stores up to NK_INPUT_MAX bytes between `nk_input_begin` and `nk_input_end`.
  ///
  /// ```c
  /// void nk_input_unicode(struct nk_context*, nk_rune rune);
  /// ```
  ///
  /// \param[in] ctx     | Must point to a previously initialized `nk_context` struct
  /// \param[in] rune    | UTF-32 unicode codepoint
  void nk_input_unicode(
    ffi.Pointer<nk_context> arg0,
    int arg1,
  ) {
    return _nk_input_unicode(
      arg0,
      arg1,
    );
  }

  late final _nk_input_unicodePtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<nk_context>, nk_rune)>>(
      'nk_input_unicode');
  late final _nk_input_unicode = _nk_input_unicodePtr
      .asFunction<void Function(ffi.Pointer<nk_context>, int)>();

  /// \brief End the input mirroring process by resetting mouse grabbing
  /// state to ensure the mouse cursor is not grabbed indefinitely.
  ///
  /// \details
  /// ```c
  /// void nk_input_end(struct nk_context *ctx);
  /// ```
  ///
  /// \param[in] ctx     | Must point to a previously initialized `nk_context` struct
  void nk_input_end(
    ffi.Pointer<nk_context> arg0,
  ) {
    return _nk_input_end(
      arg0,
    );
  }

  late final _nk_input_endPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<nk_context>)>>(
          'nk_input_end');
  late final _nk_input_end =
      _nk_input_endPtr.asFunction<void Function(ffi.Pointer<nk_context>)>();

  /// \brief Returns a draw command list iterator to iterate all draw
  /// commands accumulated over one frame.
  ///
  /// \details
  /// ```c
  /// const struct nk_command* nk__begin(struct nk_context*);
  /// ```
  ///
  /// \param[in] ctx     | must point to an previously initialized `nk_context` struct at the end of a frame
  ///
  /// \returns draw command pointer pointing to the first command inside the draw command list
  ffi.Pointer<nk_command> nk__begin(
    ffi.Pointer<nk_context> arg0,
  ) {
    return _nk__begin(
      arg0,
    );
  }

  late final _nk__beginPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<nk_command> Function(
              ffi.Pointer<nk_context>)>>('nk__begin');
  late final _nk__begin = _nk__beginPtr
      .asFunction<ffi.Pointer<nk_command> Function(ffi.Pointer<nk_context>)>();

  /// \brief Returns draw command pointer pointing to the next command inside the draw command list
  ///
  /// \details
  /// ```c
  /// const struct nk_command* nk__next(struct nk_context*, const struct nk_command*);
  /// ```
  ///
  /// \param[in] ctx     | Must point to an previously initialized `nk_context` struct at the end of a frame
  /// \param[in] cmd     | Must point to an previously a draw command either returned by `nk__begin` or `nk__next`
  ///
  /// \returns draw command pointer pointing to the next command inside the draw command list
  ffi.Pointer<nk_command> nk__next(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<nk_command> arg1,
  ) {
    return _nk__next(
      arg0,
      arg1,
    );
  }

  late final _nk__nextPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<nk_command> Function(
              ffi.Pointer<nk_context>, ffi.Pointer<nk_command>)>>('nk__next');
  late final _nk__next = _nk__nextPtr.asFunction<
      ffi.Pointer<nk_command> Function(
          ffi.Pointer<nk_context>, ffi.Pointer<nk_command>)>();

  /// \brief Converts all internal draw commands into vertex draw commands and fills
  /// three buffers with vertexes, vertex draw commands and vertex indices.
  ///
  /// \details
  /// The vertex format as well as some other configuration values have to be
  /// configured by filling out a `nk_convert_config` struct.
  ///
  /// ```c
  /// nk_flags nk_convert(struct nk_context *ctx, struct nk_buffer *cmds,
  /// struct nk_buffer *vertices, struct nk_buffer *elements, const struct nk_convert_config*);
  /// ```
  ///
  /// \param[in] ctx      Must point to an previously initialized `nk_context` struct at the end of a frame
  /// \param[out] cmds     Must point to a previously initialized buffer to hold converted vertex draw commands
  /// \param[out] vertices Must point to a previously initialized buffer to hold all produced vertices
  /// \param[out] elements Must point to a previously initialized buffer to hold all produced vertex indices
  /// \param[in] config   Must point to a filled out `nk_config` struct to configure the conversion process
  ///
  /// \returns one of enum nk_convert_result error codes
  ///
  /// Parameter                       | Description
  /// --------------------------------|-----------------------------------------------------------
  /// NK_CONVERT_SUCCESS              | Signals a successful draw command to vertex buffer conversion
  /// NK_CONVERT_INVALID_PARAM        | An invalid argument was passed in the function call
  /// NK_CONVERT_COMMAND_BUFFER_FULL  | The provided buffer for storing draw commands is full or failed to allocate more memory
  /// NK_CONVERT_VERTEX_BUFFER_FULL   | The provided buffer for storing vertices is full or failed to allocate more memory
  /// NK_CONVERT_ELEMENT_BUFFER_FULL  | The provided buffer for storing indices is full or failed to allocate more memory
  int nk_convert(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<nk_buffer> cmds,
    ffi.Pointer<nk_buffer> vertices,
    ffi.Pointer<nk_buffer> elements,
    ffi.Pointer<nk_convert_config> arg4,
  ) {
    return _nk_convert(
      arg0,
      cmds,
      vertices,
      elements,
      arg4,
    );
  }

  late final _nk_convertPtr = _lookup<
      ffi.NativeFunction<
          nk_flags Function(
              ffi.Pointer<nk_context>,
              ffi.Pointer<nk_buffer>,
              ffi.Pointer<nk_buffer>,
              ffi.Pointer<nk_buffer>,
              ffi.Pointer<nk_convert_config>)>>('nk_convert');
  late final _nk_convert = _nk_convertPtr.asFunction<
      int Function(
          ffi.Pointer<nk_context>,
          ffi.Pointer<nk_buffer>,
          ffi.Pointer<nk_buffer>,
          ffi.Pointer<nk_buffer>,
          ffi.Pointer<nk_convert_config>)>();

  /// \brief Returns a draw vertex command buffer iterator to iterate over the vertex draw command buffer
  ///
  /// \details
  /// ```c
  /// const struct nk_draw_command* nk__draw_begin(const struct nk_context*, const struct nk_buffer*);
  /// ```
  ///
  /// \param[in] ctx     | Must point to an previously initialized `nk_context` struct at the end of a frame
  /// \param[in] buf     | Must point to an previously by `nk_convert` filled out vertex draw command buffer
  ///
  /// \returns vertex draw command pointer pointing to the first command inside the vertex draw command buffer
  ffi.Pointer<nk_draw_command> nk__draw_begin(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<nk_buffer> arg1,
  ) {
    return _nk__draw_begin(
      arg0,
      arg1,
    );
  }

  late final _nk__draw_beginPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<nk_draw_command> Function(ffi.Pointer<nk_context>,
              ffi.Pointer<nk_buffer>)>>('nk__draw_begin');
  late final _nk__draw_begin = _nk__draw_beginPtr.asFunction<
      ffi.Pointer<nk_draw_command> Function(
          ffi.Pointer<nk_context>, ffi.Pointer<nk_buffer>)>();

  /// # # nk__draw_end
  /// \returns the vertex draw command at the end of the vertex draw command buffer
  ///
  /// ```c
  /// const struct nk_draw_command* nk__draw_end(const struct nk_context *ctx, const struct nk_buffer *buf);
  /// ```
  ///
  /// Parameter   | Description
  /// ------------|-----------------------------------------------------------
  /// \param[in] ctx     | Must point to an previously initialized `nk_context` struct at the end of a frame
  /// \param[in] buf     | Must point to an previously by `nk_convert` filled out vertex draw command buffer
  ///
  /// \returns vertex draw command pointer pointing to the end of the last vertex draw command inside the vertex draw command buffer
  ffi.Pointer<nk_draw_command> nk__draw_end(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<nk_buffer> arg1,
  ) {
    return _nk__draw_end(
      arg0,
      arg1,
    );
  }

  late final _nk__draw_endPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<nk_draw_command> Function(ffi.Pointer<nk_context>,
              ffi.Pointer<nk_buffer>)>>('nk__draw_end');
  late final _nk__draw_end = _nk__draw_endPtr.asFunction<
      ffi.Pointer<nk_draw_command> Function(
          ffi.Pointer<nk_context>, ffi.Pointer<nk_buffer>)>();

  /// # # nk__draw_next
  /// Increments the vertex draw command buffer iterator
  ///
  /// ```c
  /// const struct nk_draw_command* nk__draw_next(const struct nk_draw_command*, const struct nk_buffer*, const struct nk_context*);
  /// ```
  ///
  /// Parameter   | Description
  /// ------------|-----------------------------------------------------------
  /// \param[in] cmd     | Must point to an previously either by `nk__draw_begin` or `nk__draw_next` returned vertex draw command
  /// \param[in] buf     | Must point to an previously by `nk_convert` filled out vertex draw command buffer
  /// \param[in] ctx     | Must point to an previously initialized `nk_context` struct at the end of a frame
  ///
  /// \returns vertex draw command pointer pointing to the end of the last vertex draw command inside the vertex draw command buffer
  ffi.Pointer<nk_draw_command> nk__draw_next(
    ffi.Pointer<nk_draw_command> arg0,
    ffi.Pointer<nk_buffer> arg1,
    ffi.Pointer<nk_context> arg2,
  ) {
    return _nk__draw_next(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _nk__draw_nextPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<nk_draw_command> Function(
              ffi.Pointer<nk_draw_command>,
              ffi.Pointer<nk_buffer>,
              ffi.Pointer<nk_context>)>>('nk__draw_next');
  late final _nk__draw_next = _nk__draw_nextPtr.asFunction<
      ffi.Pointer<nk_draw_command> Function(ffi.Pointer<nk_draw_command>,
          ffi.Pointer<nk_buffer>, ffi.Pointer<nk_context>)>();

  /// # # nk_begin
  /// Starts a new window; needs to be called every frame for every
  /// window (unless hidden) or otherwise the window gets removed
  ///
  /// ```c
  /// nk_bool nk_begin(struct nk_context *ctx, const char *title, struct nk_rect bounds, nk_flags flags);
  /// ```
  ///
  /// Parameter   | Description
  /// ------------|-----------------------------------------------------------
  /// \param[in] ctx     | Must point to an previously initialized `nk_context` struct
  /// \param[in] title   | Window title and identifier. Needs to be persistent over frames to identify the window
  /// \param[in] bounds  | Initial position and window size. However if you do not define `NK_WINDOW_SCALABLE` or `NK_WINDOW_MOVABLE` you can set window position and size every frame
  /// \param[in] flags   | Window flags defined in the nk_panel_flags section with a number of different window behaviors
  ///
  /// \returns `true(1)` if the window can be filled up with widgets from this point
  /// until `nk_end` or `false(0)` otherwise for example if minimized
  int nk_begin(
    ffi.Pointer<nk_context> ctx,
    ffi.Pointer<ffi.Char> title,
    nk_rect bounds,
    int flags,
  ) {
    return _nk_begin(
      ctx,
      title,
      bounds,
      flags,
    );
  }

  late final _nk_beginPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>,
              nk_rect, nk_flags)>>('nk_begin');
  late final _nk_begin = _nk_beginPtr.asFunction<
      int Function(
          ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>, nk_rect, int)>();

  /// # # nk_begin_titled
  /// Extended window start with separated title and identifier to allow multiple
  /// windows with same title but not name
  ///
  /// ```c
  /// nk_bool nk_begin_titled(struct nk_context *ctx, const char *name, const char *title, struct nk_rect bounds, nk_flags flags);
  /// ```
  ///
  /// Parameter   | Description
  /// ------------|-----------------------------------------------------------
  /// \param[in] ctx     | Must point to an previously initialized `nk_context` struct
  /// \param[in] name    | Window identifier. Needs to be persistent over frames to identify the window
  /// \param[in] title   | Window title displayed inside header if flag `NK_WINDOW_TITLE` or either `NK_WINDOW_CLOSABLE` or `NK_WINDOW_MINIMIZED` was set
  /// \param[in] bounds  | Initial position and window size. However if you do not define `NK_WINDOW_SCALABLE` or `NK_WINDOW_MOVABLE` you can set window position and size every frame
  /// \param[in] flags   | Window flags defined in the nk_panel_flags section with a number of different window behaviors
  ///
  /// \returns `true(1)` if the window can be filled up with widgets from this point
  /// until `nk_end` or `false(0)` otherwise for example if minimized
  int nk_begin_titled(
    ffi.Pointer<nk_context> ctx,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> title,
    nk_rect bounds,
    int flags,
  ) {
    return _nk_begin_titled(
      ctx,
      name,
      title,
      bounds,
      flags,
    );
  }

  late final _nk_begin_titledPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, nk_rect, nk_flags)>>('nk_begin_titled');
  late final _nk_begin_titled = _nk_begin_titledPtr.asFunction<
      int Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, nk_rect, int)>();

  /// # # nk_end
  /// Needs to be called at the end of the window building process to process scaling, scrollbars and general cleanup.
  /// All widget calls after this functions will result in asserts or no state changes
  ///
  /// ```c
  /// void nk_end(struct nk_context *ctx);
  /// ```
  ///
  /// Parameter   | Description
  /// ------------|-----------------------------------------------------------
  /// \param[in] ctx     | Must point to an previously initialized `nk_context` struct
  void nk_end(
    ffi.Pointer<nk_context> ctx,
  ) {
    return _nk_end(
      ctx,
    );
  }

  late final _nk_endPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<nk_context>)>>(
          'nk_end');
  late final _nk_end =
      _nk_endPtr.asFunction<void Function(ffi.Pointer<nk_context>)>();

  /// # # nk_window_find
  /// Finds and returns a window from passed name
  ///
  /// ```c
  /// struct nk_window *nk_window_find(struct nk_context *ctx, const char *name);
  /// ```
  ///
  /// Parameter   | Description
  /// ------------|-----------------------------------------------------------
  /// \param[in] ctx     | Must point to an previously initialized `nk_context` struct
  /// \param[in] name    | Window identifier
  ///
  /// \returns a `nk_window` struct pointing to the identified window or NULL if
  /// no window with the given name was found
  ffi.Pointer<nk_window> nk_window_find(
    ffi.Pointer<nk_context> ctx,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _nk_window_find(
      ctx,
      name,
    );
  }

  late final _nk_window_findPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<nk_window> Function(ffi.Pointer<nk_context>,
              ffi.Pointer<ffi.Char>)>>('nk_window_find');
  late final _nk_window_find = _nk_window_findPtr.asFunction<
      ffi.Pointer<nk_window> Function(
          ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>)>();

  /// # # nk_window_get_bounds
  /// \returns a rectangle with screen position and size of the currently processed window
  ///
  /// !!! \warning
  /// Only call this function between calls `nk_begin_xxx` and `nk_end`
  /// ```c
  /// struct nk_rect nk_window_get_bounds(const struct nk_context *ctx);
  /// ```
  ///
  /// Parameter   | Description
  /// ------------|-----------------------------------------------------------
  /// \param[in] ctx     | Must point to an previously initialized `nk_context` struct
  ///
  /// \returns a `nk_rect` struct with window upper left window position and size
  nk_rect nk_window_get_bounds(
    ffi.Pointer<nk_context> ctx,
  ) {
    return _nk_window_get_bounds(
      ctx,
    );
  }

  late final _nk_window_get_boundsPtr =
      _lookup<ffi.NativeFunction<nk_rect Function(ffi.Pointer<nk_context>)>>(
          'nk_window_get_bounds');
  late final _nk_window_get_bounds = _nk_window_get_boundsPtr
      .asFunction<nk_rect Function(ffi.Pointer<nk_context>)>();

  /// # # nk_window_get_position
  /// \returns the position of the currently processed window.
  ///
  /// !!! \warning
  /// Only call this function between calls `nk_begin_xxx` and `nk_end`
  /// ```c
  /// struct nk_vec2 nk_window_get_position(const struct nk_context *ctx);
  /// ```
  ///
  /// Parameter   | Description
  /// ------------|-----------------------------------------------------------
  /// \param[in] ctx     | Must point to an previously initialized `nk_context` struct
  ///
  /// \returns a `nk_vec2` struct with window upper left position
  nk_vec2 nk_window_get_position(
    ffi.Pointer<nk_context> ctx,
  ) {
    return _nk_window_get_position(
      ctx,
    );
  }

  late final _nk_window_get_positionPtr =
      _lookup<ffi.NativeFunction<nk_vec2 Function(ffi.Pointer<nk_context>)>>(
          'nk_window_get_position');
  late final _nk_window_get_position = _nk_window_get_positionPtr
      .asFunction<nk_vec2 Function(ffi.Pointer<nk_context>)>();

  /// # # nk_window_get_size
  /// \returns the size with width and height of the currently processed window.
  ///
  /// !!! \warning
  /// Only call this function between calls `nk_begin_xxx` and `nk_end`
  /// ```c
  /// struct nk_vec2 nk_window_get_size(const struct nk_context *ctx);
  /// ```
  ///
  /// Parameter   | Description
  /// ------------|-----------------------------------------------------------
  /// \param[in] ctx     | Must point to an previously initialized `nk_context` struct
  ///
  /// \returns a `nk_vec2` struct with window width and height
  nk_vec2 nk_window_get_size(
    ffi.Pointer<nk_context> ctx,
  ) {
    return _nk_window_get_size(
      ctx,
    );
  }

  late final _nk_window_get_sizePtr =
      _lookup<ffi.NativeFunction<nk_vec2 Function(ffi.Pointer<nk_context>)>>(
          'nk_window_get_size');
  late final _nk_window_get_size = _nk_window_get_sizePtr
      .asFunction<nk_vec2 Function(ffi.Pointer<nk_context>)>();

  /// nk_window_get_width
  /// \returns the width of the currently processed window.
  ///
  /// !!! \warning
  /// Only call this function between calls `nk_begin_xxx` and `nk_end`
  /// ```c
  /// float nk_window_get_width(const struct nk_context *ctx);
  /// ```
  ///
  /// Parameter   | Description
  /// ------------|-----------------------------------------------------------
  /// \param[in] ctx     | Must point to an previously initialized `nk_context` struct
  ///
  /// \returns the current window width
  double nk_window_get_width(
    ffi.Pointer<nk_context> ctx,
  ) {
    return _nk_window_get_width(
      ctx,
    );
  }

  late final _nk_window_get_widthPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Pointer<nk_context>)>>(
          'nk_window_get_width');
  late final _nk_window_get_width = _nk_window_get_widthPtr
      .asFunction<double Function(ffi.Pointer<nk_context>)>();

  /// # # nk_window_get_height
  /// \returns the height of the currently processed window.
  ///
  /// !!! \warning
  /// Only call this function between calls `nk_begin_xxx` and `nk_end`
  /// ```c
  /// float nk_window_get_height(const struct nk_context *ctx);
  /// ```
  ///
  /// Parameter   | Description
  /// ------------|-----------------------------------------------------------
  /// \param[in] ctx     | Must point to an previously initialized `nk_context` struct
  ///
  /// \returns the current window height
  double nk_window_get_height(
    ffi.Pointer<nk_context> ctx,
  ) {
    return _nk_window_get_height(
      ctx,
    );
  }

  late final _nk_window_get_heightPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Pointer<nk_context>)>>(
          'nk_window_get_height');
  late final _nk_window_get_height = _nk_window_get_heightPtr
      .asFunction<double Function(ffi.Pointer<nk_context>)>();

  /// # # nk_window_get_panel
  /// \returns the underlying panel which contains all processing state of the current window.
  ///
  /// !!! \warning
  /// Only call this function between calls `nk_begin_xxx` and `nk_end`
  /// !!! \warning
  /// Do not keep the returned panel pointer around, it is only valid until `nk_end`
  /// ```c
  /// struct nk_panel* nk_window_get_panel(struct nk_context *ctx);
  /// ```
  ///
  /// Parameter   | Description
  /// ------------|-----------------------------------------------------------
  /// \param[in] ctx     | Must point to an previously initialized `nk_context` struct
  ///
  /// \returns a pointer to window internal `nk_panel` state.
  ffi.Pointer<nk_panel> nk_window_get_panel(
    ffi.Pointer<nk_context> ctx,
  ) {
    return _nk_window_get_panel(
      ctx,
    );
  }

  late final _nk_window_get_panelPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<nk_panel> Function(
              ffi.Pointer<nk_context>)>>('nk_window_get_panel');
  late final _nk_window_get_panel = _nk_window_get_panelPtr
      .asFunction<ffi.Pointer<nk_panel> Function(ffi.Pointer<nk_context>)>();

  /// # # nk_window_get_content_region
  /// \returns the position and size of the currently visible and non-clipped space
  /// inside the currently processed window.
  ///
  /// !!! \warning
  /// Only call this function between calls `nk_begin_xxx` and `nk_end`
  ///
  /// ```c
  /// struct nk_rect nk_window_get_content_region(struct nk_context *ctx);
  /// ```
  ///
  /// Parameter   | Description
  /// ------------|-----------------------------------------------------------
  /// \param[in] ctx     | Must point to an previously initialized `nk_context` struct
  ///
  /// \returns `nk_rect` struct with screen position and size (no scrollbar offset)
  /// of the visible space inside the current window
  nk_rect nk_window_get_content_region(
    ffi.Pointer<nk_context> ctx,
  ) {
    return _nk_window_get_content_region(
      ctx,
    );
  }

  late final _nk_window_get_content_regionPtr =
      _lookup<ffi.NativeFunction<nk_rect Function(ffi.Pointer<nk_context>)>>(
          'nk_window_get_content_region');
  late final _nk_window_get_content_region = _nk_window_get_content_regionPtr
      .asFunction<nk_rect Function(ffi.Pointer<nk_context>)>();

  /// # # nk_window_get_content_region_min
  /// \returns the upper left position of the currently visible and non-clipped
  /// space inside the currently processed window.
  ///
  /// !!! \warning
  /// Only call this function between calls `nk_begin_xxx` and `nk_end`
  ///
  /// ```c
  /// struct nk_vec2 nk_window_get_content_region_min(struct nk_context *ctx);
  /// ```
  ///
  /// Parameter   | Description
  /// ------------|-----------------------------------------------------------
  /// \param[in] ctx     | Must point to an previously initialized `nk_context` struct
  ///
  /// returns `nk_vec2` struct with  upper left screen position (no scrollbar offset)
  /// of the visible space inside the current window
  nk_vec2 nk_window_get_content_region_min(
    ffi.Pointer<nk_context> ctx,
  ) {
    return _nk_window_get_content_region_min(
      ctx,
    );
  }

  late final _nk_window_get_content_region_minPtr =
      _lookup<ffi.NativeFunction<nk_vec2 Function(ffi.Pointer<nk_context>)>>(
          'nk_window_get_content_region_min');
  late final _nk_window_get_content_region_min =
      _nk_window_get_content_region_minPtr
          .asFunction<nk_vec2 Function(ffi.Pointer<nk_context>)>();

  /// # # nk_window_get_content_region_max
  /// \returns the lower right screen position of the currently visible and
  /// non-clipped space inside the currently processed window.
  ///
  /// !!! \warning
  /// Only call this function between calls `nk_begin_xxx` and `nk_end`
  ///
  /// ```c
  /// struct nk_vec2 nk_window_get_content_region_max(struct nk_context *ctx);
  /// ```
  ///
  /// Parameter   | Description
  /// ------------|-----------------------------------------------------------
  /// \param[in] ctx     | Must point to an previously initialized `nk_context` struct
  ///
  /// \returns `nk_vec2` struct with lower right screen position (no scrollbar offset)
  /// of the visible space inside the current window
  nk_vec2 nk_window_get_content_region_max(
    ffi.Pointer<nk_context> ctx,
  ) {
    return _nk_window_get_content_region_max(
      ctx,
    );
  }

  late final _nk_window_get_content_region_maxPtr =
      _lookup<ffi.NativeFunction<nk_vec2 Function(ffi.Pointer<nk_context>)>>(
          'nk_window_get_content_region_max');
  late final _nk_window_get_content_region_max =
      _nk_window_get_content_region_maxPtr
          .asFunction<nk_vec2 Function(ffi.Pointer<nk_context>)>();

  /// # # nk_window_get_content_region_size
  /// \returns the size of the currently visible and non-clipped space inside the
  /// currently processed window
  ///
  /// !!! \warning
  /// Only call this function between calls `nk_begin_xxx` and `nk_end`
  ///
  /// ```c
  /// struct nk_vec2 nk_window_get_content_region_size(struct nk_context *ctx);
  /// ```
  ///
  /// Parameter   | Description
  /// ------------|-----------------------------------------------------------
  /// \param[in] ctx     | Must point to an previously initialized `nk_context` struct
  ///
  /// \returns `nk_vec2` struct with size the visible space inside the current window
  nk_vec2 nk_window_get_content_region_size(
    ffi.Pointer<nk_context> ctx,
  ) {
    return _nk_window_get_content_region_size(
      ctx,
    );
  }

  late final _nk_window_get_content_region_sizePtr =
      _lookup<ffi.NativeFunction<nk_vec2 Function(ffi.Pointer<nk_context>)>>(
          'nk_window_get_content_region_size');
  late final _nk_window_get_content_region_size =
      _nk_window_get_content_region_sizePtr
          .asFunction<nk_vec2 Function(ffi.Pointer<nk_context>)>();

  /// # # nk_window_get_canvas
  /// \returns the draw command buffer. Can be used to draw custom widgets
  /// !!! \warning
  /// Only call this function between calls `nk_begin_xxx` and `nk_end`
  /// !!! \warning
  /// Do not keep the returned command buffer pointer around it is only valid until `nk_end`
  ///
  /// ```c
  /// struct nk_command_buffer* nk_window_get_canvas(struct nk_context *ctx);
  /// ```
  ///
  /// Parameter   | Description
  /// ------------|-----------------------------------------------------------
  /// \param[in] ctx     | Must point to an previously initialized `nk_context` struct
  ///
  /// \returns a pointer to window internal `nk_command_buffer` struct used as
  /// drawing canvas. Can be used to do custom drawing.
  ffi.Pointer<nk_command_buffer> nk_window_get_canvas(
    ffi.Pointer<nk_context> ctx,
  ) {
    return _nk_window_get_canvas(
      ctx,
    );
  }

  late final _nk_window_get_canvasPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<nk_command_buffer> Function(
              ffi.Pointer<nk_context>)>>('nk_window_get_canvas');
  late final _nk_window_get_canvas = _nk_window_get_canvasPtr.asFunction<
      ffi.Pointer<nk_command_buffer> Function(ffi.Pointer<nk_context>)>();

  /// # # nk_window_get_scroll
  /// Gets the scroll offset for the current window
  /// !!! \warning
  /// Only call this function between calls `nk_begin_xxx` and `nk_end`
  ///
  /// ```c
  /// void nk_window_get_scroll(struct nk_context *ctx, nk_uint *offset_x, nk_uint *offset_y);
  /// ```
  ///
  /// Parameter    | Description
  /// -------------|-----------------------------------------------------------
  /// \param[in] ctx      | Must point to an previously initialized `nk_context` struct
  /// \param[in] offset_x | A pointer to the x offset output (or NULL to ignore)
  /// \param[in] offset_y | A pointer to the y offset output (or NULL to ignore)
  void nk_window_get_scroll(
    ffi.Pointer<nk_context> ctx,
    ffi.Pointer<nk_uint> offset_x,
    ffi.Pointer<nk_uint> offset_y,
  ) {
    return _nk_window_get_scroll(
      ctx,
      offset_x,
      offset_y,
    );
  }

  late final _nk_window_get_scrollPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_context>, ffi.Pointer<nk_uint>,
              ffi.Pointer<nk_uint>)>>('nk_window_get_scroll');
  late final _nk_window_get_scroll = _nk_window_get_scrollPtr.asFunction<
      void Function(ffi.Pointer<nk_context>, ffi.Pointer<nk_uint>,
          ffi.Pointer<nk_uint>)>();

  /// # # nk_window_has_focus
  /// \returns if the currently processed window is currently active
  /// !!! \warning
  /// Only call this function between calls `nk_begin_xxx` and `nk_end`
  /// ```c
  /// nk_bool nk_window_has_focus(const struct nk_context *ctx);
  /// ```
  ///
  /// Parameter   | Description
  /// ------------|-----------------------------------------------------------
  /// \param[in] ctx     | Must point to an previously initialized `nk_context` struct
  ///
  /// \returns `false(0)` if current window is not active or `true(1)` if it is
  int nk_window_has_focus(
    ffi.Pointer<nk_context> ctx,
  ) {
    return _nk_window_has_focus(
      ctx,
    );
  }

  late final _nk_window_has_focusPtr =
      _lookup<ffi.NativeFunction<nk_bool Function(ffi.Pointer<nk_context>)>>(
          'nk_window_has_focus');
  late final _nk_window_has_focus = _nk_window_has_focusPtr
      .asFunction<int Function(ffi.Pointer<nk_context>)>();

  /// # # nk_window_is_hovered
  /// Return if the current window is being hovered
  /// !!! \warning
  /// Only call this function between calls `nk_begin_xxx` and `nk_end`
  /// ```c
  /// nk_bool nk_window_is_hovered(struct nk_context *ctx);
  /// ```
  ///
  /// Parameter   | Description
  /// ------------|-----------------------------------------------------------
  /// \param[in] ctx     | Must point to an previously initialized `nk_context` struct
  ///
  /// \returns `true(1)` if current window is hovered or `false(0)` otherwise
  int nk_window_is_hovered(
    ffi.Pointer<nk_context> ctx,
  ) {
    return _nk_window_is_hovered(
      ctx,
    );
  }

  late final _nk_window_is_hoveredPtr =
      _lookup<ffi.NativeFunction<nk_bool Function(ffi.Pointer<nk_context>)>>(
          'nk_window_is_hovered');
  late final _nk_window_is_hovered = _nk_window_is_hoveredPtr
      .asFunction<int Function(ffi.Pointer<nk_context>)>();

  /// # # nk_window_is_collapsed
  /// \returns if the window with given name is currently minimized/collapsed
  /// ```c
  /// nk_bool nk_window_is_collapsed(struct nk_context *ctx, const char *name);
  /// ```
  ///
  /// Parameter   | Description
  /// ------------|-----------------------------------------------------------
  /// \param[in] ctx     | Must point to an previously initialized `nk_context` struct
  /// \param[in] name    | Identifier of window you want to check if it is collapsed
  ///
  /// \returns `true(1)` if current window is minimized and `false(0)` if window not
  /// found or is not minimized
  int nk_window_is_collapsed(
    ffi.Pointer<nk_context> ctx,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _nk_window_is_collapsed(
      ctx,
      name,
    );
  }

  late final _nk_window_is_collapsedPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(ffi.Pointer<nk_context>,
              ffi.Pointer<ffi.Char>)>>('nk_window_is_collapsed');
  late final _nk_window_is_collapsed = _nk_window_is_collapsedPtr.asFunction<
      int Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>)>();

  /// # # nk_window_is_closed
  /// \returns if the window with given name was closed by calling `nk_close`
  /// ```c
  /// nk_bool nk_window_is_closed(struct nk_context *ctx, const char *name);
  /// ```
  ///
  /// Parameter   | Description
  /// ------------|-----------------------------------------------------------
  /// \param[in] ctx     | Must point to an previously initialized `nk_context` struct
  /// \param[in] name    | Identifier of window you want to check if it is closed
  ///
  /// \returns `true(1)` if current window was closed or `false(0)` window not found or not closed
  int nk_window_is_closed(
    ffi.Pointer<nk_context> ctx,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _nk_window_is_closed(
      ctx,
      name,
    );
  }

  late final _nk_window_is_closedPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(ffi.Pointer<nk_context>,
              ffi.Pointer<ffi.Char>)>>('nk_window_is_closed');
  late final _nk_window_is_closed = _nk_window_is_closedPtr.asFunction<
      int Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>)>();

  /// # # nk_window_is_hidden
  /// \returns if the window with given name is hidden
  /// ```c
  /// nk_bool nk_window_is_hidden(struct nk_context *ctx, const char *name);
  /// ```
  ///
  /// Parameter   | Description
  /// ------------|-----------------------------------------------------------
  /// \param[in] ctx     | Must point to an previously initialized `nk_context` struct
  /// \param[in] name    | Identifier of window you want to check if it is hidden
  ///
  /// \returns `true(1)` if current window is hidden or `false(0)` window not found or visible
  int nk_window_is_hidden(
    ffi.Pointer<nk_context> ctx,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _nk_window_is_hidden(
      ctx,
      name,
    );
  }

  late final _nk_window_is_hiddenPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(ffi.Pointer<nk_context>,
              ffi.Pointer<ffi.Char>)>>('nk_window_is_hidden');
  late final _nk_window_is_hidden = _nk_window_is_hiddenPtr.asFunction<
      int Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>)>();

  /// # # nk_window_is_active
  /// Same as nk_window_has_focus for some reason
  /// ```c
  /// nk_bool nk_window_is_active(struct nk_context *ctx, const char *name);
  /// ```
  ///
  /// Parameter   | Description
  /// ------------|-----------------------------------------------------------
  /// \param[in] ctx     | Must point to an previously initialized `nk_context` struct
  /// \param[in] name    | Identifier of window you want to check if it is active
  ///
  /// \returns `true(1)` if current window is active or `false(0)` window not found or not active
  int nk_window_is_active(
    ffi.Pointer<nk_context> ctx,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _nk_window_is_active(
      ctx,
      name,
    );
  }

  late final _nk_window_is_activePtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(ffi.Pointer<nk_context>,
              ffi.Pointer<ffi.Char>)>>('nk_window_is_active');
  late final _nk_window_is_active = _nk_window_is_activePtr.asFunction<
      int Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>)>();

  /// # # nk_window_is_any_hovered
  /// \returns if the any window is being hovered
  /// ```c
  /// nk_bool nk_window_is_any_hovered(struct nk_context*);
  /// ```
  ///
  /// Parameter   | Description
  /// ------------|-----------------------------------------------------------
  /// \param[in] ctx     | Must point to an previously initialized `nk_context` struct
  ///
  /// \returns `true(1)` if any window is hovered or `false(0)` otherwise
  int nk_window_is_any_hovered(
    ffi.Pointer<nk_context> ctx,
  ) {
    return _nk_window_is_any_hovered(
      ctx,
    );
  }

  late final _nk_window_is_any_hoveredPtr =
      _lookup<ffi.NativeFunction<nk_bool Function(ffi.Pointer<nk_context>)>>(
          'nk_window_is_any_hovered');
  late final _nk_window_is_any_hovered = _nk_window_is_any_hoveredPtr
      .asFunction<int Function(ffi.Pointer<nk_context>)>();

  /// # # nk_item_is_any_active
  /// \returns if the any window is being hovered or any widget is currently active.
  /// Can be used to decide if input should be processed by UI or your specific input handling.
  /// Example could be UI and 3D camera to move inside a 3D space.
  /// ```c
  /// nk_bool nk_item_is_any_active(struct nk_context*);
  /// ```
  ///
  /// Parameter   | Description
  /// ------------|-----------------------------------------------------------
  /// \param[in] ctx     | Must point to an previously initialized `nk_context` struct
  ///
  /// \returns `true(1)` if any window is hovered or any item is active or `false(0)` otherwise
  int nk_item_is_any_active(
    ffi.Pointer<nk_context> ctx,
  ) {
    return _nk_item_is_any_active(
      ctx,
    );
  }

  late final _nk_item_is_any_activePtr =
      _lookup<ffi.NativeFunction<nk_bool Function(ffi.Pointer<nk_context>)>>(
          'nk_item_is_any_active');
  late final _nk_item_is_any_active = _nk_item_is_any_activePtr
      .asFunction<int Function(ffi.Pointer<nk_context>)>();

  /// # # nk_window_set_bounds
  /// Updates position and size of window with passed in name
  /// ```c
  /// void nk_window_set_bounds(struct nk_context*, const char *name, struct nk_rect bounds);
  /// ```
  ///
  /// Parameter   | Description
  /// ------------|-----------------------------------------------------------
  /// \param[in] ctx     | Must point to an previously initialized `nk_context` struct
  /// \param[in] name    | Identifier of the window to modify both position and size
  /// \param[in] bounds  | Must point to a `nk_rect` struct with the new position and size
  void nk_window_set_bounds(
    ffi.Pointer<nk_context> ctx,
    ffi.Pointer<ffi.Char> name,
    nk_rect bounds,
  ) {
    return _nk_window_set_bounds(
      ctx,
      name,
      bounds,
    );
  }

  late final _nk_window_set_boundsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>,
              nk_rect)>>('nk_window_set_bounds');
  late final _nk_window_set_bounds = _nk_window_set_boundsPtr.asFunction<
      void Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>, nk_rect)>();

  /// # # nk_window_set_position
  /// Updates position of window with passed name
  /// ```c
  /// void nk_window_set_position(struct nk_context*, const char *name, struct nk_vec2 pos);
  /// ```
  ///
  /// Parameter   | Description
  /// ------------|-----------------------------------------------------------
  /// \param[in] ctx     | Must point to an previously initialized `nk_context` struct
  /// \param[in] name    | Identifier of the window to modify both position
  /// \param[in] pos     | Must point to a `nk_vec2` struct with the new position
  void nk_window_set_position(
    ffi.Pointer<nk_context> ctx,
    ffi.Pointer<ffi.Char> name,
    nk_vec2 pos,
  ) {
    return _nk_window_set_position(
      ctx,
      name,
      pos,
    );
  }

  late final _nk_window_set_positionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>,
              nk_vec2)>>('nk_window_set_position');
  late final _nk_window_set_position = _nk_window_set_positionPtr.asFunction<
      void Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>, nk_vec2)>();

  /// # # nk_window_set_size
  /// Updates size of window with passed in name
  /// ```c
  /// void nk_window_set_size(struct nk_context*, const char *name, struct nk_vec2);
  /// ```
  ///
  /// Parameter   | Description
  /// ------------|-----------------------------------------------------------
  /// \param[in] ctx     | Must point to an previously initialized `nk_context` struct
  /// \param[in] name    | Identifier of the window to modify both window size
  /// \param[in] size    | Must point to a `nk_vec2` struct with new window size
  void nk_window_set_size(
    ffi.Pointer<nk_context> ctx,
    ffi.Pointer<ffi.Char> name,
    nk_vec2 size,
  ) {
    return _nk_window_set_size(
      ctx,
      name,
      size,
    );
  }

  late final _nk_window_set_sizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>,
              nk_vec2)>>('nk_window_set_size');
  late final _nk_window_set_size = _nk_window_set_sizePtr.asFunction<
      void Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>, nk_vec2)>();

  /// # # nk_window_set_focus
  /// Sets the window with given name as active
  /// ```c
  /// void nk_window_set_focus(struct nk_context*, const char *name);
  /// ```
  ///
  /// Parameter   | Description
  /// ------------|-----------------------------------------------------------
  /// \param[in] ctx     | Must point to an previously initialized `nk_context` struct
  /// \param[in] name    | Identifier of the window to set focus on
  void nk_window_set_focus(
    ffi.Pointer<nk_context> ctx,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _nk_window_set_focus(
      ctx,
      name,
    );
  }

  late final _nk_window_set_focusPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_context>,
              ffi.Pointer<ffi.Char>)>>('nk_window_set_focus');
  late final _nk_window_set_focus = _nk_window_set_focusPtr.asFunction<
      void Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>)>();

  /// # # nk_window_set_scroll
  /// Sets the scroll offset for the current window
  /// !!! \warning
  /// Only call this function between calls `nk_begin_xxx` and `nk_end`
  ///
  /// ```c
  /// void nk_window_set_scroll(struct nk_context *ctx, nk_uint offset_x, nk_uint offset_y);
  /// ```
  ///
  /// Parameter    | Description
  /// -------------|-----------------------------------------------------------
  /// \param[in] ctx      | Must point to an previously initialized `nk_context` struct
  /// \param[in] offset_x | The x offset to scroll to
  /// \param[in] offset_y | The y offset to scroll to
  void nk_window_set_scroll(
    ffi.Pointer<nk_context> ctx,
    int offset_x,
    int offset_y,
  ) {
    return _nk_window_set_scroll(
      ctx,
      offset_x,
      offset_y,
    );
  }

  late final _nk_window_set_scrollPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_context>, nk_uint,
              nk_uint)>>('nk_window_set_scroll');
  late final _nk_window_set_scroll = _nk_window_set_scrollPtr
      .asFunction<void Function(ffi.Pointer<nk_context>, int, int)>();

  /// # # nk_window_close
  /// Closes a window and marks it for being freed at the end of the frame
  /// ```c
  /// void nk_window_close(struct nk_context *ctx, const char *name);
  /// ```
  ///
  /// Parameter   | Description
  /// ------------|-----------------------------------------------------------
  /// \param[in] ctx     | Must point to an previously initialized `nk_context` struct
  /// \param[in] name    | Identifier of the window to close
  void nk_window_close(
    ffi.Pointer<nk_context> ctx,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _nk_window_close(
      ctx,
      name,
    );
  }

  late final _nk_window_closePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_context>,
              ffi.Pointer<ffi.Char>)>>('nk_window_close');
  late final _nk_window_close = _nk_window_closePtr.asFunction<
      void Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>)>();

  /// # # nk_window_collapse
  /// Updates collapse state of a window with given name
  /// ```c
  /// void nk_window_collapse(struct nk_context*, const char *name, enum nk_collapse_states state);
  /// ```
  ///
  /// Parameter   | Description
  /// ------------|-----------------------------------------------------------
  /// \param[in] ctx     | Must point to an previously initialized `nk_context` struct
  /// \param[in] name    | Identifier of the window to close
  /// \param[in] state   | value out of nk_collapse_states section
  void nk_window_collapse(
    ffi.Pointer<nk_context> ctx,
    ffi.Pointer<ffi.Char> name,
    int state,
  ) {
    return _nk_window_collapse(
      ctx,
      name,
      state,
    );
  }

  late final _nk_window_collapsePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>,
              ffi.Int32)>>('nk_window_collapse');
  late final _nk_window_collapse = _nk_window_collapsePtr.asFunction<
      void Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>, int)>();

  /// # # nk_window_collapse_if
  /// Updates collapse state of a window with given name if given condition is met
  /// ```c
  /// void nk_window_collapse_if(struct nk_context*, const char *name, enum nk_collapse_states, int cond);
  /// ```
  ///
  /// Parameter   | Description
  /// ------------|-----------------------------------------------------------
  /// \param[in] ctx     | Must point to an previously initialized `nk_context` struct
  /// \param[in] name    | Identifier of the window to either collapse or maximize
  /// \param[in] state   | value out of nk_collapse_states section the window should be put into
  /// \param[in] cond    | condition that has to be met to actually commit the collapse state change
  void nk_window_collapse_if(
    ffi.Pointer<nk_context> ctx,
    ffi.Pointer<ffi.Char> name,
    int state,
    int cond,
  ) {
    return _nk_window_collapse_if(
      ctx,
      name,
      state,
      cond,
    );
  }

  late final _nk_window_collapse_ifPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>,
              ffi.Int32, ffi.Int)>>('nk_window_collapse_if');
  late final _nk_window_collapse_if = _nk_window_collapse_ifPtr.asFunction<
      void Function(
          ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>, int, int)>();

  /// # # nk_window_show
  /// updates visibility state of a window with given name
  /// ```c
  /// void nk_window_show(struct nk_context*, const char *name, enum nk_show_states);
  /// ```
  ///
  /// Parameter   | Description
  /// ------------|-----------------------------------------------------------
  /// \param[in] ctx     | Must point to an previously initialized `nk_context` struct
  /// \param[in] name    | Identifier of the window to either collapse or maximize
  /// \param[in] state   | state with either visible or hidden to modify the window with
  void nk_window_show(
    ffi.Pointer<nk_context> ctx,
    ffi.Pointer<ffi.Char> name,
    int state,
  ) {
    return _nk_window_show(
      ctx,
      name,
      state,
    );
  }

  late final _nk_window_showPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>,
              ffi.Int32)>>('nk_window_show');
  late final _nk_window_show = _nk_window_showPtr.asFunction<
      void Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>, int)>();

  /// # # nk_window_show_if
  /// Updates visibility state of a window with given name if a given condition is met
  /// ```c
  /// void nk_window_show_if(struct nk_context*, const char *name, enum nk_show_states, int cond);
  /// ```
  ///
  /// Parameter   | Description
  /// ------------|-----------------------------------------------------------
  /// \param[in] ctx     | Must point to an previously initialized `nk_context` struct
  /// \param[in] name    | Identifier of the window to either hide or show
  /// \param[in] state   | state with either visible or hidden to modify the window with
  /// \param[in] cond    | condition that has to be met to actually commit the visibility state change
  void nk_window_show_if(
    ffi.Pointer<nk_context> ctx,
    ffi.Pointer<ffi.Char> name,
    int state,
    int cond,
  ) {
    return _nk_window_show_if(
      ctx,
      name,
      state,
      cond,
    );
  }

  late final _nk_window_show_ifPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>,
              ffi.Int32, ffi.Int)>>('nk_window_show_if');
  late final _nk_window_show_if = _nk_window_show_ifPtr.asFunction<
      void Function(
          ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>, int, int)>();

  /// # # nk_window_show_if
  /// Line for visual separation. Draws a line with thickness determined by the current row height.
  /// ```c
  /// void nk_rule_horizontal(struct nk_context *ctx, struct nk_color color, NK_BOOL rounding)
  /// ```
  ///
  /// Parameter       | Description
  /// ----------------|-------------------------------------------------------
  /// \param[in] ctx         | Must point to an previously initialized `nk_context` struct
  /// \param[in] color       | Color of the horizontal line
  /// \param[in] rounding    | Whether or not to make the line round
  void nk_rule_horizontal(
    ffi.Pointer<nk_context> ctx,
    nk_color color,
    int rounding,
  ) {
    return _nk_rule_horizontal(
      ctx,
      color,
      rounding,
    );
  }

  late final _nk_rule_horizontalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_context>, nk_color,
              nk_bool)>>('nk_rule_horizontal');
  late final _nk_rule_horizontal = _nk_rule_horizontalPtr
      .asFunction<void Function(ffi.Pointer<nk_context>, nk_color, int)>();

  /// Sets the currently used minimum row height.
  /// !!! \warning
  /// The passed height needs to include both your preferred row height
  /// as well as padding. No internal padding is added.
  ///
  /// ```c
  /// void nk_layout_set_min_row_height(struct nk_context*, float height);
  /// ```
  ///
  /// \param[in] ctx     | Must point to an previously initialized `nk_context` struct after call `nk_begin_xxx`
  /// \param[in] height  | New minimum row height to be used for auto generating the row height
  void nk_layout_set_min_row_height(
    ffi.Pointer<nk_context> arg0,
    double height,
  ) {
    return _nk_layout_set_min_row_height(
      arg0,
      height,
    );
  }

  late final _nk_layout_set_min_row_heightPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_context>,
              ffi.Float)>>('nk_layout_set_min_row_height');
  late final _nk_layout_set_min_row_height = _nk_layout_set_min_row_heightPtr
      .asFunction<void Function(ffi.Pointer<nk_context>, double)>();

  /// Reset the currently used minimum row height back to `font_height + text_padding + padding`
  /// ```c
  /// void nk_layout_reset_min_row_height(struct nk_context*);
  /// ```
  ///
  /// \param[in] ctx     | Must point to an previously initialized `nk_context` struct after call `nk_begin_xxx`
  void nk_layout_reset_min_row_height(
    ffi.Pointer<nk_context> arg0,
  ) {
    return _nk_layout_reset_min_row_height(
      arg0,
    );
  }

  late final _nk_layout_reset_min_row_heightPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<nk_context>)>>(
          'nk_layout_reset_min_row_height');
  late final _nk_layout_reset_min_row_height =
      _nk_layout_reset_min_row_heightPtr
          .asFunction<void Function(ffi.Pointer<nk_context>)>();

  /// \brief Returns the width of the next row allocate by one of the layouting functions
  ///
  /// \details
  /// ```c
  /// struct nk_rect nk_layout_widget_bounds(struct nk_context*);
  /// ```
  ///
  /// \param[in] ctx     | Must point to an previously initialized `nk_context` struct after call `nk_begin_xxx`
  ///
  /// \return `nk_rect` with both position and size of the next row
  nk_rect nk_layout_widget_bounds(
    ffi.Pointer<nk_context> ctx,
  ) {
    return _nk_layout_widget_bounds(
      ctx,
    );
  }

  late final _nk_layout_widget_boundsPtr =
      _lookup<ffi.NativeFunction<nk_rect Function(ffi.Pointer<nk_context>)>>(
          'nk_layout_widget_bounds');
  late final _nk_layout_widget_bounds = _nk_layout_widget_boundsPtr
      .asFunction<nk_rect Function(ffi.Pointer<nk_context>)>();

  /// \brief Utility functions to calculate window ratio from pixel size
  ///
  /// \details
  /// ```c
  /// float nk_layout_ratio_from_pixel(struct nk_context*, float pixel_width);
  /// ```
  ///
  /// \param[in] ctx     | Must point to an previously initialized `nk_context` struct after call `nk_begin_xxx`
  /// \param[in] pixel   | Pixel_width to convert to window ratio
  ///
  /// \returns `nk_rect` with both position and size of the next row
  double nk_layout_ratio_from_pixel(
    ffi.Pointer<nk_context> ctx,
    double pixel_width,
  ) {
    return _nk_layout_ratio_from_pixel(
      ctx,
      pixel_width,
    );
  }

  late final _nk_layout_ratio_from_pixelPtr = _lookup<
      ffi.NativeFunction<
          ffi.Float Function(ffi.Pointer<nk_context>,
              ffi.Float)>>('nk_layout_ratio_from_pixel');
  late final _nk_layout_ratio_from_pixel = _nk_layout_ratio_from_pixelPtr
      .asFunction<double Function(ffi.Pointer<nk_context>, double)>();

  /// \brief Sets current row layout to share horizontal space
  /// between @cols number of widgets evenly. Once called all subsequent widget
  /// calls greater than @cols will allocate a new row with same layout.
  ///
  /// \details
  /// ```c
  /// void nk_layout_row_dynamic(struct nk_context *ctx, float height, int cols);
  /// ```
  ///
  /// \param[in] ctx     | Must point to an previously initialized `nk_context` struct after call `nk_begin_xxx`
  /// \param[in] height  | Holds height of each widget in row or zero for auto layouting
  /// \param[in] columns | Number of widget inside row
  void nk_layout_row_dynamic(
    ffi.Pointer<nk_context> ctx,
    double height,
    int cols,
  ) {
    return _nk_layout_row_dynamic(
      ctx,
      height,
      cols,
    );
  }

  late final _nk_layout_row_dynamicPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_context>, ffi.Float,
              ffi.Int)>>('nk_layout_row_dynamic');
  late final _nk_layout_row_dynamic = _nk_layout_row_dynamicPtr
      .asFunction<void Function(ffi.Pointer<nk_context>, double, int)>();

  /// \brief Sets current row layout to fill @cols number of widgets
  /// in row with same @item_width horizontal size. Once called all subsequent widget
  /// calls greater than @cols will allocate a new row with same layout.
  ///
  /// \details
  /// ```c
  /// void nk_layout_row_static(struct nk_context *ctx, float height, int item_width, int cols);
  /// ```
  ///
  /// \param[in] ctx     | Must point to an previously initialized `nk_context` struct after call `nk_begin_xxx`
  /// \param[in] height  | Holds height of each widget in row or zero for auto layouting
  /// \param[in] width   | Holds pixel width of each widget in the row
  /// \param[in] columns | Number of widget inside row
  void nk_layout_row_static(
    ffi.Pointer<nk_context> ctx,
    double height,
    int item_width,
    int cols,
  ) {
    return _nk_layout_row_static(
      ctx,
      height,
      item_width,
      cols,
    );
  }

  late final _nk_layout_row_staticPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_context>, ffi.Float, ffi.Int,
              ffi.Int)>>('nk_layout_row_static');
  late final _nk_layout_row_static = _nk_layout_row_staticPtr
      .asFunction<void Function(ffi.Pointer<nk_context>, double, int, int)>();

  /// \brief Starts a new dynamic or fixed row with given height and columns.
  ///
  /// \details
  /// ```c
  /// void nk_layout_row_begin(struct nk_context *ctx, enum nk_layout_format fmt, float row_height, int cols);
  /// ```
  ///
  /// \param[in] ctx     | Must point to an previously initialized `nk_context` struct after call `nk_begin_xxx`
  /// \param[in] fmt     | either `NK_DYNAMIC` for window ratio or `NK_STATIC` for fixed size columns
  /// \param[in] height  | holds height of each widget in row or zero for auto layouting
  /// \param[in] columns | Number of widget inside row
  void nk_layout_row_begin(
    ffi.Pointer<nk_context> ctx,
    int fmt,
    double row_height,
    int cols,
  ) {
    return _nk_layout_row_begin(
      ctx,
      fmt,
      row_height,
      cols,
    );
  }

  late final _nk_layout_row_beginPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_context>, ffi.Int32, ffi.Float,
              ffi.Int)>>('nk_layout_row_begin');
  late final _nk_layout_row_begin = _nk_layout_row_beginPtr
      .asFunction<void Function(ffi.Pointer<nk_context>, int, double, int)>();

  /// \breif Specifies either window ratio or width of a single column
  ///
  /// \details
  /// ```c
  /// void nk_layout_row_push(struct nk_context*, float value);
  /// ```
  ///
  /// \param[in] ctx     | Must point to an previously initialized `nk_context` struct after call `nk_begin_xxx`
  /// \param[in] value   | either a window ratio or fixed width depending on @fmt in previous `nk_layout_row_begin` call
  void nk_layout_row_push(
    ffi.Pointer<nk_context> arg0,
    double value,
  ) {
    return _nk_layout_row_push(
      arg0,
      value,
    );
  }

  late final _nk_layout_row_pushPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<nk_context>, ffi.Float)>>('nk_layout_row_push');
  late final _nk_layout_row_push = _nk_layout_row_pushPtr
      .asFunction<void Function(ffi.Pointer<nk_context>, double)>();

  /// \brief Finished previously started row
  ///
  /// \details
  /// ```c
  /// void nk_layout_row_end(struct nk_context*);
  /// ```
  ///
  /// \param[in] ctx     | Must point to an previously initialized `nk_context` struct after call `nk_begin_xxx`
  void nk_layout_row_end(
    ffi.Pointer<nk_context> arg0,
  ) {
    return _nk_layout_row_end(
      arg0,
    );
  }

  late final _nk_layout_row_endPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<nk_context>)>>(
          'nk_layout_row_end');
  late final _nk_layout_row_end = _nk_layout_row_endPtr
      .asFunction<void Function(ffi.Pointer<nk_context>)>();

  /// \brief Specifies row columns in array as either window ratio or size
  ///
  /// \details
  /// ```c
  /// void nk_layout_row(struct nk_context*, enum nk_layout_format, float height, int cols, const float *ratio);
  /// ```
  ///
  /// \param[in] ctx     | Must point to an previously initialized `nk_context` struct after call `nk_begin_xxx`
  /// \param[in] fmt     | Either `NK_DYNAMIC` for window ratio or `NK_STATIC` for fixed size columns
  /// \param[in] height  | Holds height of each widget in row or zero for auto layouting
  /// \param[in] columns | Number of widget inside row
  void nk_layout_row(
    ffi.Pointer<nk_context> arg0,
    int arg1,
    double height,
    int cols,
    ffi.Pointer<ffi.Float> ratio,
  ) {
    return _nk_layout_row(
      arg0,
      arg1,
      height,
      cols,
      ratio,
    );
  }

  late final _nk_layout_rowPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_context>, ffi.Int32, ffi.Float,
              ffi.Int, ffi.Pointer<ffi.Float>)>>('nk_layout_row');
  late final _nk_layout_row = _nk_layout_rowPtr.asFunction<
      void Function(
          ffi.Pointer<nk_context>, int, double, int, ffi.Pointer<ffi.Float>)>();

  /// # # nk_layout_row_template_begin
  /// Begins the row template declaration
  /// ```c
  /// void nk_layout_row_template_begin(struct nk_context*, float row_height);
  /// ```
  ///
  /// Parameter   | Description
  /// ------------|-----------------------------------------------------------
  /// \param[in] ctx     | Must point to an previously initialized `nk_context` struct after call `nk_begin_xxx`
  /// \param[in] height  | Holds height of each widget in row or zero for auto layouting
  void nk_layout_row_template_begin(
    ffi.Pointer<nk_context> arg0,
    double row_height,
  ) {
    return _nk_layout_row_template_begin(
      arg0,
      row_height,
    );
  }

  late final _nk_layout_row_template_beginPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_context>,
              ffi.Float)>>('nk_layout_row_template_begin');
  late final _nk_layout_row_template_begin = _nk_layout_row_template_beginPtr
      .asFunction<void Function(ffi.Pointer<nk_context>, double)>();

  /// # # nk_layout_row_template_push_dynamic
  /// Adds a dynamic column that dynamically grows and can go to zero if not enough space
  /// ```c
  /// void nk_layout_row_template_push_dynamic(struct nk_context*);
  /// ```
  ///
  /// Parameter   | Description
  /// ------------|-----------------------------------------------------------
  /// \param[in] ctx     | Must point to an previously initialized `nk_context` struct after call `nk_begin_xxx`
  /// \param[in] height  | Holds height of each widget in row or zero for auto layouting
  void nk_layout_row_template_push_dynamic(
    ffi.Pointer<nk_context> arg0,
  ) {
    return _nk_layout_row_template_push_dynamic(
      arg0,
    );
  }

  late final _nk_layout_row_template_push_dynamicPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<nk_context>)>>(
          'nk_layout_row_template_push_dynamic');
  late final _nk_layout_row_template_push_dynamic =
      _nk_layout_row_template_push_dynamicPtr
          .asFunction<void Function(ffi.Pointer<nk_context>)>();

  /// # # nk_layout_row_template_push_variable
  /// Adds a variable column that dynamically grows but does not shrink below specified pixel width
  /// ```c
  /// void nk_layout_row_template_push_variable(struct nk_context*, float min_width);
  /// ```
  ///
  /// Parameter   | Description
  /// ------------|-----------------------------------------------------------
  /// \param[in] ctx     | Must point to an previously initialized `nk_context` struct after call `nk_begin_xxx`
  /// \param[in] width   | Holds the minimum pixel width the next column must always be
  void nk_layout_row_template_push_variable(
    ffi.Pointer<nk_context> arg0,
    double min_width,
  ) {
    return _nk_layout_row_template_push_variable(
      arg0,
      min_width,
    );
  }

  late final _nk_layout_row_template_push_variablePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_context>,
              ffi.Float)>>('nk_layout_row_template_push_variable');
  late final _nk_layout_row_template_push_variable =
      _nk_layout_row_template_push_variablePtr
          .asFunction<void Function(ffi.Pointer<nk_context>, double)>();

  /// # # nk_layout_row_template_push_static
  /// Adds a static column that does not grow and will always have the same size
  /// ```c
  /// void nk_layout_row_template_push_static(struct nk_context*, float width);
  /// ```
  ///
  /// Parameter   | Description
  /// ------------|-----------------------------------------------------------
  /// \param[in] ctx     | Must point to an previously initialized `nk_context` struct after call `nk_begin_xxx`
  /// \param[in] width   | Holds the absolute pixel width value the next column must be
  void nk_layout_row_template_push_static(
    ffi.Pointer<nk_context> arg0,
    double width,
  ) {
    return _nk_layout_row_template_push_static(
      arg0,
      width,
    );
  }

  late final _nk_layout_row_template_push_staticPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_context>,
              ffi.Float)>>('nk_layout_row_template_push_static');
  late final _nk_layout_row_template_push_static =
      _nk_layout_row_template_push_staticPtr
          .asFunction<void Function(ffi.Pointer<nk_context>, double)>();

  /// # # nk_layout_row_template_end
  /// Marks the end of the row template
  /// ```c
  /// void nk_layout_row_template_end(struct nk_context*);
  /// ```
  ///
  /// Parameter   | Description
  /// ------------|-----------------------------------------------------------
  /// \param[in] ctx     | Must point to an previously initialized `nk_context` struct after call `nk_begin_xxx`
  void nk_layout_row_template_end(
    ffi.Pointer<nk_context> arg0,
  ) {
    return _nk_layout_row_template_end(
      arg0,
    );
  }

  late final _nk_layout_row_template_endPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<nk_context>)>>(
          'nk_layout_row_template_end');
  late final _nk_layout_row_template_end = _nk_layout_row_template_endPtr
      .asFunction<void Function(ffi.Pointer<nk_context>)>();

  /// # # nk_layout_space_begin
  /// Begins a new layouting space that allows to specify each widgets position and size.
  /// ```c
  /// void nk_layout_space_begin(struct nk_context*, enum nk_layout_format, float height, int widget_count);
  /// ```
  ///
  /// Parameter   | Description
  /// ------------|-----------------------------------------------------------
  /// \param[in] ctx     | Must point to an previously initialized `nk_context` struct after call `nk_begin_xxx`
  /// \param[in] fmt     | Either `NK_DYNAMIC` for window ratio or `NK_STATIC` for fixed size columns
  /// \param[in] height  | Holds height of each widget in row or zero for auto layouting
  /// \param[in] columns | Number of widgets inside row
  void nk_layout_space_begin(
    ffi.Pointer<nk_context> arg0,
    int arg1,
    double height,
    int widget_count,
  ) {
    return _nk_layout_space_begin(
      arg0,
      arg1,
      height,
      widget_count,
    );
  }

  late final _nk_layout_space_beginPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_context>, ffi.Int32, ffi.Float,
              ffi.Int)>>('nk_layout_space_begin');
  late final _nk_layout_space_begin = _nk_layout_space_beginPtr
      .asFunction<void Function(ffi.Pointer<nk_context>, int, double, int)>();

  /// # # nk_layout_space_push
  /// Pushes position and size of the next widget in own coordinate space either as pixel or ratio
  /// ```c
  /// void nk_layout_space_push(struct nk_context *ctx, struct nk_rect bounds);
  /// ```
  ///
  /// Parameter   | Description
  /// ------------|-----------------------------------------------------------
  /// \param[in] ctx     | Must point to an previously initialized `nk_context` struct after call `nk_layout_space_begin`
  /// \param[in] bounds  | Position and size in laoyut space local coordinates
  void nk_layout_space_push(
    ffi.Pointer<nk_context> arg0,
    nk_rect bounds,
  ) {
    return _nk_layout_space_push(
      arg0,
      bounds,
    );
  }

  late final _nk_layout_space_pushPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<nk_context>, nk_rect)>>(
      'nk_layout_space_push');
  late final _nk_layout_space_push = _nk_layout_space_pushPtr
      .asFunction<void Function(ffi.Pointer<nk_context>, nk_rect)>();

  /// # # nk_layout_space_end
  /// Marks the end of the layout space
  /// ```c
  /// void nk_layout_space_end(struct nk_context*);
  /// ```
  ///
  /// Parameter   | Description
  /// ------------|-----------------------------------------------------------
  /// \param[in] ctx     | Must point to an previously initialized `nk_context` struct after call `nk_layout_space_begin`
  void nk_layout_space_end(
    ffi.Pointer<nk_context> arg0,
  ) {
    return _nk_layout_space_end(
      arg0,
    );
  }

  late final _nk_layout_space_endPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<nk_context>)>>(
          'nk_layout_space_end');
  late final _nk_layout_space_end = _nk_layout_space_endPtr
      .asFunction<void Function(ffi.Pointer<nk_context>)>();

  /// # # nk_layout_space_bounds
  /// Utility function to calculate total space allocated for `nk_layout_space`
  /// ```c
  /// struct nk_rect nk_layout_space_bounds(struct nk_context*);
  /// ```
  ///
  /// Parameter   | Description
  /// ------------|-----------------------------------------------------------
  /// \param[in] ctx     | Must point to an previously initialized `nk_context` struct after call `nk_layout_space_begin`
  ///
  /// \returns `nk_rect` holding the total space allocated
  nk_rect nk_layout_space_bounds(
    ffi.Pointer<nk_context> ctx,
  ) {
    return _nk_layout_space_bounds(
      ctx,
    );
  }

  late final _nk_layout_space_boundsPtr =
      _lookup<ffi.NativeFunction<nk_rect Function(ffi.Pointer<nk_context>)>>(
          'nk_layout_space_bounds');
  late final _nk_layout_space_bounds = _nk_layout_space_boundsPtr
      .asFunction<nk_rect Function(ffi.Pointer<nk_context>)>();

  /// # # nk_layout_space_to_screen
  /// Converts vector from nk_layout_space coordinate space into screen space
  /// ```c
  /// struct nk_vec2 nk_layout_space_to_screen(struct nk_context*, struct nk_vec2);
  /// ```
  ///
  /// Parameter   | Description
  /// ------------|-----------------------------------------------------------
  /// \param[in] ctx     | Must point to an previously initialized `nk_context` struct after call `nk_layout_space_begin`
  /// \param[in] vec     | Position to convert from layout space into screen coordinate space
  ///
  /// \returns transformed `nk_vec2` in screen space coordinates
  nk_vec2 nk_layout_space_to_screen(
    ffi.Pointer<nk_context> ctx,
    nk_vec2 vec,
  ) {
    return _nk_layout_space_to_screen(
      ctx,
      vec,
    );
  }

  late final _nk_layout_space_to_screenPtr = _lookup<
          ffi
          .NativeFunction<nk_vec2 Function(ffi.Pointer<nk_context>, nk_vec2)>>(
      'nk_layout_space_to_screen');
  late final _nk_layout_space_to_screen = _nk_layout_space_to_screenPtr
      .asFunction<nk_vec2 Function(ffi.Pointer<nk_context>, nk_vec2)>();

  /// # # nk_layout_space_to_local
  /// Converts vector from layout space into screen space
  /// ```c
  /// struct nk_vec2 nk_layout_space_to_local(struct nk_context*, struct nk_vec2);
  /// ```
  ///
  /// Parameter   | Description
  /// ------------|-----------------------------------------------------------
  /// \param[in] ctx     | Must point to an previously initialized `nk_context` struct after call `nk_layout_space_begin`
  /// \param[in] vec     | Position to convert from screen space into layout coordinate space
  ///
  /// \returns transformed `nk_vec2` in layout space coordinates
  nk_vec2 nk_layout_space_to_local(
    ffi.Pointer<nk_context> ctx,
    nk_vec2 vec,
  ) {
    return _nk_layout_space_to_local(
      ctx,
      vec,
    );
  }

  late final _nk_layout_space_to_localPtr = _lookup<
          ffi
          .NativeFunction<nk_vec2 Function(ffi.Pointer<nk_context>, nk_vec2)>>(
      'nk_layout_space_to_local');
  late final _nk_layout_space_to_local = _nk_layout_space_to_localPtr
      .asFunction<nk_vec2 Function(ffi.Pointer<nk_context>, nk_vec2)>();

  /// # # nk_layout_space_rect_to_screen
  /// Converts rectangle from screen space into layout space
  /// ```c
  /// struct nk_rect nk_layout_space_rect_to_screen(struct nk_context*, struct nk_rect);
  /// ```
  ///
  /// Parameter   | Description
  /// ------------|-----------------------------------------------------------
  /// \param[in] ctx     | Must point to an previously initialized `nk_context` struct after call `nk_layout_space_begin`
  /// \param[in] bounds  | Rectangle to convert from layout space into screen space
  ///
  /// \returns transformed `nk_rect` in screen space coordinates
  nk_rect nk_layout_space_rect_to_screen(
    ffi.Pointer<nk_context> ctx,
    nk_rect bounds,
  ) {
    return _nk_layout_space_rect_to_screen(
      ctx,
      bounds,
    );
  }

  late final _nk_layout_space_rect_to_screenPtr = _lookup<
          ffi
          .NativeFunction<nk_rect Function(ffi.Pointer<nk_context>, nk_rect)>>(
      'nk_layout_space_rect_to_screen');
  late final _nk_layout_space_rect_to_screen =
      _nk_layout_space_rect_to_screenPtr
          .asFunction<nk_rect Function(ffi.Pointer<nk_context>, nk_rect)>();

  /// # # nk_layout_space_rect_to_local
  /// Converts rectangle from layout space into screen space
  /// ```c
  /// struct nk_rect nk_layout_space_rect_to_local(struct nk_context*, struct nk_rect);
  /// ```
  ///
  /// Parameter   | Description
  /// ------------|-----------------------------------------------------------
  /// \param[in] ctx     | Must point to an previously initialized `nk_context` struct after call `nk_layout_space_begin`
  /// \param[in] bounds  | Rectangle to convert from layout space into screen space
  ///
  /// \returns transformed `nk_rect` in layout space coordinates
  nk_rect nk_layout_space_rect_to_local(
    ffi.Pointer<nk_context> ctx,
    nk_rect bounds,
  ) {
    return _nk_layout_space_rect_to_local(
      ctx,
      bounds,
    );
  }

  late final _nk_layout_space_rect_to_localPtr = _lookup<
          ffi
          .NativeFunction<nk_rect Function(ffi.Pointer<nk_context>, nk_rect)>>(
      'nk_layout_space_rect_to_local');
  late final _nk_layout_space_rect_to_local = _nk_layout_space_rect_to_localPtr
      .asFunction<nk_rect Function(ffi.Pointer<nk_context>, nk_rect)>();

  /// # # nk_spacer
  /// Spacer is a dummy widget that consumes space as usual but doesn't draw anything
  /// ```c
  /// void nk_spacer(struct nk_context* );
  /// ```
  ///
  /// Parameter   | Description
  /// ------------|-----------------------------------------------------------
  /// \param[in] ctx     | Must point to an previously initialized `nk_context` struct after call `nk_layout_space_begin`
  void nk_spacer(
    ffi.Pointer<nk_context> ctx,
  ) {
    return _nk_spacer(
      ctx,
    );
  }

  late final _nk_spacerPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<nk_context>)>>(
          'nk_spacer');
  late final _nk_spacer =
      _nk_spacerPtr.asFunction<void Function(ffi.Pointer<nk_context>)>();

  /// \brief Starts a new widget group. Requires a previous layouting function to specify a pos/size.
  /// ```c
  /// nk_bool nk_group_begin(struct nk_context*, const char *title, nk_flags);
  /// ```
  ///
  /// Parameter   | Description
  /// ------------|-----------------------------------------------------------
  /// \param[in] ctx     | Must point to an previously initialized `nk_context` struct
  /// \param[in] title   | Must be an unique identifier for this group that is also used for the group header
  /// \param[in] flags   | Window flags defined in the nk_panel_flags section with a number of different group behaviors
  ///
  /// \returns `true(1)` if visible and fillable with widgets or `false(0)` otherwise
  int nk_group_begin(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<ffi.Char> title,
    int arg2,
  ) {
    return _nk_group_begin(
      arg0,
      title,
      arg2,
    );
  }

  late final _nk_group_beginPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>,
              nk_flags)>>('nk_group_begin');
  late final _nk_group_begin = _nk_group_beginPtr.asFunction<
      int Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>, int)>();

  /// \brief Starts a new widget group. Requires a previous layouting function to specify a pos/size.
  /// ```c
  /// nk_bool nk_group_begin_titled(struct nk_context*, const char *name, const char *title, nk_flags);
  /// ```
  ///
  /// \param[in] ctx     | Must point to an previously initialized `nk_context` struct
  /// \param[in] id      | Must be an unique identifier for this group
  /// \param[in] title   | Group header title
  /// \param[in] flags   | Window flags defined in the nk_panel_flags section with a number of different group behaviors
  ///
  /// \returns `true(1)` if visible and fillable with widgets or `false(0)` otherwise
  int nk_group_begin_titled(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> title,
    int arg3,
  ) {
    return _nk_group_begin_titled(
      arg0,
      name,
      title,
      arg3,
    );
  }

  late final _nk_group_begin_titledPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, nk_flags)>>('nk_group_begin_titled');
  late final _nk_group_begin_titled = _nk_group_begin_titledPtr.asFunction<
      int Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, int)>();

  /// # # nk_group_end
  /// Ends a widget group
  /// ```c
  /// void nk_group_end(struct nk_context*);
  /// ```
  ///
  /// Parameter   | Description
  /// ------------|-----------------------------------------------------------
  /// \param[in] ctx     | Must point to an previously initialized `nk_context` struct
  void nk_group_end(
    ffi.Pointer<nk_context> arg0,
  ) {
    return _nk_group_end(
      arg0,
    );
  }

  late final _nk_group_endPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<nk_context>)>>(
          'nk_group_end');
  late final _nk_group_end =
      _nk_group_endPtr.asFunction<void Function(ffi.Pointer<nk_context>)>();

  /// # # nk_group_scrolled_offset_begin
  /// starts a new widget group. requires a previous layouting function to specify
  /// a size. Does not keep track of scrollbar.
  /// ```c
  /// nk_bool nk_group_scrolled_offset_begin(struct nk_context*, nk_uint *x_offset, nk_uint *y_offset, const char *title, nk_flags flags);
  /// ```
  ///
  /// Parameter   | Description
  /// ------------|-----------------------------------------------------------
  /// \param[in] ctx     | Must point to an previously initialized `nk_context` struct
  /// \param[in] x_offset| Scrollbar x-offset to offset all widgets inside the group horizontally.
  /// \param[in] y_offset| Scrollbar y-offset to offset all widgets inside the group vertically
  /// \param[in] title   | Window unique group title used to both identify and display in the group header
  /// \param[in] flags   | Window flags from the nk_panel_flags section
  ///
  /// \returns `true(1)` if visible and fillable with widgets or `false(0)` otherwise
  int nk_group_scrolled_offset_begin(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<nk_uint> x_offset,
    ffi.Pointer<nk_uint> y_offset,
    ffi.Pointer<ffi.Char> title,
    int flags,
  ) {
    return _nk_group_scrolled_offset_begin(
      arg0,
      x_offset,
      y_offset,
      title,
      flags,
    );
  }

  late final _nk_group_scrolled_offset_beginPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(
              ffi.Pointer<nk_context>,
              ffi.Pointer<nk_uint>,
              ffi.Pointer<nk_uint>,
              ffi.Pointer<ffi.Char>,
              nk_flags)>>('nk_group_scrolled_offset_begin');
  late final _nk_group_scrolled_offset_begin =
      _nk_group_scrolled_offset_beginPtr.asFunction<
          int Function(ffi.Pointer<nk_context>, ffi.Pointer<nk_uint>,
              ffi.Pointer<nk_uint>, ffi.Pointer<ffi.Char>, int)>();

  /// # # nk_group_scrolled_begin
  /// Starts a new widget group. requires a previous
  /// layouting function to specify a size. Does not keep track of scrollbar.
  /// ```c
  /// nk_bool nk_group_scrolled_begin(struct nk_context*, struct nk_scroll *off, const char *title, nk_flags);
  /// ```
  ///
  /// Parameter   | Description
  /// ------------|-----------------------------------------------------------
  /// \param[in] ctx     | Must point to an previously initialized `nk_context` struct
  /// \param[in] off     | Both x- and y- scroll offset. Allows for manual scrollbar control
  /// \param[in] title   | Window unique group title used to both identify and display in the group header
  /// \param[in] flags   | Window flags from nk_panel_flags section
  ///
  /// \returns `true(1)` if visible and fillable with widgets or `false(0)` otherwise
  int nk_group_scrolled_begin(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<nk_scroll> off,
    ffi.Pointer<ffi.Char> title,
    int arg3,
  ) {
    return _nk_group_scrolled_begin(
      arg0,
      off,
      title,
      arg3,
    );
  }

  late final _nk_group_scrolled_beginPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(ffi.Pointer<nk_context>, ffi.Pointer<nk_scroll>,
              ffi.Pointer<ffi.Char>, nk_flags)>>('nk_group_scrolled_begin');
  late final _nk_group_scrolled_begin = _nk_group_scrolled_beginPtr.asFunction<
      int Function(ffi.Pointer<nk_context>, ffi.Pointer<nk_scroll>,
          ffi.Pointer<ffi.Char>, int)>();

  /// # # nk_group_scrolled_end
  /// Ends a widget group after calling nk_group_scrolled_offset_begin or nk_group_scrolled_begin.
  /// ```c
  /// void nk_group_scrolled_end(struct nk_context*);
  /// ```
  ///
  /// Parameter   | Description
  /// ------------|-----------------------------------------------------------
  /// \param[in] ctx     | Must point to an previously initialized `nk_context` struct
  void nk_group_scrolled_end(
    ffi.Pointer<nk_context> arg0,
  ) {
    return _nk_group_scrolled_end(
      arg0,
    );
  }

  late final _nk_group_scrolled_endPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<nk_context>)>>(
          'nk_group_scrolled_end');
  late final _nk_group_scrolled_end = _nk_group_scrolled_endPtr
      .asFunction<void Function(ffi.Pointer<nk_context>)>();

  /// # # nk_group_get_scroll
  /// Gets the scroll position of the given group.
  /// ```c
  /// void nk_group_get_scroll(struct nk_context*, const char *id, nk_uint *x_offset, nk_uint *y_offset);
  /// ```
  ///
  /// Parameter    | Description
  /// -------------|-----------------------------------------------------------
  /// \param[in] ctx      | Must point to an previously initialized `nk_context` struct
  /// \param[in] id       | The id of the group to get the scroll position of
  /// \param[in] x_offset | A pointer to the x offset output (or NULL to ignore)
  /// \param[in] y_offset | A pointer to the y offset output (or NULL to ignore)
  void nk_group_get_scroll(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<ffi.Char> id,
    ffi.Pointer<nk_uint> x_offset,
    ffi.Pointer<nk_uint> y_offset,
  ) {
    return _nk_group_get_scroll(
      arg0,
      id,
      x_offset,
      y_offset,
    );
  }

  late final _nk_group_get_scrollPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<nk_context>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<nk_uint>,
              ffi.Pointer<nk_uint>)>>('nk_group_get_scroll');
  late final _nk_group_get_scroll = _nk_group_get_scrollPtr.asFunction<
      void Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<nk_uint>, ffi.Pointer<nk_uint>)>();

  /// # # nk_group_set_scroll
  /// Sets the scroll position of the given group.
  /// ```c
  /// void nk_group_set_scroll(struct nk_context*, const char *id, nk_uint x_offset, nk_uint y_offset);
  /// ```
  ///
  /// Parameter    | Description
  /// -------------|-----------------------------------------------------------
  /// \param[in] ctx      | Must point to an previously initialized `nk_context` struct
  /// \param[in] id       | The id of the group to scroll
  /// \param[in] x_offset | The x offset to scroll to
  /// \param[in] y_offset | The y offset to scroll to
  void nk_group_set_scroll(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<ffi.Char> id,
    int x_offset,
    int y_offset,
  ) {
    return _nk_group_set_scroll(
      arg0,
      id,
      x_offset,
      y_offset,
    );
  }

  late final _nk_group_set_scrollPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>,
              nk_uint, nk_uint)>>('nk_group_set_scroll');
  late final _nk_group_set_scroll = _nk_group_set_scrollPtr.asFunction<
      void Function(
          ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>, int, int)>();

  /// # # nk_tree_push_hashed
  /// Start a collapsible UI section with internal state management with full
  /// control over internal unique ID used to store state
  /// ```c
  /// nk_bool nk_tree_push_hashed(struct nk_context*, enum nk_tree_type, const char *title, enum nk_collapse_states initial_state, const char *hash, int len,int seed);
  /// ```
  ///
  /// Parameter   | Description
  /// ------------|-----------------------------------------------------------
  /// \param[in] ctx     | Must point to an previously initialized `nk_context` struct
  /// \param[in] type    | Value from the nk_tree_type section to visually mark a tree node header as either a collapseable UI section or tree node
  /// \param[in] title   | Label printed in the tree header
  /// \param[in] state   | Initial tree state value out of nk_collapse_states
  /// \param[in] hash    | Memory block or string to generate the ID from
  /// \param[in] len     | Size of passed memory block or string in __hash__
  /// \param[in] seed    | Seeding value if this function is called in a loop or default to `0`
  ///
  /// \returns `true(1)` if visible and fillable with widgets or `false(0)` otherwise
  int nk_tree_push_hashed(
    ffi.Pointer<nk_context> arg0,
    int arg1,
    ffi.Pointer<ffi.Char> title,
    int initial_state,
    ffi.Pointer<ffi.Char> hash,
    int len,
    int seed,
  ) {
    return _nk_tree_push_hashed(
      arg0,
      arg1,
      title,
      initial_state,
      hash,
      len,
      seed,
    );
  }

  late final _nk_tree_push_hashedPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(
              ffi.Pointer<nk_context>,
              ffi.Int32,
              ffi.Pointer<ffi.Char>,
              ffi.Int32,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              ffi.Int)>>('nk_tree_push_hashed');
  late final _nk_tree_push_hashed = _nk_tree_push_hashedPtr.asFunction<
      int Function(ffi.Pointer<nk_context>, int, ffi.Pointer<ffi.Char>, int,
          ffi.Pointer<ffi.Char>, int, int)>();

  /// # # nk_tree_image_push_hashed
  /// Start a collapsible UI section with internal state management with full
  /// control over internal unique ID used to store state
  /// ```c
  /// nk_bool nk_tree_image_push_hashed(struct nk_context*, enum nk_tree_type, struct nk_image, const char *title, enum nk_collapse_states initial_state, const char *hash, int len,int seed);
  /// ```
  ///
  /// Parameter   | Description
  /// ------------|-----------------------------------------------------------
  /// \param[in] ctx     | Must point to an previously initialized `nk_context` struct
  /// \param[in] type    | Value from the nk_tree_type section to visually mark a tree node header as either a collapseable UI section or tree node
  /// \param[in] img     | Image to display inside the header on the left of the label
  /// \param[in] title   | Label printed in the tree header
  /// \param[in] state   | Initial tree state value out of nk_collapse_states
  /// \param[in] hash    | Memory block or string to generate the ID from
  /// \param[in] len     | Size of passed memory block or string in __hash__
  /// \param[in] seed    | Seeding value if this function is called in a loop or default to `0`
  ///
  /// \returns `true(1)` if visible and fillable with widgets or `false(0)` otherwise
  int nk_tree_image_push_hashed(
    ffi.Pointer<nk_context> arg0,
    int arg1,
    nk_image arg2,
    ffi.Pointer<ffi.Char> title,
    int initial_state,
    ffi.Pointer<ffi.Char> hash,
    int len,
    int seed,
  ) {
    return _nk_tree_image_push_hashed(
      arg0,
      arg1,
      arg2,
      title,
      initial_state,
      hash,
      len,
      seed,
    );
  }

  late final _nk_tree_image_push_hashedPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(
              ffi.Pointer<nk_context>,
              ffi.Int32,
              nk_image,
              ffi.Pointer<ffi.Char>,
              ffi.Int32,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              ffi.Int)>>('nk_tree_image_push_hashed');
  late final _nk_tree_image_push_hashed =
      _nk_tree_image_push_hashedPtr.asFunction<
          int Function(ffi.Pointer<nk_context>, int, nk_image,
              ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>, int, int)>();

  /// # # nk_tree_pop
  /// Ends a collapsabale UI section
  /// ```c
  /// void nk_tree_pop(struct nk_context*);
  /// ```
  ///
  /// Parameter   | Description
  /// ------------|-----------------------------------------------------------
  /// \param[in] ctx     | Must point to an previously initialized `nk_context` struct after calling `nk_tree_xxx_push_xxx`
  void nk_tree_pop(
    ffi.Pointer<nk_context> arg0,
  ) {
    return _nk_tree_pop(
      arg0,
    );
  }

  late final _nk_tree_popPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<nk_context>)>>(
          'nk_tree_pop');
  late final _nk_tree_pop =
      _nk_tree_popPtr.asFunction<void Function(ffi.Pointer<nk_context>)>();

  /// # # nk_tree_state_push
  /// Start a collapsible UI section with external state management
  /// ```c
  /// nk_bool nk_tree_state_push(struct nk_context*, enum nk_tree_type, const char *title, enum nk_collapse_states *state);
  /// ```
  ///
  /// Parameter   | Description
  /// ------------|-----------------------------------------------------------
  /// \param[in] ctx     | Must point to an previously initialized `nk_context` struct after calling `nk_tree_xxx_push_xxx`
  /// \param[in] type    | Value from the nk_tree_type section to visually mark a tree node header as either a collapseable UI section or tree node
  /// \param[in] title   | Label printed in the tree header
  /// \param[in] state   | Persistent state to update
  ///
  /// \returns `true(1)` if visible and fillable with widgets or `false(0)` otherwise
  int nk_tree_state_push(
    ffi.Pointer<nk_context> arg0,
    int arg1,
    ffi.Pointer<ffi.Char> title,
    ffi.Pointer<ffi.Int32> state,
  ) {
    return _nk_tree_state_push(
      arg0,
      arg1,
      title,
      state,
    );
  }

  late final _nk_tree_state_pushPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(
              ffi.Pointer<nk_context>,
              ffi.Int32,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Int32>)>>('nk_tree_state_push');
  late final _nk_tree_state_push = _nk_tree_state_pushPtr.asFunction<
      int Function(ffi.Pointer<nk_context>, int, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Int32>)>();

  /// # # nk_tree_state_image_push
  /// Start a collapsible UI section with image and label header and external state management
  /// ```c
  /// nk_bool nk_tree_state_image_push(struct nk_context*, enum nk_tree_type, struct nk_image, const char *title, enum nk_collapse_states *state);
  /// ```
  ///
  /// Parameter   | Description
  /// ------------|-----------------------------------------------------------
  /// \param[in] ctx     | Must point to an previously initialized `nk_context` struct after calling `nk_tree_xxx_push_xxx`
  /// \param[in] img     | Image to display inside the header on the left of the label
  /// \param[in] type    | Value from the nk_tree_type section to visually mark a tree node header as either a collapseable UI section or tree node
  /// \param[in] title   | Label printed in the tree header
  /// \param[in] state   | Persistent state to update
  ///
  /// \returns `true(1)` if visible and fillable with widgets or `false(0)` otherwise
  int nk_tree_state_image_push(
    ffi.Pointer<nk_context> arg0,
    int arg1,
    nk_image arg2,
    ffi.Pointer<ffi.Char> title,
    ffi.Pointer<ffi.Int32> state,
  ) {
    return _nk_tree_state_image_push(
      arg0,
      arg1,
      arg2,
      title,
      state,
    );
  }

  late final _nk_tree_state_image_pushPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(
              ffi.Pointer<nk_context>,
              ffi.Int32,
              nk_image,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Int32>)>>('nk_tree_state_image_push');
  late final _nk_tree_state_image_push =
      _nk_tree_state_image_pushPtr.asFunction<
          int Function(ffi.Pointer<nk_context>, int, nk_image,
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Int32>)>();

  /// # # nk_tree_state_pop
  /// Ends a collapsabale UI section
  /// ```c
  /// void nk_tree_state_pop(struct nk_context*);
  /// ```
  ///
  /// Parameter   | Description
  /// ------------|-----------------------------------------------------------
  /// \param[in] ctx     | Must point to an previously initialized `nk_context` struct after calling `nk_tree_xxx_push_xxx`
  void nk_tree_state_pop(
    ffi.Pointer<nk_context> arg0,
  ) {
    return _nk_tree_state_pop(
      arg0,
    );
  }

  late final _nk_tree_state_popPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<nk_context>)>>(
          'nk_tree_state_pop');
  late final _nk_tree_state_pop = _nk_tree_state_popPtr
      .asFunction<void Function(ffi.Pointer<nk_context>)>();

  int nk_tree_element_push_hashed(
    ffi.Pointer<nk_context> arg0,
    int arg1,
    ffi.Pointer<ffi.Char> title,
    int initial_state,
    ffi.Pointer<nk_bool> selected,
    ffi.Pointer<ffi.Char> hash,
    int len,
    int seed,
  ) {
    return _nk_tree_element_push_hashed(
      arg0,
      arg1,
      title,
      initial_state,
      selected,
      hash,
      len,
      seed,
    );
  }

  late final _nk_tree_element_push_hashedPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(
              ffi.Pointer<nk_context>,
              ffi.Int32,
              ffi.Pointer<ffi.Char>,
              ffi.Int32,
              ffi.Pointer<nk_bool>,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              ffi.Int)>>('nk_tree_element_push_hashed');
  late final _nk_tree_element_push_hashed =
      _nk_tree_element_push_hashedPtr.asFunction<
          int Function(ffi.Pointer<nk_context>, int, ffi.Pointer<ffi.Char>, int,
              ffi.Pointer<nk_bool>, ffi.Pointer<ffi.Char>, int, int)>();

  int nk_tree_element_image_push_hashed(
    ffi.Pointer<nk_context> arg0,
    int arg1,
    nk_image arg2,
    ffi.Pointer<ffi.Char> title,
    int initial_state,
    ffi.Pointer<nk_bool> selected,
    ffi.Pointer<ffi.Char> hash,
    int len,
    int seed,
  ) {
    return _nk_tree_element_image_push_hashed(
      arg0,
      arg1,
      arg2,
      title,
      initial_state,
      selected,
      hash,
      len,
      seed,
    );
  }

  late final _nk_tree_element_image_push_hashedPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(
              ffi.Pointer<nk_context>,
              ffi.Int32,
              nk_image,
              ffi.Pointer<ffi.Char>,
              ffi.Int32,
              ffi.Pointer<nk_bool>,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              ffi.Int)>>('nk_tree_element_image_push_hashed');
  late final _nk_tree_element_image_push_hashed =
      _nk_tree_element_image_push_hashedPtr.asFunction<
          int Function(
              ffi.Pointer<nk_context>,
              int,
              nk_image,
              ffi.Pointer<ffi.Char>,
              int,
              ffi.Pointer<nk_bool>,
              ffi.Pointer<ffi.Char>,
              int,
              int)>();

  void nk_tree_element_pop(
    ffi.Pointer<nk_context> arg0,
  ) {
    return _nk_tree_element_pop(
      arg0,
    );
  }

  late final _nk_tree_element_popPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<nk_context>)>>(
          'nk_tree_element_pop');
  late final _nk_tree_element_pop = _nk_tree_element_popPtr
      .asFunction<void Function(ffi.Pointer<nk_context>)>();

  int nk_list_view_begin(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<nk_list_view> out,
    ffi.Pointer<ffi.Char> id,
    int arg3,
    int row_height,
    int row_count,
  ) {
    return _nk_list_view_begin(
      arg0,
      out,
      id,
      arg3,
      row_height,
      row_count,
    );
  }

  late final _nk_list_view_beginPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(
              ffi.Pointer<nk_context>,
              ffi.Pointer<nk_list_view>,
              ffi.Pointer<ffi.Char>,
              nk_flags,
              ffi.Int,
              ffi.Int)>>('nk_list_view_begin');
  late final _nk_list_view_begin = _nk_list_view_beginPtr.asFunction<
      int Function(ffi.Pointer<nk_context>, ffi.Pointer<nk_list_view>,
          ffi.Pointer<ffi.Char>, int, int, int)>();

  void nk_list_view_end(
    ffi.Pointer<nk_list_view> arg0,
  ) {
    return _nk_list_view_end(
      arg0,
    );
  }

  late final _nk_list_view_endPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<nk_list_view>)>>(
          'nk_list_view_end');
  late final _nk_list_view_end = _nk_list_view_endPtr
      .asFunction<void Function(ffi.Pointer<nk_list_view>)>();

  int nk_widget(
    ffi.Pointer<nk_rect> arg0,
    ffi.Pointer<nk_context> arg1,
  ) {
    return _nk_widget(
      arg0,
      arg1,
    );
  }

  late final _nk_widgetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<nk_rect>, ffi.Pointer<nk_context>)>>('nk_widget');
  late final _nk_widget = _nk_widgetPtr.asFunction<
      int Function(ffi.Pointer<nk_rect>, ffi.Pointer<nk_context>)>();

  int nk_widget_fitting(
    ffi.Pointer<nk_rect> arg0,
    ffi.Pointer<nk_context> arg1,
    nk_vec2 arg2,
  ) {
    return _nk_widget_fitting(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _nk_widget_fittingPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<nk_rect>, ffi.Pointer<nk_context>,
              nk_vec2)>>('nk_widget_fitting');
  late final _nk_widget_fitting = _nk_widget_fittingPtr.asFunction<
      int Function(ffi.Pointer<nk_rect>, ffi.Pointer<nk_context>, nk_vec2)>();

  nk_rect nk_widget_bounds(
    ffi.Pointer<nk_context> arg0,
  ) {
    return _nk_widget_bounds(
      arg0,
    );
  }

  late final _nk_widget_boundsPtr =
      _lookup<ffi.NativeFunction<nk_rect Function(ffi.Pointer<nk_context>)>>(
          'nk_widget_bounds');
  late final _nk_widget_bounds = _nk_widget_boundsPtr
      .asFunction<nk_rect Function(ffi.Pointer<nk_context>)>();

  nk_vec2 nk_widget_position(
    ffi.Pointer<nk_context> arg0,
  ) {
    return _nk_widget_position(
      arg0,
    );
  }

  late final _nk_widget_positionPtr =
      _lookup<ffi.NativeFunction<nk_vec2 Function(ffi.Pointer<nk_context>)>>(
          'nk_widget_position');
  late final _nk_widget_position = _nk_widget_positionPtr
      .asFunction<nk_vec2 Function(ffi.Pointer<nk_context>)>();

  nk_vec2 nk_widget_size(
    ffi.Pointer<nk_context> arg0,
  ) {
    return _nk_widget_size(
      arg0,
    );
  }

  late final _nk_widget_sizePtr =
      _lookup<ffi.NativeFunction<nk_vec2 Function(ffi.Pointer<nk_context>)>>(
          'nk_widget_size');
  late final _nk_widget_size = _nk_widget_sizePtr
      .asFunction<nk_vec2 Function(ffi.Pointer<nk_context>)>();

  double nk_widget_width(
    ffi.Pointer<nk_context> arg0,
  ) {
    return _nk_widget_width(
      arg0,
    );
  }

  late final _nk_widget_widthPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Pointer<nk_context>)>>(
          'nk_widget_width');
  late final _nk_widget_width = _nk_widget_widthPtr
      .asFunction<double Function(ffi.Pointer<nk_context>)>();

  double nk_widget_height(
    ffi.Pointer<nk_context> arg0,
  ) {
    return _nk_widget_height(
      arg0,
    );
  }

  late final _nk_widget_heightPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Pointer<nk_context>)>>(
          'nk_widget_height');
  late final _nk_widget_height = _nk_widget_heightPtr
      .asFunction<double Function(ffi.Pointer<nk_context>)>();

  int nk_widget_is_hovered(
    ffi.Pointer<nk_context> arg0,
  ) {
    return _nk_widget_is_hovered(
      arg0,
    );
  }

  late final _nk_widget_is_hoveredPtr =
      _lookup<ffi.NativeFunction<nk_bool Function(ffi.Pointer<nk_context>)>>(
          'nk_widget_is_hovered');
  late final _nk_widget_is_hovered = _nk_widget_is_hoveredPtr
      .asFunction<int Function(ffi.Pointer<nk_context>)>();

  int nk_widget_is_mouse_clicked(
    ffi.Pointer<nk_context> arg0,
    int arg1,
  ) {
    return _nk_widget_is_mouse_clicked(
      arg0,
      arg1,
    );
  }

  late final _nk_widget_is_mouse_clickedPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(ffi.Pointer<nk_context>,
              ffi.Int32)>>('nk_widget_is_mouse_clicked');
  late final _nk_widget_is_mouse_clicked = _nk_widget_is_mouse_clickedPtr
      .asFunction<int Function(ffi.Pointer<nk_context>, int)>();

  int nk_widget_has_mouse_click_down(
    ffi.Pointer<nk_context> arg0,
    int arg1,
    int down,
  ) {
    return _nk_widget_has_mouse_click_down(
      arg0,
      arg1,
      down,
    );
  }

  late final _nk_widget_has_mouse_click_downPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(ffi.Pointer<nk_context>, ffi.Int32,
              nk_bool)>>('nk_widget_has_mouse_click_down');
  late final _nk_widget_has_mouse_click_down =
      _nk_widget_has_mouse_click_downPtr
          .asFunction<int Function(ffi.Pointer<nk_context>, int, int)>();

  void nk_spacing(
    ffi.Pointer<nk_context> arg0,
    int cols,
  ) {
    return _nk_spacing(
      arg0,
      cols,
    );
  }

  late final _nk_spacingPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_context>, ffi.Int)>>('nk_spacing');
  late final _nk_spacing =
      _nk_spacingPtr.asFunction<void Function(ffi.Pointer<nk_context>, int)>();

  void nk_widget_disable_begin(
    ffi.Pointer<nk_context> ctx,
  ) {
    return _nk_widget_disable_begin(
      ctx,
    );
  }

  late final _nk_widget_disable_beginPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<nk_context>)>>(
          'nk_widget_disable_begin');
  late final _nk_widget_disable_begin = _nk_widget_disable_beginPtr
      .asFunction<void Function(ffi.Pointer<nk_context>)>();

  void nk_widget_disable_end(
    ffi.Pointer<nk_context> ctx,
  ) {
    return _nk_widget_disable_end(
      ctx,
    );
  }

  late final _nk_widget_disable_endPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<nk_context>)>>(
          'nk_widget_disable_end');
  late final _nk_widget_disable_end = _nk_widget_disable_endPtr
      .asFunction<void Function(ffi.Pointer<nk_context>)>();

  void nk_text(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
    int arg3,
  ) {
    return _nk_text(
      arg0,
      arg1,
      arg2,
      arg3,
    );
  }

  late final _nk_textPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>,
              ffi.Int, nk_flags)>>('nk_text');
  late final _nk_text = _nk_textPtr.asFunction<
      void Function(
          ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>, int, int)>();

  void nk_text_colored(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
    int arg3,
    nk_color arg4,
  ) {
    return _nk_text_colored(
      arg0,
      arg1,
      arg2,
      arg3,
      arg4,
    );
  }

  late final _nk_text_coloredPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>,
              ffi.Int, nk_flags, nk_color)>>('nk_text_colored');
  late final _nk_text_colored = _nk_text_coloredPtr.asFunction<
      void Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>, int, int,
          nk_color)>();

  void nk_text_wrap(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
  ) {
    return _nk_text_wrap(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _nk_text_wrapPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>,
              ffi.Int)>>('nk_text_wrap');
  late final _nk_text_wrap = _nk_text_wrapPtr.asFunction<
      void Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>, int)>();

  void nk_text_wrap_colored(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
    nk_color arg3,
  ) {
    return _nk_text_wrap_colored(
      arg0,
      arg1,
      arg2,
      arg3,
    );
  }

  late final _nk_text_wrap_coloredPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>,
              ffi.Int, nk_color)>>('nk_text_wrap_colored');
  late final _nk_text_wrap_colored = _nk_text_wrap_coloredPtr.asFunction<
      void Function(
          ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>, int, nk_color)>();

  void nk_label(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<ffi.Char> arg1,
    int align,
  ) {
    return _nk_label(
      arg0,
      arg1,
      align,
    );
  }

  late final _nk_labelPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>,
              nk_flags)>>('nk_label');
  late final _nk_label = _nk_labelPtr.asFunction<
      void Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>, int)>();

  void nk_label_colored(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<ffi.Char> arg1,
    int align,
    nk_color arg3,
  ) {
    return _nk_label_colored(
      arg0,
      arg1,
      align,
      arg3,
    );
  }

  late final _nk_label_coloredPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>,
              nk_flags, nk_color)>>('nk_label_colored');
  late final _nk_label_colored = _nk_label_coloredPtr.asFunction<
      void Function(
          ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>, int, nk_color)>();

  void nk_label_wrap(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<ffi.Char> arg1,
  ) {
    return _nk_label_wrap(
      arg0,
      arg1,
    );
  }

  late final _nk_label_wrapPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_context>,
              ffi.Pointer<ffi.Char>)>>('nk_label_wrap');
  late final _nk_label_wrap = _nk_label_wrapPtr.asFunction<
      void Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>)>();

  void nk_label_colored_wrap(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<ffi.Char> arg1,
    nk_color arg2,
  ) {
    return _nk_label_colored_wrap(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _nk_label_colored_wrapPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>,
              nk_color)>>('nk_label_colored_wrap');
  late final _nk_label_colored_wrap = _nk_label_colored_wrapPtr.asFunction<
      void Function(
          ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>, nk_color)>();

  void nk_image1(
    ffi.Pointer<nk_context> arg0,
    nk_image arg1,
  ) {
    return _nk_image1(
      arg0,
      arg1,
    );
  }

  late final _nk_image1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_context>, nk_image)>>('nk_image');
  late final _nk_image1 = _nk_image1Ptr
      .asFunction<void Function(ffi.Pointer<nk_context>, nk_image)>();

  void nk_image_color(
    ffi.Pointer<nk_context> arg0,
    nk_image arg1,
    nk_color arg2,
  ) {
    return _nk_image_color(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _nk_image_colorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<nk_context>, nk_image, nk_color)>>('nk_image_color');
  late final _nk_image_color = _nk_image_colorPtr
      .asFunction<void Function(ffi.Pointer<nk_context>, nk_image, nk_color)>();

  void nk_labelf(
    ffi.Pointer<nk_context> arg0,
    int arg1,
    ffi.Pointer<ffi.Char> arg2,
  ) {
    return _nk_labelf(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _nk_labelfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_context>, nk_flags,
              ffi.Pointer<ffi.Char>)>>('nk_labelf');
  late final _nk_labelf = _nk_labelfPtr.asFunction<
      void Function(ffi.Pointer<nk_context>, int, ffi.Pointer<ffi.Char>)>();

  void nk_labelf_colored(
    ffi.Pointer<nk_context> arg0,
    int arg1,
    nk_color arg2,
    ffi.Pointer<ffi.Char> arg3,
  ) {
    return _nk_labelf_colored(
      arg0,
      arg1,
      arg2,
      arg3,
    );
  }

  late final _nk_labelf_coloredPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_context>, nk_flags, nk_color,
              ffi.Pointer<ffi.Char>)>>('nk_labelf_colored');
  late final _nk_labelf_colored = _nk_labelf_coloredPtr.asFunction<
      void Function(
          ffi.Pointer<nk_context>, int, nk_color, ffi.Pointer<ffi.Char>)>();

  void nk_labelf_wrap(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<ffi.Char> arg1,
  ) {
    return _nk_labelf_wrap(
      arg0,
      arg1,
    );
  }

  late final _nk_labelf_wrapPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_context>,
              ffi.Pointer<ffi.Char>)>>('nk_labelf_wrap');
  late final _nk_labelf_wrap = _nk_labelf_wrapPtr.asFunction<
      void Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>)>();

  void nk_labelf_colored_wrap(
    ffi.Pointer<nk_context> arg0,
    nk_color arg1,
    ffi.Pointer<ffi.Char> arg2,
  ) {
    return _nk_labelf_colored_wrap(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _nk_labelf_colored_wrapPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_context>, nk_color,
              ffi.Pointer<ffi.Char>)>>('nk_labelf_colored_wrap');
  late final _nk_labelf_colored_wrap = _nk_labelf_colored_wrapPtr.asFunction<
      void Function(
          ffi.Pointer<nk_context>, nk_color, ffi.Pointer<ffi.Char>)>();

  void nk_labelfv(
    ffi.Pointer<nk_context> arg0,
    int arg1,
    ffi.Pointer<ffi.Char> arg2,
    va_list arg3,
  ) {
    return _nk_labelfv(
      arg0,
      arg1,
      arg2,
      arg3,
    );
  }

  late final _nk_labelfvPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_context>, nk_flags,
              ffi.Pointer<ffi.Char>, va_list)>>('nk_labelfv');
  late final _nk_labelfv = _nk_labelfvPtr.asFunction<
      void Function(
          ffi.Pointer<nk_context>, int, ffi.Pointer<ffi.Char>, va_list)>();

  void nk_labelfv_colored(
    ffi.Pointer<nk_context> arg0,
    int arg1,
    nk_color arg2,
    ffi.Pointer<ffi.Char> arg3,
    va_list arg4,
  ) {
    return _nk_labelfv_colored(
      arg0,
      arg1,
      arg2,
      arg3,
      arg4,
    );
  }

  late final _nk_labelfv_coloredPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_context>, nk_flags, nk_color,
              ffi.Pointer<ffi.Char>, va_list)>>('nk_labelfv_colored');
  late final _nk_labelfv_colored = _nk_labelfv_coloredPtr.asFunction<
      void Function(ffi.Pointer<nk_context>, int, nk_color,
          ffi.Pointer<ffi.Char>, va_list)>();

  void nk_labelfv_wrap(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<ffi.Char> arg1,
    va_list arg2,
  ) {
    return _nk_labelfv_wrap(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _nk_labelfv_wrapPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>,
              va_list)>>('nk_labelfv_wrap');
  late final _nk_labelfv_wrap = _nk_labelfv_wrapPtr.asFunction<
      void Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>, va_list)>();

  void nk_labelfv_colored_wrap(
    ffi.Pointer<nk_context> arg0,
    nk_color arg1,
    ffi.Pointer<ffi.Char> arg2,
    va_list arg3,
  ) {
    return _nk_labelfv_colored_wrap(
      arg0,
      arg1,
      arg2,
      arg3,
    );
  }

  late final _nk_labelfv_colored_wrapPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_context>, nk_color,
              ffi.Pointer<ffi.Char>, va_list)>>('nk_labelfv_colored_wrap');
  late final _nk_labelfv_colored_wrap = _nk_labelfv_colored_wrapPtr.asFunction<
      void Function(
          ffi.Pointer<nk_context>, nk_color, ffi.Pointer<ffi.Char>, va_list)>();

  void nk_value_bool(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<ffi.Char> prefix,
    int arg2,
  ) {
    return _nk_value_bool(
      arg0,
      prefix,
      arg2,
    );
  }

  late final _nk_value_boolPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>,
              ffi.Int)>>('nk_value_bool');
  late final _nk_value_bool = _nk_value_boolPtr.asFunction<
      void Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>, int)>();

  void nk_value_int(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<ffi.Char> prefix,
    int arg2,
  ) {
    return _nk_value_int(
      arg0,
      prefix,
      arg2,
    );
  }

  late final _nk_value_intPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>,
              ffi.Int)>>('nk_value_int');
  late final _nk_value_int = _nk_value_intPtr.asFunction<
      void Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>, int)>();

  void nk_value_uint(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<ffi.Char> prefix,
    int arg2,
  ) {
    return _nk_value_uint(
      arg0,
      prefix,
      arg2,
    );
  }

  late final _nk_value_uintPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>,
              ffi.UnsignedInt)>>('nk_value_uint');
  late final _nk_value_uint = _nk_value_uintPtr.asFunction<
      void Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>, int)>();

  void nk_value_float(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<ffi.Char> prefix,
    double arg2,
  ) {
    return _nk_value_float(
      arg0,
      prefix,
      arg2,
    );
  }

  late final _nk_value_floatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>,
              ffi.Float)>>('nk_value_float');
  late final _nk_value_float = _nk_value_floatPtr.asFunction<
      void Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>, double)>();

  void nk_value_color_byte(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<ffi.Char> prefix,
    nk_color arg2,
  ) {
    return _nk_value_color_byte(
      arg0,
      prefix,
      arg2,
    );
  }

  late final _nk_value_color_bytePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>,
              nk_color)>>('nk_value_color_byte');
  late final _nk_value_color_byte = _nk_value_color_bytePtr.asFunction<
      void Function(
          ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>, nk_color)>();

  void nk_value_color_float(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<ffi.Char> prefix,
    nk_color arg2,
  ) {
    return _nk_value_color_float(
      arg0,
      prefix,
      arg2,
    );
  }

  late final _nk_value_color_floatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>,
              nk_color)>>('nk_value_color_float');
  late final _nk_value_color_float = _nk_value_color_floatPtr.asFunction<
      void Function(
          ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>, nk_color)>();

  void nk_value_color_hex(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<ffi.Char> prefix,
    nk_color arg2,
  ) {
    return _nk_value_color_hex(
      arg0,
      prefix,
      arg2,
    );
  }

  late final _nk_value_color_hexPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>,
              nk_color)>>('nk_value_color_hex');
  late final _nk_value_color_hex = _nk_value_color_hexPtr.asFunction<
      void Function(
          ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>, nk_color)>();

  int nk_button_text(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<ffi.Char> title,
    int len,
  ) {
    return _nk_button_text(
      arg0,
      title,
      len,
    );
  }

  late final _nk_button_textPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>,
              ffi.Int)>>('nk_button_text');
  late final _nk_button_text = _nk_button_textPtr.asFunction<
      int Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>, int)>();

  int nk_button_label(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<ffi.Char> title,
  ) {
    return _nk_button_label(
      arg0,
      title,
    );
  }

  late final _nk_button_labelPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(ffi.Pointer<nk_context>,
              ffi.Pointer<ffi.Char>)>>('nk_button_label');
  late final _nk_button_label = _nk_button_labelPtr.asFunction<
      int Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>)>();

  int nk_button_color(
    ffi.Pointer<nk_context> arg0,
    nk_color arg1,
  ) {
    return _nk_button_color(
      arg0,
      arg1,
    );
  }

  late final _nk_button_colorPtr = _lookup<
          ffi
          .NativeFunction<nk_bool Function(ffi.Pointer<nk_context>, nk_color)>>(
      'nk_button_color');
  late final _nk_button_color = _nk_button_colorPtr
      .asFunction<int Function(ffi.Pointer<nk_context>, nk_color)>();

  int nk_button_symbol(
    ffi.Pointer<nk_context> arg0,
    int arg1,
  ) {
    return _nk_button_symbol(
      arg0,
      arg1,
    );
  }

  late final _nk_button_symbolPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(
              ffi.Pointer<nk_context>, ffi.Int32)>>('nk_button_symbol');
  late final _nk_button_symbol = _nk_button_symbolPtr
      .asFunction<int Function(ffi.Pointer<nk_context>, int)>();

  int nk_button_image(
    ffi.Pointer<nk_context> arg0,
    nk_image img,
  ) {
    return _nk_button_image(
      arg0,
      img,
    );
  }

  late final _nk_button_imagePtr = _lookup<
          ffi
          .NativeFunction<nk_bool Function(ffi.Pointer<nk_context>, nk_image)>>(
      'nk_button_image');
  late final _nk_button_image = _nk_button_imagePtr
      .asFunction<int Function(ffi.Pointer<nk_context>, nk_image)>();

  int nk_button_symbol_label(
    ffi.Pointer<nk_context> arg0,
    int arg1,
    ffi.Pointer<ffi.Char> arg2,
    int text_alignment,
  ) {
    return _nk_button_symbol_label(
      arg0,
      arg1,
      arg2,
      text_alignment,
    );
  }

  late final _nk_button_symbol_labelPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(ffi.Pointer<nk_context>, ffi.Int32,
              ffi.Pointer<ffi.Char>, nk_flags)>>('nk_button_symbol_label');
  late final _nk_button_symbol_label = _nk_button_symbol_labelPtr.asFunction<
      int Function(ffi.Pointer<nk_context>, int, ffi.Pointer<ffi.Char>, int)>();

  int nk_button_symbol_text(
    ffi.Pointer<nk_context> arg0,
    int arg1,
    ffi.Pointer<ffi.Char> arg2,
    int arg3,
    int alignment,
  ) {
    return _nk_button_symbol_text(
      arg0,
      arg1,
      arg2,
      arg3,
      alignment,
    );
  }

  late final _nk_button_symbol_textPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(
              ffi.Pointer<nk_context>,
              ffi.Int32,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              nk_flags)>>('nk_button_symbol_text');
  late final _nk_button_symbol_text = _nk_button_symbol_textPtr.asFunction<
      int Function(
          ffi.Pointer<nk_context>, int, ffi.Pointer<ffi.Char>, int, int)>();

  int nk_button_image_label(
    ffi.Pointer<nk_context> arg0,
    nk_image img,
    ffi.Pointer<ffi.Char> arg2,
    int text_alignment,
  ) {
    return _nk_button_image_label(
      arg0,
      img,
      arg2,
      text_alignment,
    );
  }

  late final _nk_button_image_labelPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(ffi.Pointer<nk_context>, nk_image,
              ffi.Pointer<ffi.Char>, nk_flags)>>('nk_button_image_label');
  late final _nk_button_image_label = _nk_button_image_labelPtr.asFunction<
      int Function(
          ffi.Pointer<nk_context>, nk_image, ffi.Pointer<ffi.Char>, int)>();

  int nk_button_image_text(
    ffi.Pointer<nk_context> arg0,
    nk_image img,
    ffi.Pointer<ffi.Char> arg2,
    int arg3,
    int alignment,
  ) {
    return _nk_button_image_text(
      arg0,
      img,
      arg2,
      arg3,
      alignment,
    );
  }

  late final _nk_button_image_textPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(
              ffi.Pointer<nk_context>,
              nk_image,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              nk_flags)>>('nk_button_image_text');
  late final _nk_button_image_text = _nk_button_image_textPtr.asFunction<
      int Function(ffi.Pointer<nk_context>, nk_image, ffi.Pointer<ffi.Char>,
          int, int)>();

  int nk_button_text_styled(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<nk_style_button> arg1,
    ffi.Pointer<ffi.Char> title,
    int len,
  ) {
    return _nk_button_text_styled(
      arg0,
      arg1,
      title,
      len,
    );
  }

  late final _nk_button_text_styledPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(
              ffi.Pointer<nk_context>,
              ffi.Pointer<nk_style_button>,
              ffi.Pointer<ffi.Char>,
              ffi.Int)>>('nk_button_text_styled');
  late final _nk_button_text_styled = _nk_button_text_styledPtr.asFunction<
      int Function(ffi.Pointer<nk_context>, ffi.Pointer<nk_style_button>,
          ffi.Pointer<ffi.Char>, int)>();

  int nk_button_label_styled(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<nk_style_button> arg1,
    ffi.Pointer<ffi.Char> title,
  ) {
    return _nk_button_label_styled(
      arg0,
      arg1,
      title,
    );
  }

  late final _nk_button_label_styledPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(
              ffi.Pointer<nk_context>,
              ffi.Pointer<nk_style_button>,
              ffi.Pointer<ffi.Char>)>>('nk_button_label_styled');
  late final _nk_button_label_styled = _nk_button_label_styledPtr.asFunction<
      int Function(ffi.Pointer<nk_context>, ffi.Pointer<nk_style_button>,
          ffi.Pointer<ffi.Char>)>();

  int nk_button_symbol_styled(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<nk_style_button> arg1,
    int arg2,
  ) {
    return _nk_button_symbol_styled(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _nk_button_symbol_styledPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(
              ffi.Pointer<nk_context>,
              ffi.Pointer<nk_style_button>,
              ffi.Int32)>>('nk_button_symbol_styled');
  late final _nk_button_symbol_styled = _nk_button_symbol_styledPtr.asFunction<
      int Function(
          ffi.Pointer<nk_context>, ffi.Pointer<nk_style_button>, int)>();

  int nk_button_image_styled(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<nk_style_button> arg1,
    nk_image img,
  ) {
    return _nk_button_image_styled(
      arg0,
      arg1,
      img,
    );
  }

  late final _nk_button_image_styledPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(
              ffi.Pointer<nk_context>,
              ffi.Pointer<nk_style_button>,
              nk_image)>>('nk_button_image_styled');
  late final _nk_button_image_styled = _nk_button_image_styledPtr.asFunction<
      int Function(
          ffi.Pointer<nk_context>, ffi.Pointer<nk_style_button>, nk_image)>();

  int nk_button_symbol_text_styled(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<nk_style_button> arg1,
    int arg2,
    ffi.Pointer<ffi.Char> arg3,
    int arg4,
    int alignment,
  ) {
    return _nk_button_symbol_text_styled(
      arg0,
      arg1,
      arg2,
      arg3,
      arg4,
      alignment,
    );
  }

  late final _nk_button_symbol_text_styledPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(
              ffi.Pointer<nk_context>,
              ffi.Pointer<nk_style_button>,
              ffi.Int32,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              nk_flags)>>('nk_button_symbol_text_styled');
  late final _nk_button_symbol_text_styled =
      _nk_button_symbol_text_styledPtr.asFunction<
          int Function(ffi.Pointer<nk_context>, ffi.Pointer<nk_style_button>,
              int, ffi.Pointer<ffi.Char>, int, int)>();

  int nk_button_symbol_label_styled(
    ffi.Pointer<nk_context> ctx,
    ffi.Pointer<nk_style_button> style,
    int symbol,
    ffi.Pointer<ffi.Char> title,
    int align,
  ) {
    return _nk_button_symbol_label_styled(
      ctx,
      style,
      symbol,
      title,
      align,
    );
  }

  late final _nk_button_symbol_label_styledPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(
              ffi.Pointer<nk_context>,
              ffi.Pointer<nk_style_button>,
              ffi.Int32,
              ffi.Pointer<ffi.Char>,
              nk_flags)>>('nk_button_symbol_label_styled');
  late final _nk_button_symbol_label_styled =
      _nk_button_symbol_label_styledPtr.asFunction<
          int Function(ffi.Pointer<nk_context>, ffi.Pointer<nk_style_button>,
              int, ffi.Pointer<ffi.Char>, int)>();

  int nk_button_image_label_styled(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<nk_style_button> arg1,
    nk_image img,
    ffi.Pointer<ffi.Char> arg3,
    int text_alignment,
  ) {
    return _nk_button_image_label_styled(
      arg0,
      arg1,
      img,
      arg3,
      text_alignment,
    );
  }

  late final _nk_button_image_label_styledPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(
              ffi.Pointer<nk_context>,
              ffi.Pointer<nk_style_button>,
              nk_image,
              ffi.Pointer<ffi.Char>,
              nk_flags)>>('nk_button_image_label_styled');
  late final _nk_button_image_label_styled =
      _nk_button_image_label_styledPtr.asFunction<
          int Function(ffi.Pointer<nk_context>, ffi.Pointer<nk_style_button>,
              nk_image, ffi.Pointer<ffi.Char>, int)>();

  int nk_button_image_text_styled(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<nk_style_button> arg1,
    nk_image img,
    ffi.Pointer<ffi.Char> arg3,
    int arg4,
    int alignment,
  ) {
    return _nk_button_image_text_styled(
      arg0,
      arg1,
      img,
      arg3,
      arg4,
      alignment,
    );
  }

  late final _nk_button_image_text_styledPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(
              ffi.Pointer<nk_context>,
              ffi.Pointer<nk_style_button>,
              nk_image,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              nk_flags)>>('nk_button_image_text_styled');
  late final _nk_button_image_text_styled =
      _nk_button_image_text_styledPtr.asFunction<
          int Function(ffi.Pointer<nk_context>, ffi.Pointer<nk_style_button>,
              nk_image, ffi.Pointer<ffi.Char>, int, int)>();

  void nk_button_set_behavior(
    ffi.Pointer<nk_context> arg0,
    int arg1,
  ) {
    return _nk_button_set_behavior(
      arg0,
      arg1,
    );
  }

  late final _nk_button_set_behaviorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<nk_context>, ffi.Int32)>>('nk_button_set_behavior');
  late final _nk_button_set_behavior = _nk_button_set_behaviorPtr
      .asFunction<void Function(ffi.Pointer<nk_context>, int)>();

  int nk_button_push_behavior(
    ffi.Pointer<nk_context> arg0,
    int arg1,
  ) {
    return _nk_button_push_behavior(
      arg0,
      arg1,
    );
  }

  late final _nk_button_push_behaviorPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(
              ffi.Pointer<nk_context>, ffi.Int32)>>('nk_button_push_behavior');
  late final _nk_button_push_behavior = _nk_button_push_behaviorPtr
      .asFunction<int Function(ffi.Pointer<nk_context>, int)>();

  int nk_button_pop_behavior(
    ffi.Pointer<nk_context> arg0,
  ) {
    return _nk_button_pop_behavior(
      arg0,
    );
  }

  late final _nk_button_pop_behaviorPtr =
      _lookup<ffi.NativeFunction<nk_bool Function(ffi.Pointer<nk_context>)>>(
          'nk_button_pop_behavior');
  late final _nk_button_pop_behavior = _nk_button_pop_behaviorPtr
      .asFunction<int Function(ffi.Pointer<nk_context>)>();

  int nk_check_label(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<ffi.Char> arg1,
    int active,
  ) {
    return _nk_check_label(
      arg0,
      arg1,
      active,
    );
  }

  late final _nk_check_labelPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>,
              nk_bool)>>('nk_check_label');
  late final _nk_check_label = _nk_check_labelPtr.asFunction<
      int Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>, int)>();

  int nk_check_text(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
    int active,
  ) {
    return _nk_check_text(
      arg0,
      arg1,
      arg2,
      active,
    );
  }

  late final _nk_check_textPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>,
              ffi.Int, nk_bool)>>('nk_check_text');
  late final _nk_check_text = _nk_check_textPtr.asFunction<
      int Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>, int, int)>();

  int nk_check_text_align(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
    int active,
    int widget_alignment,
    int text_alignment,
  ) {
    return _nk_check_text_align(
      arg0,
      arg1,
      arg2,
      active,
      widget_alignment,
      text_alignment,
    );
  }

  late final _nk_check_text_alignPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>,
              ffi.Int, nk_bool, nk_flags, nk_flags)>>('nk_check_text_align');
  late final _nk_check_text_align = _nk_check_text_alignPtr.asFunction<
      int Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>, int, int,
          int, int)>();

  int nk_check_flags_label(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<ffi.Char> arg1,
    int flags,
    int value,
  ) {
    return _nk_check_flags_label(
      arg0,
      arg1,
      flags,
      value,
    );
  }

  late final _nk_check_flags_labelPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              ffi.Pointer<nk_context>,
              ffi.Pointer<ffi.Char>,
              ffi.UnsignedInt,
              ffi.UnsignedInt)>>('nk_check_flags_label');
  late final _nk_check_flags_label = _nk_check_flags_labelPtr.asFunction<
      int Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>, int, int)>();

  int nk_check_flags_text(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
    int flags,
    int value,
  ) {
    return _nk_check_flags_text(
      arg0,
      arg1,
      arg2,
      flags,
      value,
    );
  }

  late final _nk_check_flags_textPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              ffi.Pointer<nk_context>,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              ffi.UnsignedInt,
              ffi.UnsignedInt)>>('nk_check_flags_text');
  late final _nk_check_flags_text = _nk_check_flags_textPtr.asFunction<
      int Function(
          ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>, int, int, int)>();

  int nk_checkbox_label(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<ffi.Char> arg1,
    ffi.Pointer<nk_bool> active,
  ) {
    return _nk_checkbox_label(
      arg0,
      arg1,
      active,
    );
  }

  late final _nk_checkbox_labelPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<nk_bool>)>>('nk_checkbox_label');
  late final _nk_checkbox_label = _nk_checkbox_labelPtr.asFunction<
      int Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<nk_bool>)>();

  int nk_checkbox_label_align(
    ffi.Pointer<nk_context> ctx,
    ffi.Pointer<ffi.Char> label,
    ffi.Pointer<nk_bool> active,
    int widget_alignment,
    int text_alignment,
  ) {
    return _nk_checkbox_label_align(
      ctx,
      label,
      active,
      widget_alignment,
      text_alignment,
    );
  }

  late final _nk_checkbox_label_alignPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(
              ffi.Pointer<nk_context>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<nk_bool>,
              nk_flags,
              nk_flags)>>('nk_checkbox_label_align');
  late final _nk_checkbox_label_align = _nk_checkbox_label_alignPtr.asFunction<
      int Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<nk_bool>, int, int)>();

  int nk_checkbox_text(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
    ffi.Pointer<nk_bool> active,
  ) {
    return _nk_checkbox_text(
      arg0,
      arg1,
      arg2,
      active,
    );
  }

  late final _nk_checkbox_textPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>,
              ffi.Int, ffi.Pointer<nk_bool>)>>('nk_checkbox_text');
  late final _nk_checkbox_text = _nk_checkbox_textPtr.asFunction<
      int Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>, int,
          ffi.Pointer<nk_bool>)>();

  int nk_checkbox_text_align(
    ffi.Pointer<nk_context> ctx,
    ffi.Pointer<ffi.Char> text,
    int len,
    ffi.Pointer<nk_bool> active,
    int widget_alignment,
    int text_alignment,
  ) {
    return _nk_checkbox_text_align(
      ctx,
      text,
      len,
      active,
      widget_alignment,
      text_alignment,
    );
  }

  late final _nk_checkbox_text_alignPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(
              ffi.Pointer<nk_context>,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              ffi.Pointer<nk_bool>,
              nk_flags,
              nk_flags)>>('nk_checkbox_text_align');
  late final _nk_checkbox_text_align = _nk_checkbox_text_alignPtr.asFunction<
      int Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>, int,
          ffi.Pointer<nk_bool>, int, int)>();

  int nk_checkbox_flags_label(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<ffi.Char> arg1,
    ffi.Pointer<ffi.UnsignedInt> flags,
    int value,
  ) {
    return _nk_checkbox_flags_label(
      arg0,
      arg1,
      flags,
      value,
    );
  }

  late final _nk_checkbox_flags_labelPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(
              ffi.Pointer<nk_context>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.UnsignedInt>,
              ffi.UnsignedInt)>>('nk_checkbox_flags_label');
  late final _nk_checkbox_flags_label = _nk_checkbox_flags_labelPtr.asFunction<
      int Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.UnsignedInt>, int)>();

  int nk_checkbox_flags_text(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
    ffi.Pointer<ffi.UnsignedInt> flags,
    int value,
  ) {
    return _nk_checkbox_flags_text(
      arg0,
      arg1,
      arg2,
      flags,
      value,
    );
  }

  late final _nk_checkbox_flags_textPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(
              ffi.Pointer<nk_context>,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              ffi.Pointer<ffi.UnsignedInt>,
              ffi.UnsignedInt)>>('nk_checkbox_flags_text');
  late final _nk_checkbox_flags_text = _nk_checkbox_flags_textPtr.asFunction<
      int Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>, int,
          ffi.Pointer<ffi.UnsignedInt>, int)>();

  int nk_radio_label(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<ffi.Char> arg1,
    ffi.Pointer<nk_bool> active,
  ) {
    return _nk_radio_label(
      arg0,
      arg1,
      active,
    );
  }

  late final _nk_radio_labelPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<nk_bool>)>>('nk_radio_label');
  late final _nk_radio_label = _nk_radio_labelPtr.asFunction<
      int Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<nk_bool>)>();

  int nk_radio_label_align(
    ffi.Pointer<nk_context> ctx,
    ffi.Pointer<ffi.Char> label,
    ffi.Pointer<nk_bool> active,
    int widget_alignment,
    int text_alignment,
  ) {
    return _nk_radio_label_align(
      ctx,
      label,
      active,
      widget_alignment,
      text_alignment,
    );
  }

  late final _nk_radio_label_alignPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(
              ffi.Pointer<nk_context>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<nk_bool>,
              nk_flags,
              nk_flags)>>('nk_radio_label_align');
  late final _nk_radio_label_align = _nk_radio_label_alignPtr.asFunction<
      int Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<nk_bool>, int, int)>();

  int nk_radio_text(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
    ffi.Pointer<nk_bool> active,
  ) {
    return _nk_radio_text(
      arg0,
      arg1,
      arg2,
      active,
    );
  }

  late final _nk_radio_textPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>,
              ffi.Int, ffi.Pointer<nk_bool>)>>('nk_radio_text');
  late final _nk_radio_text = _nk_radio_textPtr.asFunction<
      int Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>, int,
          ffi.Pointer<nk_bool>)>();

  int nk_radio_text_align(
    ffi.Pointer<nk_context> ctx,
    ffi.Pointer<ffi.Char> text,
    int len,
    ffi.Pointer<nk_bool> active,
    int widget_alignment,
    int text_alignment,
  ) {
    return _nk_radio_text_align(
      ctx,
      text,
      len,
      active,
      widget_alignment,
      text_alignment,
    );
  }

  late final _nk_radio_text_alignPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(
              ffi.Pointer<nk_context>,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              ffi.Pointer<nk_bool>,
              nk_flags,
              nk_flags)>>('nk_radio_text_align');
  late final _nk_radio_text_align = _nk_radio_text_alignPtr.asFunction<
      int Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>, int,
          ffi.Pointer<nk_bool>, int, int)>();

  int nk_option_label(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<ffi.Char> arg1,
    int active,
  ) {
    return _nk_option_label(
      arg0,
      arg1,
      active,
    );
  }

  late final _nk_option_labelPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>,
              nk_bool)>>('nk_option_label');
  late final _nk_option_label = _nk_option_labelPtr.asFunction<
      int Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>, int)>();

  int nk_option_label_align(
    ffi.Pointer<nk_context> ctx,
    ffi.Pointer<ffi.Char> label,
    int active,
    int widget_alignment,
    int text_alignment,
  ) {
    return _nk_option_label_align(
      ctx,
      label,
      active,
      widget_alignment,
      text_alignment,
    );
  }

  late final _nk_option_label_alignPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>,
              nk_bool, nk_flags, nk_flags)>>('nk_option_label_align');
  late final _nk_option_label_align = _nk_option_label_alignPtr.asFunction<
      int Function(
          ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>, int, int, int)>();

  int nk_option_text(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
    int active,
  ) {
    return _nk_option_text(
      arg0,
      arg1,
      arg2,
      active,
    );
  }

  late final _nk_option_textPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>,
              ffi.Int, nk_bool)>>('nk_option_text');
  late final _nk_option_text = _nk_option_textPtr.asFunction<
      int Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>, int, int)>();

  int nk_option_text_align(
    ffi.Pointer<nk_context> ctx,
    ffi.Pointer<ffi.Char> text,
    int len,
    int is_active,
    int widget_alignment,
    int text_alignment,
  ) {
    return _nk_option_text_align(
      ctx,
      text,
      len,
      is_active,
      widget_alignment,
      text_alignment,
    );
  }

  late final _nk_option_text_alignPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>,
              ffi.Int, nk_bool, nk_flags, nk_flags)>>('nk_option_text_align');
  late final _nk_option_text_align = _nk_option_text_alignPtr.asFunction<
      int Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>, int, int,
          int, int)>();

  int nk_selectable_label(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<ffi.Char> arg1,
    int align,
    ffi.Pointer<nk_bool> value,
  ) {
    return _nk_selectable_label(
      arg0,
      arg1,
      align,
      value,
    );
  }

  late final _nk_selectable_labelPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>,
              nk_flags, ffi.Pointer<nk_bool>)>>('nk_selectable_label');
  late final _nk_selectable_label = _nk_selectable_labelPtr.asFunction<
      int Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>, int,
          ffi.Pointer<nk_bool>)>();

  int nk_selectable_text(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
    int align,
    ffi.Pointer<nk_bool> value,
  ) {
    return _nk_selectable_text(
      arg0,
      arg1,
      arg2,
      align,
      value,
    );
  }

  late final _nk_selectable_textPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>,
              ffi.Int, nk_flags, ffi.Pointer<nk_bool>)>>('nk_selectable_text');
  late final _nk_selectable_text = _nk_selectable_textPtr.asFunction<
      int Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>, int, int,
          ffi.Pointer<nk_bool>)>();

  int nk_selectable_image_label(
    ffi.Pointer<nk_context> arg0,
    nk_image arg1,
    ffi.Pointer<ffi.Char> arg2,
    int align,
    ffi.Pointer<nk_bool> value,
  ) {
    return _nk_selectable_image_label(
      arg0,
      arg1,
      arg2,
      align,
      value,
    );
  }

  late final _nk_selectable_image_labelPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(
              ffi.Pointer<nk_context>,
              nk_image,
              ffi.Pointer<ffi.Char>,
              nk_flags,
              ffi.Pointer<nk_bool>)>>('nk_selectable_image_label');
  late final _nk_selectable_image_label =
      _nk_selectable_image_labelPtr.asFunction<
          int Function(ffi.Pointer<nk_context>, nk_image, ffi.Pointer<ffi.Char>,
              int, ffi.Pointer<nk_bool>)>();

  int nk_selectable_image_text(
    ffi.Pointer<nk_context> arg0,
    nk_image arg1,
    ffi.Pointer<ffi.Char> arg2,
    int arg3,
    int align,
    ffi.Pointer<nk_bool> value,
  ) {
    return _nk_selectable_image_text(
      arg0,
      arg1,
      arg2,
      arg3,
      align,
      value,
    );
  }

  late final _nk_selectable_image_textPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(
              ffi.Pointer<nk_context>,
              nk_image,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              nk_flags,
              ffi.Pointer<nk_bool>)>>('nk_selectable_image_text');
  late final _nk_selectable_image_text =
      _nk_selectable_image_textPtr.asFunction<
          int Function(ffi.Pointer<nk_context>, nk_image, ffi.Pointer<ffi.Char>,
              int, int, ffi.Pointer<nk_bool>)>();

  int nk_selectable_symbol_label(
    ffi.Pointer<nk_context> arg0,
    int arg1,
    ffi.Pointer<ffi.Char> arg2,
    int align,
    ffi.Pointer<nk_bool> value,
  ) {
    return _nk_selectable_symbol_label(
      arg0,
      arg1,
      arg2,
      align,
      value,
    );
  }

  late final _nk_selectable_symbol_labelPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(
              ffi.Pointer<nk_context>,
              ffi.Int32,
              ffi.Pointer<ffi.Char>,
              nk_flags,
              ffi.Pointer<nk_bool>)>>('nk_selectable_symbol_label');
  late final _nk_selectable_symbol_label =
      _nk_selectable_symbol_labelPtr.asFunction<
          int Function(ffi.Pointer<nk_context>, int, ffi.Pointer<ffi.Char>, int,
              ffi.Pointer<nk_bool>)>();

  int nk_selectable_symbol_text(
    ffi.Pointer<nk_context> arg0,
    int arg1,
    ffi.Pointer<ffi.Char> arg2,
    int arg3,
    int align,
    ffi.Pointer<nk_bool> value,
  ) {
    return _nk_selectable_symbol_text(
      arg0,
      arg1,
      arg2,
      arg3,
      align,
      value,
    );
  }

  late final _nk_selectable_symbol_textPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(
              ffi.Pointer<nk_context>,
              ffi.Int32,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              nk_flags,
              ffi.Pointer<nk_bool>)>>('nk_selectable_symbol_text');
  late final _nk_selectable_symbol_text =
      _nk_selectable_symbol_textPtr.asFunction<
          int Function(ffi.Pointer<nk_context>, int, ffi.Pointer<ffi.Char>, int,
              int, ffi.Pointer<nk_bool>)>();

  int nk_select_label(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<ffi.Char> arg1,
    int align,
    int value,
  ) {
    return _nk_select_label(
      arg0,
      arg1,
      align,
      value,
    );
  }

  late final _nk_select_labelPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>,
              nk_flags, nk_bool)>>('nk_select_label');
  late final _nk_select_label = _nk_select_labelPtr.asFunction<
      int Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>, int, int)>();

  int nk_select_text(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
    int align,
    int value,
  ) {
    return _nk_select_text(
      arg0,
      arg1,
      arg2,
      align,
      value,
    );
  }

  late final _nk_select_textPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>,
              ffi.Int, nk_flags, nk_bool)>>('nk_select_text');
  late final _nk_select_text = _nk_select_textPtr.asFunction<
      int Function(
          ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>, int, int, int)>();

  int nk_select_image_label(
    ffi.Pointer<nk_context> arg0,
    nk_image arg1,
    ffi.Pointer<ffi.Char> arg2,
    int align,
    int value,
  ) {
    return _nk_select_image_label(
      arg0,
      arg1,
      arg2,
      align,
      value,
    );
  }

  late final _nk_select_image_labelPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(
              ffi.Pointer<nk_context>,
              nk_image,
              ffi.Pointer<ffi.Char>,
              nk_flags,
              nk_bool)>>('nk_select_image_label');
  late final _nk_select_image_label = _nk_select_image_labelPtr.asFunction<
      int Function(ffi.Pointer<nk_context>, nk_image, ffi.Pointer<ffi.Char>,
          int, int)>();

  int nk_select_image_text(
    ffi.Pointer<nk_context> arg0,
    nk_image arg1,
    ffi.Pointer<ffi.Char> arg2,
    int arg3,
    int align,
    int value,
  ) {
    return _nk_select_image_text(
      arg0,
      arg1,
      arg2,
      arg3,
      align,
      value,
    );
  }

  late final _nk_select_image_textPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(
              ffi.Pointer<nk_context>,
              nk_image,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              nk_flags,
              nk_bool)>>('nk_select_image_text');
  late final _nk_select_image_text = _nk_select_image_textPtr.asFunction<
      int Function(ffi.Pointer<nk_context>, nk_image, ffi.Pointer<ffi.Char>,
          int, int, int)>();

  int nk_select_symbol_label(
    ffi.Pointer<nk_context> arg0,
    int arg1,
    ffi.Pointer<ffi.Char> arg2,
    int align,
    int value,
  ) {
    return _nk_select_symbol_label(
      arg0,
      arg1,
      arg2,
      align,
      value,
    );
  }

  late final _nk_select_symbol_labelPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(
              ffi.Pointer<nk_context>,
              ffi.Int32,
              ffi.Pointer<ffi.Char>,
              nk_flags,
              nk_bool)>>('nk_select_symbol_label');
  late final _nk_select_symbol_label = _nk_select_symbol_labelPtr.asFunction<
      int Function(
          ffi.Pointer<nk_context>, int, ffi.Pointer<ffi.Char>, int, int)>();

  int nk_select_symbol_text(
    ffi.Pointer<nk_context> arg0,
    int arg1,
    ffi.Pointer<ffi.Char> arg2,
    int arg3,
    int align,
    int value,
  ) {
    return _nk_select_symbol_text(
      arg0,
      arg1,
      arg2,
      arg3,
      align,
      value,
    );
  }

  late final _nk_select_symbol_textPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(
              ffi.Pointer<nk_context>,
              ffi.Int32,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              nk_flags,
              nk_bool)>>('nk_select_symbol_text');
  late final _nk_select_symbol_text = _nk_select_symbol_textPtr.asFunction<
      int Function(ffi.Pointer<nk_context>, int, ffi.Pointer<ffi.Char>, int,
          int, int)>();

  double nk_slide_float(
    ffi.Pointer<nk_context> arg0,
    double min,
    double val,
    double max,
    double step,
  ) {
    return _nk_slide_float(
      arg0,
      min,
      val,
      max,
      step,
    );
  }

  late final _nk_slide_floatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Float Function(ffi.Pointer<nk_context>, ffi.Float, ffi.Float,
              ffi.Float, ffi.Float)>>('nk_slide_float');
  late final _nk_slide_float = _nk_slide_floatPtr.asFunction<
      double Function(
          ffi.Pointer<nk_context>, double, double, double, double)>();

  int nk_slide_int(
    ffi.Pointer<nk_context> arg0,
    int min,
    int val,
    int max,
    int step,
  ) {
    return _nk_slide_int(
      arg0,
      min,
      val,
      max,
      step,
    );
  }

  late final _nk_slide_intPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<nk_context>, ffi.Int, ffi.Int, ffi.Int,
              ffi.Int)>>('nk_slide_int');
  late final _nk_slide_int = _nk_slide_intPtr
      .asFunction<int Function(ffi.Pointer<nk_context>, int, int, int, int)>();

  int nk_slider_float(
    ffi.Pointer<nk_context> arg0,
    double min,
    ffi.Pointer<ffi.Float> val,
    double max,
    double step,
  ) {
    return _nk_slider_float(
      arg0,
      min,
      val,
      max,
      step,
    );
  }

  late final _nk_slider_floatPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(
              ffi.Pointer<nk_context>,
              ffi.Float,
              ffi.Pointer<ffi.Float>,
              ffi.Float,
              ffi.Float)>>('nk_slider_float');
  late final _nk_slider_float = _nk_slider_floatPtr.asFunction<
      int Function(ffi.Pointer<nk_context>, double, ffi.Pointer<ffi.Float>,
          double, double)>();

  int nk_slider_int(
    ffi.Pointer<nk_context> arg0,
    int min,
    ffi.Pointer<ffi.Int> val,
    int max,
    int step,
  ) {
    return _nk_slider_int(
      arg0,
      min,
      val,
      max,
      step,
    );
  }

  late final _nk_slider_intPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(ffi.Pointer<nk_context>, ffi.Int,
              ffi.Pointer<ffi.Int>, ffi.Int, ffi.Int)>>('nk_slider_int');
  late final _nk_slider_int = _nk_slider_intPtr.asFunction<
      int Function(
          ffi.Pointer<nk_context>, int, ffi.Pointer<ffi.Int>, int, int)>();

  int nk_knob_float(
    ffi.Pointer<nk_context> arg0,
    double min,
    ffi.Pointer<ffi.Float> val,
    double max,
    double step,
    int zero_direction,
    double dead_zone_degrees,
  ) {
    return _nk_knob_float(
      arg0,
      min,
      val,
      max,
      step,
      zero_direction,
      dead_zone_degrees,
    );
  }

  late final _nk_knob_floatPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(
              ffi.Pointer<nk_context>,
              ffi.Float,
              ffi.Pointer<ffi.Float>,
              ffi.Float,
              ffi.Float,
              ffi.Int32,
              ffi.Float)>>('nk_knob_float');
  late final _nk_knob_float = _nk_knob_floatPtr.asFunction<
      int Function(ffi.Pointer<nk_context>, double, ffi.Pointer<ffi.Float>,
          double, double, int, double)>();

  int nk_knob_int(
    ffi.Pointer<nk_context> arg0,
    int min,
    ffi.Pointer<ffi.Int> val,
    int max,
    int step,
    int zero_direction,
    double dead_zone_degrees,
  ) {
    return _nk_knob_int(
      arg0,
      min,
      val,
      max,
      step,
      zero_direction,
      dead_zone_degrees,
    );
  }

  late final _nk_knob_intPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(
              ffi.Pointer<nk_context>,
              ffi.Int,
              ffi.Pointer<ffi.Int>,
              ffi.Int,
              ffi.Int,
              ffi.Int32,
              ffi.Float)>>('nk_knob_int');
  late final _nk_knob_int = _nk_knob_intPtr.asFunction<
      int Function(ffi.Pointer<nk_context>, int, ffi.Pointer<ffi.Int>, int, int,
          int, double)>();

  int nk_progress(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<nk_size> cur,
    int max,
    int modifyable,
  ) {
    return _nk_progress(
      arg0,
      cur,
      max,
      modifyable,
    );
  }

  late final _nk_progressPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(ffi.Pointer<nk_context>, ffi.Pointer<nk_size>,
              nk_size, nk_bool)>>('nk_progress');
  late final _nk_progress = _nk_progressPtr.asFunction<
      int Function(ffi.Pointer<nk_context>, ffi.Pointer<nk_size>, int, int)>();

  int nk_prog(
    ffi.Pointer<nk_context> arg0,
    int cur,
    int max,
    int modifyable,
  ) {
    return _nk_prog(
      arg0,
      cur,
      max,
      modifyable,
    );
  }

  late final _nk_progPtr = _lookup<
      ffi.NativeFunction<
          nk_size Function(
              ffi.Pointer<nk_context>, nk_size, nk_size, nk_bool)>>('nk_prog');
  late final _nk_prog = _nk_progPtr
      .asFunction<int Function(ffi.Pointer<nk_context>, int, int, int)>();

  nk_colorf nk_color_picker(
    ffi.Pointer<nk_context> arg0,
    nk_colorf arg1,
    int arg2,
  ) {
    return _nk_color_picker(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _nk_color_pickerPtr = _lookup<
      ffi.NativeFunction<
          nk_colorf Function(ffi.Pointer<nk_context>, nk_colorf,
              ffi.Int32)>>('nk_color_picker');
  late final _nk_color_picker = _nk_color_pickerPtr.asFunction<
      nk_colorf Function(ffi.Pointer<nk_context>, nk_colorf, int)>();

  int nk_color_pick(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<nk_colorf> arg1,
    int arg2,
  ) {
    return _nk_color_pick(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _nk_color_pickPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(ffi.Pointer<nk_context>, ffi.Pointer<nk_colorf>,
              ffi.Int32)>>('nk_color_pick');
  late final _nk_color_pick = _nk_color_pickPtr.asFunction<
      int Function(ffi.Pointer<nk_context>, ffi.Pointer<nk_colorf>, int)>();

  /// \page Properties
  /// Properties are the main value modification widgets in Nuklear. Changing a value
  /// can be achieved by dragging, adding/removing incremental steps on button click
  /// or by directly typing a number.
  ///
  /// # Usage
  /// Each property requires a unique name for identification that is also used for
  /// displaying a label. If you want to use the same name multiple times make sure
  /// add a '#' before your name. The '#' will not be shown but will generate a
  /// unique ID. Each property also takes in a minimum and maximum value. If you want
  /// to make use of the complete number range of a type just use the provided
  /// type limits from `limits.h`. For example `INT_MIN` and `INT_MAX` for
  /// `nk_property_int` and `nk_propertyi`. In additional each property takes in
  /// a increment value that will be added or subtracted if either the increment
  /// decrement button is clicked. Finally there is a value for increment per pixel
  /// dragged that is added or subtracted from the value.
  ///
  /// ```c
  /// int value = 0;
  /// struct nk_context ctx;
  /// nk_init_xxx(&ctx, ...);
  /// while (1) {
  /// // Input
  /// Event evt;
  /// nk_input_begin(&ctx);
  /// while (GetEvent(&evt)) {
  /// if (evt.type == MOUSE_MOVE)
  /// nk_input_motion(&ctx, evt.motion.x, evt.motion.y);
  /// else if (evt.type == [...]) {
  /// nk_input_xxx(...);
  /// }
  /// }
  /// nk_input_end(&ctx);
  /// //
  /// // Window
  /// if (nk_begin_xxx(...) {
  /// // Property
  /// nk_layout_row_dynamic(...);
  /// nk_property_int(ctx, "ID", INT_MIN, &value, INT_MAX, 1, 1);
  /// }
  /// nk_end(ctx);
  /// //
  /// // Draw
  /// const struct nk_command *cmd = 0;
  /// nk_foreach(cmd, &ctx) {
  /// switch (cmd->type) {
  /// case NK_COMMAND_LINE:
  /// your_draw_line_function(...)
  /// break;
  /// case NK_COMMAND_RECT
  /// your_draw_rect_function(...)
  /// break;
  /// case ...:
  /// // [...]
  /// }
  /// nk_clear(&ctx);
  /// }
  /// nk_free(&ctx);
  /// ```
  ///
  /// # Reference
  /// Function            | Description
  /// --------------------|-------------------------------------------
  /// \ref nk_property_int     | Integer property directly modifying a passed in value
  /// \ref nk_property_float   | Float property directly modifying a passed in value
  /// \ref nk_property_double  | Double property directly modifying a passed in value
  /// \ref nk_propertyi        | Integer property returning the modified int value
  /// \ref nk_propertyf        | Float property returning the modified float value
  /// \ref nk_propertyd        | Double property returning the modified double value
  ///
  ///
  /// # # nk_property_int
  /// Integer property directly modifying a passed in value
  /// !!! \warning
  /// To generate a unique property ID using the same label make sure to insert
  /// a `#` at the beginning. It will not be shown but guarantees correct behavior.
  ///
  /// ```c
  /// void nk_property_int(struct nk_context *ctx, const char *name, int min, int *val, int max, int step, float inc_per_pixel);
  /// ```
  ///
  /// Parameter           | Description
  /// --------------------|-----------------------------------------------------------
  /// \param[in] ctx             | Must point to an previously initialized `nk_context` struct after calling a layouting function
  /// \param[in] name            | String used both as a label as well as a unique identifier
  /// \param[in] min             | Minimum value not allowed to be underflown
  /// \param[in] val             | Integer pointer to be modified
  /// \param[in] max             | Maximum value not allowed to be overflown
  /// \param[in] step            | Increment added and subtracted on increment and decrement button
  /// \param[in] inc_per_pixel   | Value per pixel added or subtracted on dragging
  void nk_property_int(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<ffi.Char> name,
    int min,
    ffi.Pointer<ffi.Int> val,
    int max,
    int step,
    double inc_per_pixel,
  ) {
    return _nk_property_int(
      arg0,
      name,
      min,
      val,
      max,
      step,
      inc_per_pixel,
    );
  }

  late final _nk_property_intPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<nk_context>,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              ffi.Pointer<ffi.Int>,
              ffi.Int,
              ffi.Int,
              ffi.Float)>>('nk_property_int');
  late final _nk_property_int = _nk_property_intPtr.asFunction<
      void Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>, int,
          ffi.Pointer<ffi.Int>, int, int, double)>();

  /// # # nk_property_float
  /// Float property directly modifying a passed in value
  /// !!! \warning
  /// To generate a unique property ID using the same label make sure to insert
  /// a `#` at the beginning. It will not be shown but guarantees correct behavior.
  ///
  /// ```c
  /// void nk_property_float(struct nk_context *ctx, const char *name, float min, float *val, float max, float step, float inc_per_pixel);
  /// ```
  ///
  /// Parameter           | Description
  /// --------------------|-----------------------------------------------------------
  /// \param[in] ctx             | Must point to an previously initialized `nk_context` struct after calling a layouting function
  /// \param[in] name            | String used both as a label as well as a unique identifier
  /// \param[in] min             | Minimum value not allowed to be underflown
  /// \param[in] val             | Float pointer to be modified
  /// \param[in] max             | Maximum value not allowed to be overflown
  /// \param[in] step            | Increment added and subtracted on increment and decrement button
  /// \param[in] inc_per_pixel   | Value per pixel added or subtracted on dragging
  void nk_property_float(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<ffi.Char> name,
    double min,
    ffi.Pointer<ffi.Float> val,
    double max,
    double step,
    double inc_per_pixel,
  ) {
    return _nk_property_float(
      arg0,
      name,
      min,
      val,
      max,
      step,
      inc_per_pixel,
    );
  }

  late final _nk_property_floatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<nk_context>,
              ffi.Pointer<ffi.Char>,
              ffi.Float,
              ffi.Pointer<ffi.Float>,
              ffi.Float,
              ffi.Float,
              ffi.Float)>>('nk_property_float');
  late final _nk_property_float = _nk_property_floatPtr.asFunction<
      void Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>, double,
          ffi.Pointer<ffi.Float>, double, double, double)>();

  /// # # nk_property_double
  /// Double property directly modifying a passed in value
  /// !!! \warning
  /// To generate a unique property ID using the same label make sure to insert
  /// a `#` at the beginning. It will not be shown but guarantees correct behavior.
  ///
  /// ```c
  /// void nk_property_double(struct nk_context *ctx, const char *name, double min, double *val, double max, double step, double inc_per_pixel);
  /// ```
  ///
  /// Parameter           | Description
  /// --------------------|-----------------------------------------------------------
  /// \param[in] ctx             | Must point to an previously initialized `nk_context` struct after calling a layouting function
  /// \param[in] name            | String used both as a label as well as a unique identifier
  /// \param[in] min             | Minimum value not allowed to be underflown
  /// \param[in] val             | Double pointer to be modified
  /// \param[in] max             | Maximum value not allowed to be overflown
  /// \param[in] step            | Increment added and subtracted on increment and decrement button
  /// \param[in] inc_per_pixel   | Value per pixel added or subtracted on dragging
  void nk_property_double(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<ffi.Char> name,
    double min,
    ffi.Pointer<ffi.Double> val,
    double max,
    double step,
    double inc_per_pixel,
  ) {
    return _nk_property_double(
      arg0,
      name,
      min,
      val,
      max,
      step,
      inc_per_pixel,
    );
  }

  late final _nk_property_doublePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<nk_context>,
              ffi.Pointer<ffi.Char>,
              ffi.Double,
              ffi.Pointer<ffi.Double>,
              ffi.Double,
              ffi.Double,
              ffi.Float)>>('nk_property_double');
  late final _nk_property_double = _nk_property_doublePtr.asFunction<
      void Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>, double,
          ffi.Pointer<ffi.Double>, double, double, double)>();

  /// # # nk_propertyi
  /// Integer property modifying a passed in value and returning the new value
  /// !!! \warning
  /// To generate a unique property ID using the same label make sure to insert
  /// a `#` at the beginning. It will not be shown but guarantees correct behavior.
  ///
  /// ```c
  /// int nk_propertyi(struct nk_context *ctx, const char *name, int min, int val, int max, int step, float inc_per_pixel);
  /// ```
  ///
  /// \param[in] ctx              Must point to an previously initialized `nk_context` struct after calling a layouting function
  /// \param[in] name             String used both as a label as well as a unique identifier
  /// \param[in] min              Minimum value not allowed to be underflown
  /// \param[in] val              Current integer value to be modified and returned
  /// \param[in] max              Maximum value not allowed to be overflown
  /// \param[in] step             Increment added and subtracted on increment and decrement button
  /// \param[in] inc_per_pixel    Value per pixel added or subtracted on dragging
  ///
  /// \returns the new modified integer value
  int nk_propertyi(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<ffi.Char> name,
    int min,
    int val,
    int max,
    int step,
    double inc_per_pixel,
  ) {
    return _nk_propertyi(
      arg0,
      name,
      min,
      val,
      max,
      step,
      inc_per_pixel,
    );
  }

  late final _nk_propertyiPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>,
              ffi.Int, ffi.Int, ffi.Int, ffi.Int, ffi.Float)>>('nk_propertyi');
  late final _nk_propertyi = _nk_propertyiPtr.asFunction<
      int Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>, int, int,
          int, int, double)>();

  /// # # nk_propertyf
  /// Float property modifying a passed in value and returning the new value
  /// !!! \warning
  /// To generate a unique property ID using the same label make sure to insert
  /// a `#` at the beginning. It will not be shown but guarantees correct behavior.
  ///
  /// ```c
  /// float nk_propertyf(struct nk_context *ctx, const char *name, float min, float val, float max, float step, float inc_per_pixel);
  /// ```
  ///
  /// \param[in] ctx              Must point to an previously initialized `nk_context` struct after calling a layouting function
  /// \param[in] name             String used both as a label as well as a unique identifier
  /// \param[in] min              Minimum value not allowed to be underflown
  /// \param[in] val              Current float value to be modified and returned
  /// \param[in] max              Maximum value not allowed to be overflown
  /// \param[in] step             Increment added and subtracted on increment and decrement button
  /// \param[in] inc_per_pixel    Value per pixel added or subtracted on dragging
  ///
  /// \returns the new modified float value
  double nk_propertyf(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<ffi.Char> name,
    double min,
    double val,
    double max,
    double step,
    double inc_per_pixel,
  ) {
    return _nk_propertyf(
      arg0,
      name,
      min,
      val,
      max,
      step,
      inc_per_pixel,
    );
  }

  late final _nk_propertyfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Float Function(
              ffi.Pointer<nk_context>,
              ffi.Pointer<ffi.Char>,
              ffi.Float,
              ffi.Float,
              ffi.Float,
              ffi.Float,
              ffi.Float)>>('nk_propertyf');
  late final _nk_propertyf = _nk_propertyfPtr.asFunction<
      double Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>, double,
          double, double, double, double)>();

  /// # # nk_propertyd
  /// Float property modifying a passed in value and returning the new value
  /// !!! \warning
  /// To generate a unique property ID using the same label make sure to insert
  /// a `#` at the beginning. It will not be shown but guarantees correct behavior.
  ///
  /// ```c
  /// float nk_propertyd(struct nk_context *ctx, const char *name, double min, double val, double max, double step, double inc_per_pixel);
  /// ```
  ///
  /// \param[in] ctx              Must point to an previously initialized `nk_context` struct after calling a layouting function
  /// \param[in] name             String used both as a label as well as a unique identifier
  /// \param[in] min              Minimum value not allowed to be underflown
  /// \param[in] val              Current double value to be modified and returned
  /// \param[in] max              Maximum value not allowed to be overflown
  /// \param[in] step             Increment added and subtracted on increment and decrement button
  /// \param[in] inc_per_pixel    Value per pixel added or subtracted on dragging
  ///
  /// \returns the new modified double value
  double nk_propertyd(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<ffi.Char> name,
    double min,
    double val,
    double max,
    double step,
    double inc_per_pixel,
  ) {
    return _nk_propertyd(
      arg0,
      name,
      min,
      val,
      max,
      step,
      inc_per_pixel,
    );
  }

  late final _nk_propertydPtr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(
              ffi.Pointer<nk_context>,
              ffi.Pointer<ffi.Char>,
              ffi.Double,
              ffi.Double,
              ffi.Double,
              ffi.Double,
              ffi.Float)>>('nk_propertyd');
  late final _nk_propertyd = _nk_propertydPtr.asFunction<
      double Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>, double,
          double, double, double, double)>();

  int nk_edit_string(
    ffi.Pointer<nk_context> arg0,
    int arg1,
    ffi.Pointer<ffi.Char> buffer,
    ffi.Pointer<ffi.Int> len,
    int max,
    nk_plugin_filter arg5,
  ) {
    return _nk_edit_string(
      arg0,
      arg1,
      buffer,
      len,
      max,
      arg5,
    );
  }

  late final _nk_edit_stringPtr = _lookup<
      ffi.NativeFunction<
          nk_flags Function(
              ffi.Pointer<nk_context>,
              nk_flags,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Int>,
              ffi.Int,
              nk_plugin_filter)>>('nk_edit_string');
  late final _nk_edit_string = _nk_edit_stringPtr.asFunction<
      int Function(ffi.Pointer<nk_context>, int, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Int>, int, nk_plugin_filter)>();

  int nk_edit_string_zero_terminated(
    ffi.Pointer<nk_context> arg0,
    int arg1,
    ffi.Pointer<ffi.Char> buffer,
    int max,
    nk_plugin_filter arg4,
  ) {
    return _nk_edit_string_zero_terminated(
      arg0,
      arg1,
      buffer,
      max,
      arg4,
    );
  }

  late final _nk_edit_string_zero_terminatedPtr = _lookup<
      ffi.NativeFunction<
          nk_flags Function(
              ffi.Pointer<nk_context>,
              nk_flags,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              nk_plugin_filter)>>('nk_edit_string_zero_terminated');
  late final _nk_edit_string_zero_terminated =
      _nk_edit_string_zero_terminatedPtr.asFunction<
          int Function(ffi.Pointer<nk_context>, int, ffi.Pointer<ffi.Char>, int,
              nk_plugin_filter)>();

  int nk_edit_buffer(
    ffi.Pointer<nk_context> arg0,
    int arg1,
    ffi.Pointer<nk_text_edit> arg2,
    nk_plugin_filter arg3,
  ) {
    return _nk_edit_buffer(
      arg0,
      arg1,
      arg2,
      arg3,
    );
  }

  late final _nk_edit_bufferPtr = _lookup<
      ffi.NativeFunction<
          nk_flags Function(ffi.Pointer<nk_context>, nk_flags,
              ffi.Pointer<nk_text_edit>, nk_plugin_filter)>>('nk_edit_buffer');
  late final _nk_edit_buffer = _nk_edit_bufferPtr.asFunction<
      int Function(ffi.Pointer<nk_context>, int, ffi.Pointer<nk_text_edit>,
          nk_plugin_filter)>();

  void nk_edit_focus(
    ffi.Pointer<nk_context> arg0,
    int flags,
  ) {
    return _nk_edit_focus(
      arg0,
      flags,
    );
  }

  late final _nk_edit_focusPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<nk_context>, nk_flags)>>('nk_edit_focus');
  late final _nk_edit_focus = _nk_edit_focusPtr
      .asFunction<void Function(ffi.Pointer<nk_context>, int)>();

  void nk_edit_unfocus(
    ffi.Pointer<nk_context> arg0,
  ) {
    return _nk_edit_unfocus(
      arg0,
    );
  }

  late final _nk_edit_unfocusPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<nk_context>)>>(
          'nk_edit_unfocus');
  late final _nk_edit_unfocus =
      _nk_edit_unfocusPtr.asFunction<void Function(ffi.Pointer<nk_context>)>();

  int nk_chart_begin(
    ffi.Pointer<nk_context> arg0,
    int arg1,
    int num,
    double min,
    double max,
  ) {
    return _nk_chart_begin(
      arg0,
      arg1,
      num,
      min,
      max,
    );
  }

  late final _nk_chart_beginPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(ffi.Pointer<nk_context>, ffi.Int32, ffi.Int,
              ffi.Float, ffi.Float)>>('nk_chart_begin');
  late final _nk_chart_begin = _nk_chart_beginPtr.asFunction<
      int Function(ffi.Pointer<nk_context>, int, int, double, double)>();

  int nk_chart_begin_colored(
    ffi.Pointer<nk_context> arg0,
    int arg1,
    nk_color arg2,
    nk_color active,
    int num,
    double min,
    double max,
  ) {
    return _nk_chart_begin_colored(
      arg0,
      arg1,
      arg2,
      active,
      num,
      min,
      max,
    );
  }

  late final _nk_chart_begin_coloredPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(
              ffi.Pointer<nk_context>,
              ffi.Int32,
              nk_color,
              nk_color,
              ffi.Int,
              ffi.Float,
              ffi.Float)>>('nk_chart_begin_colored');
  late final _nk_chart_begin_colored = _nk_chart_begin_coloredPtr.asFunction<
      int Function(ffi.Pointer<nk_context>, int, nk_color, nk_color, int,
          double, double)>();

  void nk_chart_add_slot(
    ffi.Pointer<nk_context> ctx,
    int arg1,
    int count,
    double min_value,
    double max_value,
  ) {
    return _nk_chart_add_slot(
      ctx,
      arg1,
      count,
      min_value,
      max_value,
    );
  }

  late final _nk_chart_add_slotPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_context>, ffi.Int32, ffi.Int,
              ffi.Float, ffi.Float)>>('nk_chart_add_slot');
  late final _nk_chart_add_slot = _nk_chart_add_slotPtr.asFunction<
      void Function(ffi.Pointer<nk_context>, int, int, double, double)>();

  void nk_chart_add_slot_colored(
    ffi.Pointer<nk_context> ctx,
    int arg1,
    nk_color arg2,
    nk_color active,
    int count,
    double min_value,
    double max_value,
  ) {
    return _nk_chart_add_slot_colored(
      ctx,
      arg1,
      arg2,
      active,
      count,
      min_value,
      max_value,
    );
  }

  late final _nk_chart_add_slot_coloredPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<nk_context>,
              ffi.Int32,
              nk_color,
              nk_color,
              ffi.Int,
              ffi.Float,
              ffi.Float)>>('nk_chart_add_slot_colored');
  late final _nk_chart_add_slot_colored =
      _nk_chart_add_slot_coloredPtr.asFunction<
          void Function(ffi.Pointer<nk_context>, int, nk_color, nk_color, int,
              double, double)>();

  int nk_chart_push(
    ffi.Pointer<nk_context> arg0,
    double arg1,
  ) {
    return _nk_chart_push(
      arg0,
      arg1,
    );
  }

  late final _nk_chart_pushPtr = _lookup<
      ffi.NativeFunction<
          nk_flags Function(
              ffi.Pointer<nk_context>, ffi.Float)>>('nk_chart_push');
  late final _nk_chart_push = _nk_chart_pushPtr
      .asFunction<int Function(ffi.Pointer<nk_context>, double)>();

  int nk_chart_push_slot(
    ffi.Pointer<nk_context> arg0,
    double arg1,
    int arg2,
  ) {
    return _nk_chart_push_slot(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _nk_chart_push_slotPtr = _lookup<
      ffi.NativeFunction<
          nk_flags Function(ffi.Pointer<nk_context>, ffi.Float,
              ffi.Int)>>('nk_chart_push_slot');
  late final _nk_chart_push_slot = _nk_chart_push_slotPtr
      .asFunction<int Function(ffi.Pointer<nk_context>, double, int)>();

  void nk_chart_end(
    ffi.Pointer<nk_context> arg0,
  ) {
    return _nk_chart_end(
      arg0,
    );
  }

  late final _nk_chart_endPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<nk_context>)>>(
          'nk_chart_end');
  late final _nk_chart_end =
      _nk_chart_endPtr.asFunction<void Function(ffi.Pointer<nk_context>)>();

  void nk_plot(
    ffi.Pointer<nk_context> arg0,
    int arg1,
    ffi.Pointer<ffi.Float> values,
    int count,
    int offset,
  ) {
    return _nk_plot(
      arg0,
      arg1,
      values,
      count,
      offset,
    );
  }

  late final _nk_plotPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_context>, ffi.Int32,
              ffi.Pointer<ffi.Float>, ffi.Int, ffi.Int)>>('nk_plot');
  late final _nk_plot = _nk_plotPtr.asFunction<
      void Function(
          ffi.Pointer<nk_context>, int, ffi.Pointer<ffi.Float>, int, int)>();

  void nk_plot_function(
    ffi.Pointer<nk_context> arg0,
    int arg1,
    ffi.Pointer<ffi.Void> userdata,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Float Function(ffi.Pointer<ffi.Void> user, ffi.Int index)>>
        value_getter,
    int count,
    int offset,
  ) {
    return _nk_plot_function(
      arg0,
      arg1,
      userdata,
      value_getter,
      count,
      offset,
    );
  }

  late final _nk_plot_functionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<nk_context>,
              ffi.Int32,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Float Function(
                          ffi.Pointer<ffi.Void> user, ffi.Int index)>>,
              ffi.Int,
              ffi.Int)>>('nk_plot_function');
  late final _nk_plot_function = _nk_plot_functionPtr.asFunction<
      void Function(
          ffi.Pointer<nk_context>,
          int,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Float Function(
                      ffi.Pointer<ffi.Void> user, ffi.Int index)>>,
          int,
          int)>();

  int nk_popup_begin(
    ffi.Pointer<nk_context> arg0,
    int arg1,
    ffi.Pointer<ffi.Char> arg2,
    int arg3,
    nk_rect bounds,
  ) {
    return _nk_popup_begin(
      arg0,
      arg1,
      arg2,
      arg3,
      bounds,
    );
  }

  late final _nk_popup_beginPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(ffi.Pointer<nk_context>, ffi.Int32,
              ffi.Pointer<ffi.Char>, nk_flags, nk_rect)>>('nk_popup_begin');
  late final _nk_popup_begin = _nk_popup_beginPtr.asFunction<
      int Function(
          ffi.Pointer<nk_context>, int, ffi.Pointer<ffi.Char>, int, nk_rect)>();

  void nk_popup_close(
    ffi.Pointer<nk_context> arg0,
  ) {
    return _nk_popup_close(
      arg0,
    );
  }

  late final _nk_popup_closePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<nk_context>)>>(
          'nk_popup_close');
  late final _nk_popup_close =
      _nk_popup_closePtr.asFunction<void Function(ffi.Pointer<nk_context>)>();

  void nk_popup_end(
    ffi.Pointer<nk_context> arg0,
  ) {
    return _nk_popup_end(
      arg0,
    );
  }

  late final _nk_popup_endPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<nk_context>)>>(
          'nk_popup_end');
  late final _nk_popup_end =
      _nk_popup_endPtr.asFunction<void Function(ffi.Pointer<nk_context>)>();

  void nk_popup_get_scroll(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<nk_uint> offset_x,
    ffi.Pointer<nk_uint> offset_y,
  ) {
    return _nk_popup_get_scroll(
      arg0,
      offset_x,
      offset_y,
    );
  }

  late final _nk_popup_get_scrollPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_context>, ffi.Pointer<nk_uint>,
              ffi.Pointer<nk_uint>)>>('nk_popup_get_scroll');
  late final _nk_popup_get_scroll = _nk_popup_get_scrollPtr.asFunction<
      void Function(ffi.Pointer<nk_context>, ffi.Pointer<nk_uint>,
          ffi.Pointer<nk_uint>)>();

  void nk_popup_set_scroll(
    ffi.Pointer<nk_context> arg0,
    int offset_x,
    int offset_y,
  ) {
    return _nk_popup_set_scroll(
      arg0,
      offset_x,
      offset_y,
    );
  }

  late final _nk_popup_set_scrollPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_context>, nk_uint,
              nk_uint)>>('nk_popup_set_scroll');
  late final _nk_popup_set_scroll = _nk_popup_set_scrollPtr
      .asFunction<void Function(ffi.Pointer<nk_context>, int, int)>();

  int nk_combo(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<ffi.Pointer<ffi.Char>> items,
    int count,
    int selected,
    int item_height,
    nk_vec2 size,
  ) {
    return _nk_combo(
      arg0,
      items,
      count,
      selected,
      item_height,
      size,
    );
  }

  late final _nk_comboPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<nk_context>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              nk_vec2)>>('nk_combo');
  late final _nk_combo = _nk_comboPtr.asFunction<
      int Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Pointer<ffi.Char>>,
          int, int, int, nk_vec2)>();

  int nk_combo_separator(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<ffi.Char> items_separated_by_separator,
    int separator,
    int selected,
    int count,
    int item_height,
    nk_vec2 size,
  ) {
    return _nk_combo_separator(
      arg0,
      items_separated_by_separator,
      separator,
      selected,
      count,
      item_height,
      size,
    );
  }

  late final _nk_combo_separatorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<nk_context>,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              nk_vec2)>>('nk_combo_separator');
  late final _nk_combo_separator = _nk_combo_separatorPtr.asFunction<
      int Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>, int, int,
          int, int, nk_vec2)>();

  int nk_combo_string(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<ffi.Char> items_separated_by_zeros,
    int selected,
    int count,
    int item_height,
    nk_vec2 size,
  ) {
    return _nk_combo_string(
      arg0,
      items_separated_by_zeros,
      selected,
      count,
      item_height,
      size,
    );
  }

  late final _nk_combo_stringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>,
              ffi.Int, ffi.Int, ffi.Int, nk_vec2)>>('nk_combo_string');
  late final _nk_combo_string = _nk_combo_stringPtr.asFunction<
      int Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>, int, int,
          int, nk_vec2)>();

  int nk_combo_callback(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int,
                    ffi.Pointer<ffi.Pointer<ffi.Char>>)>>
        item_getter,
    ffi.Pointer<ffi.Void> userdata,
    int selected,
    int count,
    int item_height,
    nk_vec2 size,
  ) {
    return _nk_combo_callback(
      arg0,
      item_getter,
      userdata,
      selected,
      count,
      item_height,
      size,
    );
  }

  late final _nk_combo_callbackPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<nk_context>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int,
                          ffi.Pointer<ffi.Pointer<ffi.Char>>)>>,
              ffi.Pointer<ffi.Void>,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              nk_vec2)>>('nk_combo_callback');
  late final _nk_combo_callback = _nk_combo_callbackPtr.asFunction<
      int Function(
          ffi.Pointer<nk_context>,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int,
                      ffi.Pointer<ffi.Pointer<ffi.Char>>)>>,
          ffi.Pointer<ffi.Void>,
          int,
          int,
          int,
          nk_vec2)>();

  void nk_combobox(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<ffi.Pointer<ffi.Char>> items,
    int count,
    ffi.Pointer<ffi.Int> selected,
    int item_height,
    nk_vec2 size,
  ) {
    return _nk_combobox(
      arg0,
      items,
      count,
      selected,
      item_height,
      size,
    );
  }

  late final _nk_comboboxPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<nk_context>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Int,
              ffi.Pointer<ffi.Int>,
              ffi.Int,
              nk_vec2)>>('nk_combobox');
  late final _nk_combobox = _nk_comboboxPtr.asFunction<
      void Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Pointer<ffi.Char>>,
          int, ffi.Pointer<ffi.Int>, int, nk_vec2)>();

  void nk_combobox_string(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<ffi.Char> items_separated_by_zeros,
    ffi.Pointer<ffi.Int> selected,
    int count,
    int item_height,
    nk_vec2 size,
  ) {
    return _nk_combobox_string(
      arg0,
      items_separated_by_zeros,
      selected,
      count,
      item_height,
      size,
    );
  }

  late final _nk_combobox_stringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<nk_context>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Int>,
              ffi.Int,
              ffi.Int,
              nk_vec2)>>('nk_combobox_string');
  late final _nk_combobox_string = _nk_combobox_stringPtr.asFunction<
      void Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Int>, int, int, nk_vec2)>();

  void nk_combobox_separator(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<ffi.Char> items_separated_by_separator,
    int separator,
    ffi.Pointer<ffi.Int> selected,
    int count,
    int item_height,
    nk_vec2 size,
  ) {
    return _nk_combobox_separator(
      arg0,
      items_separated_by_separator,
      separator,
      selected,
      count,
      item_height,
      size,
    );
  }

  late final _nk_combobox_separatorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<nk_context>,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              ffi.Pointer<ffi.Int>,
              ffi.Int,
              ffi.Int,
              nk_vec2)>>('nk_combobox_separator');
  late final _nk_combobox_separator = _nk_combobox_separatorPtr.asFunction<
      void Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>, int,
          ffi.Pointer<ffi.Int>, int, int, nk_vec2)>();

  void nk_combobox_callback(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int,
                    ffi.Pointer<ffi.Pointer<ffi.Char>>)>>
        item_getter,
    ffi.Pointer<ffi.Void> arg2,
    ffi.Pointer<ffi.Int> selected,
    int count,
    int item_height,
    nk_vec2 size,
  ) {
    return _nk_combobox_callback(
      arg0,
      item_getter,
      arg2,
      selected,
      count,
      item_height,
      size,
    );
  }

  late final _nk_combobox_callbackPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<nk_context>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int,
                          ffi.Pointer<ffi.Pointer<ffi.Char>>)>>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Int>,
              ffi.Int,
              ffi.Int,
              nk_vec2)>>('nk_combobox_callback');
  late final _nk_combobox_callback = _nk_combobox_callbackPtr.asFunction<
      void Function(
          ffi.Pointer<nk_context>,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int,
                      ffi.Pointer<ffi.Pointer<ffi.Char>>)>>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Int>,
          int,
          int,
          nk_vec2)>();

  int nk_combo_begin_text(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<ffi.Char> selected,
    int arg2,
    nk_vec2 size,
  ) {
    return _nk_combo_begin_text(
      arg0,
      selected,
      arg2,
      size,
    );
  }

  late final _nk_combo_begin_textPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>,
              ffi.Int, nk_vec2)>>('nk_combo_begin_text');
  late final _nk_combo_begin_text = _nk_combo_begin_textPtr.asFunction<
      int Function(
          ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>, int, nk_vec2)>();

  int nk_combo_begin_label(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<ffi.Char> selected,
    nk_vec2 size,
  ) {
    return _nk_combo_begin_label(
      arg0,
      selected,
      size,
    );
  }

  late final _nk_combo_begin_labelPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>,
              nk_vec2)>>('nk_combo_begin_label');
  late final _nk_combo_begin_label = _nk_combo_begin_labelPtr.asFunction<
      int Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>, nk_vec2)>();

  int nk_combo_begin_color(
    ffi.Pointer<nk_context> arg0,
    nk_color color,
    nk_vec2 size,
  ) {
    return _nk_combo_begin_color(
      arg0,
      color,
      size,
    );
  }

  late final _nk_combo_begin_colorPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(ffi.Pointer<nk_context>, nk_color,
              nk_vec2)>>('nk_combo_begin_color');
  late final _nk_combo_begin_color = _nk_combo_begin_colorPtr
      .asFunction<int Function(ffi.Pointer<nk_context>, nk_color, nk_vec2)>();

  int nk_combo_begin_symbol(
    ffi.Pointer<nk_context> arg0,
    int arg1,
    nk_vec2 size,
  ) {
    return _nk_combo_begin_symbol(
      arg0,
      arg1,
      size,
    );
  }

  late final _nk_combo_begin_symbolPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(ffi.Pointer<nk_context>, ffi.Int32,
              nk_vec2)>>('nk_combo_begin_symbol');
  late final _nk_combo_begin_symbol = _nk_combo_begin_symbolPtr
      .asFunction<int Function(ffi.Pointer<nk_context>, int, nk_vec2)>();

  int nk_combo_begin_symbol_label(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<ffi.Char> selected,
    int arg2,
    nk_vec2 size,
  ) {
    return _nk_combo_begin_symbol_label(
      arg0,
      selected,
      arg2,
      size,
    );
  }

  late final _nk_combo_begin_symbol_labelPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>,
              ffi.Int32, nk_vec2)>>('nk_combo_begin_symbol_label');
  late final _nk_combo_begin_symbol_label =
      _nk_combo_begin_symbol_labelPtr.asFunction<
          int Function(
              ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>, int, nk_vec2)>();

  int nk_combo_begin_symbol_text(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<ffi.Char> selected,
    int arg2,
    int arg3,
    nk_vec2 size,
  ) {
    return _nk_combo_begin_symbol_text(
      arg0,
      selected,
      arg2,
      arg3,
      size,
    );
  }

  late final _nk_combo_begin_symbol_textPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>,
              ffi.Int, ffi.Int32, nk_vec2)>>('nk_combo_begin_symbol_text');
  late final _nk_combo_begin_symbol_text =
      _nk_combo_begin_symbol_textPtr.asFunction<
          int Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>, int, int,
              nk_vec2)>();

  int nk_combo_begin_image(
    ffi.Pointer<nk_context> arg0,
    nk_image img,
    nk_vec2 size,
  ) {
    return _nk_combo_begin_image(
      arg0,
      img,
      size,
    );
  }

  late final _nk_combo_begin_imagePtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(ffi.Pointer<nk_context>, nk_image,
              nk_vec2)>>('nk_combo_begin_image');
  late final _nk_combo_begin_image = _nk_combo_begin_imagePtr
      .asFunction<int Function(ffi.Pointer<nk_context>, nk_image, nk_vec2)>();

  int nk_combo_begin_image_label(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<ffi.Char> selected,
    nk_image arg2,
    nk_vec2 size,
  ) {
    return _nk_combo_begin_image_label(
      arg0,
      selected,
      arg2,
      size,
    );
  }

  late final _nk_combo_begin_image_labelPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>,
              nk_image, nk_vec2)>>('nk_combo_begin_image_label');
  late final _nk_combo_begin_image_label =
      _nk_combo_begin_image_labelPtr.asFunction<
          int Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>, nk_image,
              nk_vec2)>();

  int nk_combo_begin_image_text(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<ffi.Char> selected,
    int arg2,
    nk_image arg3,
    nk_vec2 size,
  ) {
    return _nk_combo_begin_image_text(
      arg0,
      selected,
      arg2,
      arg3,
      size,
    );
  }

  late final _nk_combo_begin_image_textPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>,
              ffi.Int, nk_image, nk_vec2)>>('nk_combo_begin_image_text');
  late final _nk_combo_begin_image_text =
      _nk_combo_begin_image_textPtr.asFunction<
          int Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>, int,
              nk_image, nk_vec2)>();

  int nk_combo_item_label(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<ffi.Char> arg1,
    int alignment,
  ) {
    return _nk_combo_item_label(
      arg0,
      arg1,
      alignment,
    );
  }

  late final _nk_combo_item_labelPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>,
              nk_flags)>>('nk_combo_item_label');
  late final _nk_combo_item_label = _nk_combo_item_labelPtr.asFunction<
      int Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>, int)>();

  int nk_combo_item_text(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
    int alignment,
  ) {
    return _nk_combo_item_text(
      arg0,
      arg1,
      arg2,
      alignment,
    );
  }

  late final _nk_combo_item_textPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>,
              ffi.Int, nk_flags)>>('nk_combo_item_text');
  late final _nk_combo_item_text = _nk_combo_item_textPtr.asFunction<
      int Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>, int, int)>();

  int nk_combo_item_image_label(
    ffi.Pointer<nk_context> arg0,
    nk_image arg1,
    ffi.Pointer<ffi.Char> arg2,
    int alignment,
  ) {
    return _nk_combo_item_image_label(
      arg0,
      arg1,
      arg2,
      alignment,
    );
  }

  late final _nk_combo_item_image_labelPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(ffi.Pointer<nk_context>, nk_image,
              ffi.Pointer<ffi.Char>, nk_flags)>>('nk_combo_item_image_label');
  late final _nk_combo_item_image_label =
      _nk_combo_item_image_labelPtr.asFunction<
          int Function(
              ffi.Pointer<nk_context>, nk_image, ffi.Pointer<ffi.Char>, int)>();

  int nk_combo_item_image_text(
    ffi.Pointer<nk_context> arg0,
    nk_image arg1,
    ffi.Pointer<ffi.Char> arg2,
    int arg3,
    int alignment,
  ) {
    return _nk_combo_item_image_text(
      arg0,
      arg1,
      arg2,
      arg3,
      alignment,
    );
  }

  late final _nk_combo_item_image_textPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(
              ffi.Pointer<nk_context>,
              nk_image,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              nk_flags)>>('nk_combo_item_image_text');
  late final _nk_combo_item_image_text =
      _nk_combo_item_image_textPtr.asFunction<
          int Function(ffi.Pointer<nk_context>, nk_image, ffi.Pointer<ffi.Char>,
              int, int)>();

  int nk_combo_item_symbol_label(
    ffi.Pointer<nk_context> arg0,
    int arg1,
    ffi.Pointer<ffi.Char> arg2,
    int alignment,
  ) {
    return _nk_combo_item_symbol_label(
      arg0,
      arg1,
      arg2,
      alignment,
    );
  }

  late final _nk_combo_item_symbol_labelPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(ffi.Pointer<nk_context>, ffi.Int32,
              ffi.Pointer<ffi.Char>, nk_flags)>>('nk_combo_item_symbol_label');
  late final _nk_combo_item_symbol_label =
      _nk_combo_item_symbol_labelPtr.asFunction<
          int Function(
              ffi.Pointer<nk_context>, int, ffi.Pointer<ffi.Char>, int)>();

  int nk_combo_item_symbol_text(
    ffi.Pointer<nk_context> arg0,
    int arg1,
    ffi.Pointer<ffi.Char> arg2,
    int arg3,
    int alignment,
  ) {
    return _nk_combo_item_symbol_text(
      arg0,
      arg1,
      arg2,
      arg3,
      alignment,
    );
  }

  late final _nk_combo_item_symbol_textPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(
              ffi.Pointer<nk_context>,
              ffi.Int32,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              nk_flags)>>('nk_combo_item_symbol_text');
  late final _nk_combo_item_symbol_text =
      _nk_combo_item_symbol_textPtr.asFunction<
          int Function(
              ffi.Pointer<nk_context>, int, ffi.Pointer<ffi.Char>, int, int)>();

  void nk_combo_close(
    ffi.Pointer<nk_context> arg0,
  ) {
    return _nk_combo_close(
      arg0,
    );
  }

  late final _nk_combo_closePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<nk_context>)>>(
          'nk_combo_close');
  late final _nk_combo_close =
      _nk_combo_closePtr.asFunction<void Function(ffi.Pointer<nk_context>)>();

  void nk_combo_end(
    ffi.Pointer<nk_context> arg0,
  ) {
    return _nk_combo_end(
      arg0,
    );
  }

  late final _nk_combo_endPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<nk_context>)>>(
          'nk_combo_end');
  late final _nk_combo_end =
      _nk_combo_endPtr.asFunction<void Function(ffi.Pointer<nk_context>)>();

  int nk_contextual_begin(
    ffi.Pointer<nk_context> arg0,
    int arg1,
    nk_vec2 arg2,
    nk_rect trigger_bounds,
  ) {
    return _nk_contextual_begin(
      arg0,
      arg1,
      arg2,
      trigger_bounds,
    );
  }

  late final _nk_contextual_beginPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(ffi.Pointer<nk_context>, nk_flags, nk_vec2,
              nk_rect)>>('nk_contextual_begin');
  late final _nk_contextual_begin = _nk_contextual_beginPtr.asFunction<
      int Function(ffi.Pointer<nk_context>, int, nk_vec2, nk_rect)>();

  int nk_contextual_item_text(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
    int align,
  ) {
    return _nk_contextual_item_text(
      arg0,
      arg1,
      arg2,
      align,
    );
  }

  late final _nk_contextual_item_textPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>,
              ffi.Int, nk_flags)>>('nk_contextual_item_text');
  late final _nk_contextual_item_text = _nk_contextual_item_textPtr.asFunction<
      int Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>, int, int)>();

  int nk_contextual_item_label(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<ffi.Char> arg1,
    int align,
  ) {
    return _nk_contextual_item_label(
      arg0,
      arg1,
      align,
    );
  }

  late final _nk_contextual_item_labelPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>,
              nk_flags)>>('nk_contextual_item_label');
  late final _nk_contextual_item_label =
      _nk_contextual_item_labelPtr.asFunction<
          int Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>, int)>();

  int nk_contextual_item_image_label(
    ffi.Pointer<nk_context> arg0,
    nk_image arg1,
    ffi.Pointer<ffi.Char> arg2,
    int alignment,
  ) {
    return _nk_contextual_item_image_label(
      arg0,
      arg1,
      arg2,
      alignment,
    );
  }

  late final _nk_contextual_item_image_labelPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(
              ffi.Pointer<nk_context>,
              nk_image,
              ffi.Pointer<ffi.Char>,
              nk_flags)>>('nk_contextual_item_image_label');
  late final _nk_contextual_item_image_label =
      _nk_contextual_item_image_labelPtr.asFunction<
          int Function(
              ffi.Pointer<nk_context>, nk_image, ffi.Pointer<ffi.Char>, int)>();

  int nk_contextual_item_image_text(
    ffi.Pointer<nk_context> arg0,
    nk_image arg1,
    ffi.Pointer<ffi.Char> arg2,
    int len,
    int alignment,
  ) {
    return _nk_contextual_item_image_text(
      arg0,
      arg1,
      arg2,
      len,
      alignment,
    );
  }

  late final _nk_contextual_item_image_textPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(
              ffi.Pointer<nk_context>,
              nk_image,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              nk_flags)>>('nk_contextual_item_image_text');
  late final _nk_contextual_item_image_text =
      _nk_contextual_item_image_textPtr.asFunction<
          int Function(ffi.Pointer<nk_context>, nk_image, ffi.Pointer<ffi.Char>,
              int, int)>();

  int nk_contextual_item_symbol_label(
    ffi.Pointer<nk_context> arg0,
    int arg1,
    ffi.Pointer<ffi.Char> arg2,
    int alignment,
  ) {
    return _nk_contextual_item_symbol_label(
      arg0,
      arg1,
      arg2,
      alignment,
    );
  }

  late final _nk_contextual_item_symbol_labelPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(
              ffi.Pointer<nk_context>,
              ffi.Int32,
              ffi.Pointer<ffi.Char>,
              nk_flags)>>('nk_contextual_item_symbol_label');
  late final _nk_contextual_item_symbol_label =
      _nk_contextual_item_symbol_labelPtr.asFunction<
          int Function(
              ffi.Pointer<nk_context>, int, ffi.Pointer<ffi.Char>, int)>();

  int nk_contextual_item_symbol_text(
    ffi.Pointer<nk_context> arg0,
    int arg1,
    ffi.Pointer<ffi.Char> arg2,
    int arg3,
    int alignment,
  ) {
    return _nk_contextual_item_symbol_text(
      arg0,
      arg1,
      arg2,
      arg3,
      alignment,
    );
  }

  late final _nk_contextual_item_symbol_textPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(
              ffi.Pointer<nk_context>,
              ffi.Int32,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              nk_flags)>>('nk_contextual_item_symbol_text');
  late final _nk_contextual_item_symbol_text =
      _nk_contextual_item_symbol_textPtr.asFunction<
          int Function(
              ffi.Pointer<nk_context>, int, ffi.Pointer<ffi.Char>, int, int)>();

  void nk_contextual_close(
    ffi.Pointer<nk_context> arg0,
  ) {
    return _nk_contextual_close(
      arg0,
    );
  }

  late final _nk_contextual_closePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<nk_context>)>>(
          'nk_contextual_close');
  late final _nk_contextual_close = _nk_contextual_closePtr
      .asFunction<void Function(ffi.Pointer<nk_context>)>();

  void nk_contextual_end(
    ffi.Pointer<nk_context> arg0,
  ) {
    return _nk_contextual_end(
      arg0,
    );
  }

  late final _nk_contextual_endPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<nk_context>)>>(
          'nk_contextual_end');
  late final _nk_contextual_end = _nk_contextual_endPtr
      .asFunction<void Function(ffi.Pointer<nk_context>)>();

  void nk_tooltip(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<ffi.Char> arg1,
  ) {
    return _nk_tooltip(
      arg0,
      arg1,
    );
  }

  late final _nk_tooltipPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>)>>('nk_tooltip');
  late final _nk_tooltip = _nk_tooltipPtr.asFunction<
      void Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>)>();

  void nk_tooltipf(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<ffi.Char> arg1,
  ) {
    return _nk_tooltipf(
      arg0,
      arg1,
    );
  }

  late final _nk_tooltipfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>)>>('nk_tooltipf');
  late final _nk_tooltipf = _nk_tooltipfPtr.asFunction<
      void Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>)>();

  void nk_tooltipfv(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<ffi.Char> arg1,
    va_list arg2,
  ) {
    return _nk_tooltipfv(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _nk_tooltipfvPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>,
              va_list)>>('nk_tooltipfv');
  late final _nk_tooltipfv = _nk_tooltipfvPtr.asFunction<
      void Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>, va_list)>();

  int nk_tooltip_begin(
    ffi.Pointer<nk_context> arg0,
    double width,
  ) {
    return _nk_tooltip_begin(
      arg0,
      width,
    );
  }

  late final _nk_tooltip_beginPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(
              ffi.Pointer<nk_context>, ffi.Float)>>('nk_tooltip_begin');
  late final _nk_tooltip_begin = _nk_tooltip_beginPtr
      .asFunction<int Function(ffi.Pointer<nk_context>, double)>();

  void nk_tooltip_end(
    ffi.Pointer<nk_context> arg0,
  ) {
    return _nk_tooltip_end(
      arg0,
    );
  }

  late final _nk_tooltip_endPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<nk_context>)>>(
          'nk_tooltip_end');
  late final _nk_tooltip_end =
      _nk_tooltip_endPtr.asFunction<void Function(ffi.Pointer<nk_context>)>();

  void nk_menubar_begin(
    ffi.Pointer<nk_context> arg0,
  ) {
    return _nk_menubar_begin(
      arg0,
    );
  }

  late final _nk_menubar_beginPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<nk_context>)>>(
          'nk_menubar_begin');
  late final _nk_menubar_begin =
      _nk_menubar_beginPtr.asFunction<void Function(ffi.Pointer<nk_context>)>();

  void nk_menubar_end(
    ffi.Pointer<nk_context> arg0,
  ) {
    return _nk_menubar_end(
      arg0,
    );
  }

  late final _nk_menubar_endPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<nk_context>)>>(
          'nk_menubar_end');
  late final _nk_menubar_end =
      _nk_menubar_endPtr.asFunction<void Function(ffi.Pointer<nk_context>)>();

  int nk_menu_begin_text(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<ffi.Char> title,
    int title_len,
    int align,
    nk_vec2 size,
  ) {
    return _nk_menu_begin_text(
      arg0,
      title,
      title_len,
      align,
      size,
    );
  }

  late final _nk_menu_begin_textPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>,
              ffi.Int, nk_flags, nk_vec2)>>('nk_menu_begin_text');
  late final _nk_menu_begin_text = _nk_menu_begin_textPtr.asFunction<
      int Function(
          ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>, int, int, nk_vec2)>();

  int nk_menu_begin_label(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<ffi.Char> arg1,
    int align,
    nk_vec2 size,
  ) {
    return _nk_menu_begin_label(
      arg0,
      arg1,
      align,
      size,
    );
  }

  late final _nk_menu_begin_labelPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>,
              nk_flags, nk_vec2)>>('nk_menu_begin_label');
  late final _nk_menu_begin_label = _nk_menu_begin_labelPtr.asFunction<
      int Function(
          ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>, int, nk_vec2)>();

  int nk_menu_begin_image(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<ffi.Char> arg1,
    nk_image arg2,
    nk_vec2 size,
  ) {
    return _nk_menu_begin_image(
      arg0,
      arg1,
      arg2,
      size,
    );
  }

  late final _nk_menu_begin_imagePtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>,
              nk_image, nk_vec2)>>('nk_menu_begin_image');
  late final _nk_menu_begin_image = _nk_menu_begin_imagePtr.asFunction<
      int Function(
          ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>, nk_image, nk_vec2)>();

  int nk_menu_begin_image_text(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
    int align,
    nk_image arg4,
    nk_vec2 size,
  ) {
    return _nk_menu_begin_image_text(
      arg0,
      arg1,
      arg2,
      align,
      arg4,
      size,
    );
  }

  late final _nk_menu_begin_image_textPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(
              ffi.Pointer<nk_context>,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              nk_flags,
              nk_image,
              nk_vec2)>>('nk_menu_begin_image_text');
  late final _nk_menu_begin_image_text =
      _nk_menu_begin_image_textPtr.asFunction<
          int Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>, int, int,
              nk_image, nk_vec2)>();

  int nk_menu_begin_image_label(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<ffi.Char> arg1,
    int align,
    nk_image arg3,
    nk_vec2 size,
  ) {
    return _nk_menu_begin_image_label(
      arg0,
      arg1,
      align,
      arg3,
      size,
    );
  }

  late final _nk_menu_begin_image_labelPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>,
              nk_flags, nk_image, nk_vec2)>>('nk_menu_begin_image_label');
  late final _nk_menu_begin_image_label =
      _nk_menu_begin_image_labelPtr.asFunction<
          int Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>, int,
              nk_image, nk_vec2)>();

  int nk_menu_begin_symbol(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
    nk_vec2 size,
  ) {
    return _nk_menu_begin_symbol(
      arg0,
      arg1,
      arg2,
      size,
    );
  }

  late final _nk_menu_begin_symbolPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>,
              ffi.Int32, nk_vec2)>>('nk_menu_begin_symbol');
  late final _nk_menu_begin_symbol = _nk_menu_begin_symbolPtr.asFunction<
      int Function(
          ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>, int, nk_vec2)>();

  int nk_menu_begin_symbol_text(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
    int align,
    int arg4,
    nk_vec2 size,
  ) {
    return _nk_menu_begin_symbol_text(
      arg0,
      arg1,
      arg2,
      align,
      arg4,
      size,
    );
  }

  late final _nk_menu_begin_symbol_textPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(
              ffi.Pointer<nk_context>,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              nk_flags,
              ffi.Int32,
              nk_vec2)>>('nk_menu_begin_symbol_text');
  late final _nk_menu_begin_symbol_text =
      _nk_menu_begin_symbol_textPtr.asFunction<
          int Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>, int, int,
              int, nk_vec2)>();

  int nk_menu_begin_symbol_label(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<ffi.Char> arg1,
    int align,
    int arg3,
    nk_vec2 size,
  ) {
    return _nk_menu_begin_symbol_label(
      arg0,
      arg1,
      align,
      arg3,
      size,
    );
  }

  late final _nk_menu_begin_symbol_labelPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>,
              nk_flags, ffi.Int32, nk_vec2)>>('nk_menu_begin_symbol_label');
  late final _nk_menu_begin_symbol_label =
      _nk_menu_begin_symbol_labelPtr.asFunction<
          int Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>, int, int,
              nk_vec2)>();

  int nk_menu_item_text(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
    int align,
  ) {
    return _nk_menu_item_text(
      arg0,
      arg1,
      arg2,
      align,
    );
  }

  late final _nk_menu_item_textPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>,
              ffi.Int, nk_flags)>>('nk_menu_item_text');
  late final _nk_menu_item_text = _nk_menu_item_textPtr.asFunction<
      int Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>, int, int)>();

  int nk_menu_item_label(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<ffi.Char> arg1,
    int alignment,
  ) {
    return _nk_menu_item_label(
      arg0,
      arg1,
      alignment,
    );
  }

  late final _nk_menu_item_labelPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>,
              nk_flags)>>('nk_menu_item_label');
  late final _nk_menu_item_label = _nk_menu_item_labelPtr.asFunction<
      int Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Char>, int)>();

  int nk_menu_item_image_label(
    ffi.Pointer<nk_context> arg0,
    nk_image arg1,
    ffi.Pointer<ffi.Char> arg2,
    int alignment,
  ) {
    return _nk_menu_item_image_label(
      arg0,
      arg1,
      arg2,
      alignment,
    );
  }

  late final _nk_menu_item_image_labelPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(ffi.Pointer<nk_context>, nk_image,
              ffi.Pointer<ffi.Char>, nk_flags)>>('nk_menu_item_image_label');
  late final _nk_menu_item_image_label =
      _nk_menu_item_image_labelPtr.asFunction<
          int Function(
              ffi.Pointer<nk_context>, nk_image, ffi.Pointer<ffi.Char>, int)>();

  int nk_menu_item_image_text(
    ffi.Pointer<nk_context> arg0,
    nk_image arg1,
    ffi.Pointer<ffi.Char> arg2,
    int len,
    int alignment,
  ) {
    return _nk_menu_item_image_text(
      arg0,
      arg1,
      arg2,
      len,
      alignment,
    );
  }

  late final _nk_menu_item_image_textPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(
              ffi.Pointer<nk_context>,
              nk_image,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              nk_flags)>>('nk_menu_item_image_text');
  late final _nk_menu_item_image_text = _nk_menu_item_image_textPtr.asFunction<
      int Function(ffi.Pointer<nk_context>, nk_image, ffi.Pointer<ffi.Char>,
          int, int)>();

  int nk_menu_item_symbol_text(
    ffi.Pointer<nk_context> arg0,
    int arg1,
    ffi.Pointer<ffi.Char> arg2,
    int arg3,
    int alignment,
  ) {
    return _nk_menu_item_symbol_text(
      arg0,
      arg1,
      arg2,
      arg3,
      alignment,
    );
  }

  late final _nk_menu_item_symbol_textPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(
              ffi.Pointer<nk_context>,
              ffi.Int32,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              nk_flags)>>('nk_menu_item_symbol_text');
  late final _nk_menu_item_symbol_text =
      _nk_menu_item_symbol_textPtr.asFunction<
          int Function(
              ffi.Pointer<nk_context>, int, ffi.Pointer<ffi.Char>, int, int)>();

  int nk_menu_item_symbol_label(
    ffi.Pointer<nk_context> arg0,
    int arg1,
    ffi.Pointer<ffi.Char> arg2,
    int alignment,
  ) {
    return _nk_menu_item_symbol_label(
      arg0,
      arg1,
      arg2,
      alignment,
    );
  }

  late final _nk_menu_item_symbol_labelPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(ffi.Pointer<nk_context>, ffi.Int32,
              ffi.Pointer<ffi.Char>, nk_flags)>>('nk_menu_item_symbol_label');
  late final _nk_menu_item_symbol_label =
      _nk_menu_item_symbol_labelPtr.asFunction<
          int Function(
              ffi.Pointer<nk_context>, int, ffi.Pointer<ffi.Char>, int)>();

  void nk_menu_close(
    ffi.Pointer<nk_context> arg0,
  ) {
    return _nk_menu_close(
      arg0,
    );
  }

  late final _nk_menu_closePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<nk_context>)>>(
          'nk_menu_close');
  late final _nk_menu_close =
      _nk_menu_closePtr.asFunction<void Function(ffi.Pointer<nk_context>)>();

  void nk_menu_end(
    ffi.Pointer<nk_context> arg0,
  ) {
    return _nk_menu_end(
      arg0,
    );
  }

  late final _nk_menu_endPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<nk_context>)>>(
          'nk_menu_end');
  late final _nk_menu_end =
      _nk_menu_endPtr.asFunction<void Function(ffi.Pointer<nk_context>)>();

  void nk_style_default(
    ffi.Pointer<nk_context> arg0,
  ) {
    return _nk_style_default(
      arg0,
    );
  }

  late final _nk_style_defaultPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<nk_context>)>>(
          'nk_style_default');
  late final _nk_style_default =
      _nk_style_defaultPtr.asFunction<void Function(ffi.Pointer<nk_context>)>();

  void nk_style_from_table(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<nk_color> arg1,
  ) {
    return _nk_style_from_table(
      arg0,
      arg1,
    );
  }

  late final _nk_style_from_tablePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_context>,
              ffi.Pointer<nk_color>)>>('nk_style_from_table');
  late final _nk_style_from_table = _nk_style_from_tablePtr.asFunction<
      void Function(ffi.Pointer<nk_context>, ffi.Pointer<nk_color>)>();

  void nk_style_load_cursor(
    ffi.Pointer<nk_context> arg0,
    int arg1,
    ffi.Pointer<nk_cursor> arg2,
  ) {
    return _nk_style_load_cursor(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _nk_style_load_cursorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_context>, ffi.Int32,
              ffi.Pointer<nk_cursor>)>>('nk_style_load_cursor');
  late final _nk_style_load_cursor = _nk_style_load_cursorPtr.asFunction<
      void Function(ffi.Pointer<nk_context>, int, ffi.Pointer<nk_cursor>)>();

  void nk_style_load_all_cursors(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<nk_cursor> arg1,
  ) {
    return _nk_style_load_all_cursors(
      arg0,
      arg1,
    );
  }

  late final _nk_style_load_all_cursorsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_context>,
              ffi.Pointer<nk_cursor>)>>('nk_style_load_all_cursors');
  late final _nk_style_load_all_cursors =
      _nk_style_load_all_cursorsPtr.asFunction<
          void Function(ffi.Pointer<nk_context>, ffi.Pointer<nk_cursor>)>();

  ffi.Pointer<ffi.Char> nk_style_get_color_by_name(
    int arg0,
  ) {
    return _nk_style_get_color_by_name(
      arg0,
    );
  }

  late final _nk_style_get_color_by_namePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int32)>>(
          'nk_style_get_color_by_name');
  late final _nk_style_get_color_by_name = _nk_style_get_color_by_namePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  void nk_style_set_font(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<nk_user_font> arg1,
  ) {
    return _nk_style_set_font(
      arg0,
      arg1,
    );
  }

  late final _nk_style_set_fontPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_context>,
              ffi.Pointer<nk_user_font>)>>('nk_style_set_font');
  late final _nk_style_set_font = _nk_style_set_fontPtr.asFunction<
      void Function(ffi.Pointer<nk_context>, ffi.Pointer<nk_user_font>)>();

  int nk_style_set_cursor(
    ffi.Pointer<nk_context> arg0,
    int arg1,
  ) {
    return _nk_style_set_cursor(
      arg0,
      arg1,
    );
  }

  late final _nk_style_set_cursorPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(
              ffi.Pointer<nk_context>, ffi.Int32)>>('nk_style_set_cursor');
  late final _nk_style_set_cursor = _nk_style_set_cursorPtr
      .asFunction<int Function(ffi.Pointer<nk_context>, int)>();

  void nk_style_show_cursor(
    ffi.Pointer<nk_context> arg0,
  ) {
    return _nk_style_show_cursor(
      arg0,
    );
  }

  late final _nk_style_show_cursorPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<nk_context>)>>(
          'nk_style_show_cursor');
  late final _nk_style_show_cursor = _nk_style_show_cursorPtr
      .asFunction<void Function(ffi.Pointer<nk_context>)>();

  void nk_style_hide_cursor(
    ffi.Pointer<nk_context> arg0,
  ) {
    return _nk_style_hide_cursor(
      arg0,
    );
  }

  late final _nk_style_hide_cursorPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<nk_context>)>>(
          'nk_style_hide_cursor');
  late final _nk_style_hide_cursor = _nk_style_hide_cursorPtr
      .asFunction<void Function(ffi.Pointer<nk_context>)>();

  int nk_style_push_font(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<nk_user_font> arg1,
  ) {
    return _nk_style_push_font(
      arg0,
      arg1,
    );
  }

  late final _nk_style_push_fontPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(ffi.Pointer<nk_context>,
              ffi.Pointer<nk_user_font>)>>('nk_style_push_font');
  late final _nk_style_push_font = _nk_style_push_fontPtr.asFunction<
      int Function(ffi.Pointer<nk_context>, ffi.Pointer<nk_user_font>)>();

  int nk_style_push_float(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<ffi.Float> arg1,
    double arg2,
  ) {
    return _nk_style_push_float(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _nk_style_push_floatPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Float>,
              ffi.Float)>>('nk_style_push_float');
  late final _nk_style_push_float = _nk_style_push_floatPtr.asFunction<
      int Function(ffi.Pointer<nk_context>, ffi.Pointer<ffi.Float>, double)>();

  int nk_style_push_vec2(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<nk_vec2> arg1,
    nk_vec2 arg2,
  ) {
    return _nk_style_push_vec2(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _nk_style_push_vec2Ptr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(ffi.Pointer<nk_context>, ffi.Pointer<nk_vec2>,
              nk_vec2)>>('nk_style_push_vec2');
  late final _nk_style_push_vec2 = _nk_style_push_vec2Ptr.asFunction<
      int Function(ffi.Pointer<nk_context>, ffi.Pointer<nk_vec2>, nk_vec2)>();

  int nk_style_push_style_item(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<nk_style_item> arg1,
    nk_style_item arg2,
  ) {
    return _nk_style_push_style_item(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _nk_style_push_style_itemPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(ffi.Pointer<nk_context>, ffi.Pointer<nk_style_item>,
              nk_style_item)>>('nk_style_push_style_item');
  late final _nk_style_push_style_item =
      _nk_style_push_style_itemPtr.asFunction<
          int Function(ffi.Pointer<nk_context>, ffi.Pointer<nk_style_item>,
              nk_style_item)>();

  int nk_style_push_flags(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<nk_flags> arg1,
    int arg2,
  ) {
    return _nk_style_push_flags(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _nk_style_push_flagsPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(ffi.Pointer<nk_context>, ffi.Pointer<nk_flags>,
              nk_flags)>>('nk_style_push_flags');
  late final _nk_style_push_flags = _nk_style_push_flagsPtr.asFunction<
      int Function(ffi.Pointer<nk_context>, ffi.Pointer<nk_flags>, int)>();

  int nk_style_push_color(
    ffi.Pointer<nk_context> arg0,
    ffi.Pointer<nk_color> arg1,
    nk_color arg2,
  ) {
    return _nk_style_push_color(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _nk_style_push_colorPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(ffi.Pointer<nk_context>, ffi.Pointer<nk_color>,
              nk_color)>>('nk_style_push_color');
  late final _nk_style_push_color = _nk_style_push_colorPtr.asFunction<
      int Function(ffi.Pointer<nk_context>, ffi.Pointer<nk_color>, nk_color)>();

  int nk_style_pop_font(
    ffi.Pointer<nk_context> arg0,
  ) {
    return _nk_style_pop_font(
      arg0,
    );
  }

  late final _nk_style_pop_fontPtr =
      _lookup<ffi.NativeFunction<nk_bool Function(ffi.Pointer<nk_context>)>>(
          'nk_style_pop_font');
  late final _nk_style_pop_font =
      _nk_style_pop_fontPtr.asFunction<int Function(ffi.Pointer<nk_context>)>();

  int nk_style_pop_float(
    ffi.Pointer<nk_context> arg0,
  ) {
    return _nk_style_pop_float(
      arg0,
    );
  }

  late final _nk_style_pop_floatPtr =
      _lookup<ffi.NativeFunction<nk_bool Function(ffi.Pointer<nk_context>)>>(
          'nk_style_pop_float');
  late final _nk_style_pop_float = _nk_style_pop_floatPtr
      .asFunction<int Function(ffi.Pointer<nk_context>)>();

  int nk_style_pop_vec2(
    ffi.Pointer<nk_context> arg0,
  ) {
    return _nk_style_pop_vec2(
      arg0,
    );
  }

  late final _nk_style_pop_vec2Ptr =
      _lookup<ffi.NativeFunction<nk_bool Function(ffi.Pointer<nk_context>)>>(
          'nk_style_pop_vec2');
  late final _nk_style_pop_vec2 =
      _nk_style_pop_vec2Ptr.asFunction<int Function(ffi.Pointer<nk_context>)>();

  int nk_style_pop_style_item(
    ffi.Pointer<nk_context> arg0,
  ) {
    return _nk_style_pop_style_item(
      arg0,
    );
  }

  late final _nk_style_pop_style_itemPtr =
      _lookup<ffi.NativeFunction<nk_bool Function(ffi.Pointer<nk_context>)>>(
          'nk_style_pop_style_item');
  late final _nk_style_pop_style_item = _nk_style_pop_style_itemPtr
      .asFunction<int Function(ffi.Pointer<nk_context>)>();

  int nk_style_pop_flags(
    ffi.Pointer<nk_context> arg0,
  ) {
    return _nk_style_pop_flags(
      arg0,
    );
  }

  late final _nk_style_pop_flagsPtr =
      _lookup<ffi.NativeFunction<nk_bool Function(ffi.Pointer<nk_context>)>>(
          'nk_style_pop_flags');
  late final _nk_style_pop_flags = _nk_style_pop_flagsPtr
      .asFunction<int Function(ffi.Pointer<nk_context>)>();

  int nk_style_pop_color(
    ffi.Pointer<nk_context> arg0,
  ) {
    return _nk_style_pop_color(
      arg0,
    );
  }

  late final _nk_style_pop_colorPtr =
      _lookup<ffi.NativeFunction<nk_bool Function(ffi.Pointer<nk_context>)>>(
          'nk_style_pop_color');
  late final _nk_style_pop_color = _nk_style_pop_colorPtr
      .asFunction<int Function(ffi.Pointer<nk_context>)>();

  nk_color nk_rgb(
    int r,
    int g,
    int b,
  ) {
    return _nk_rgb(
      r,
      g,
      b,
    );
  }

  late final _nk_rgbPtr =
      _lookup<ffi.NativeFunction<nk_color Function(ffi.Int, ffi.Int, ffi.Int)>>(
          'nk_rgb');
  late final _nk_rgb =
      _nk_rgbPtr.asFunction<nk_color Function(int, int, int)>();

  nk_color nk_rgb_iv(
    ffi.Pointer<ffi.Int> rgb,
  ) {
    return _nk_rgb_iv(
      rgb,
    );
  }

  late final _nk_rgb_ivPtr =
      _lookup<ffi.NativeFunction<nk_color Function(ffi.Pointer<ffi.Int>)>>(
          'nk_rgb_iv');
  late final _nk_rgb_iv =
      _nk_rgb_ivPtr.asFunction<nk_color Function(ffi.Pointer<ffi.Int>)>();

  nk_color nk_rgb_bv(
    ffi.Pointer<nk_byte> rgb,
  ) {
    return _nk_rgb_bv(
      rgb,
    );
  }

  late final _nk_rgb_bvPtr =
      _lookup<ffi.NativeFunction<nk_color Function(ffi.Pointer<nk_byte>)>>(
          'nk_rgb_bv');
  late final _nk_rgb_bv =
      _nk_rgb_bvPtr.asFunction<nk_color Function(ffi.Pointer<nk_byte>)>();

  nk_color nk_rgb_f(
    double r,
    double g,
    double b,
  ) {
    return _nk_rgb_f(
      r,
      g,
      b,
    );
  }

  late final _nk_rgb_fPtr = _lookup<
      ffi.NativeFunction<
          nk_color Function(ffi.Float, ffi.Float, ffi.Float)>>('nk_rgb_f');
  late final _nk_rgb_f =
      _nk_rgb_fPtr.asFunction<nk_color Function(double, double, double)>();

  nk_color nk_rgb_fv(
    ffi.Pointer<ffi.Float> rgb,
  ) {
    return _nk_rgb_fv(
      rgb,
    );
  }

  late final _nk_rgb_fvPtr =
      _lookup<ffi.NativeFunction<nk_color Function(ffi.Pointer<ffi.Float>)>>(
          'nk_rgb_fv');
  late final _nk_rgb_fv =
      _nk_rgb_fvPtr.asFunction<nk_color Function(ffi.Pointer<ffi.Float>)>();

  nk_color nk_rgb_cf(
    nk_colorf c,
  ) {
    return _nk_rgb_cf(
      c,
    );
  }

  late final _nk_rgb_cfPtr =
      _lookup<ffi.NativeFunction<nk_color Function(nk_colorf)>>('nk_rgb_cf');
  late final _nk_rgb_cf =
      _nk_rgb_cfPtr.asFunction<nk_color Function(nk_colorf)>();

  nk_color nk_rgb_hex(
    ffi.Pointer<ffi.Char> rgb,
  ) {
    return _nk_rgb_hex(
      rgb,
    );
  }

  late final _nk_rgb_hexPtr =
      _lookup<ffi.NativeFunction<nk_color Function(ffi.Pointer<ffi.Char>)>>(
          'nk_rgb_hex');
  late final _nk_rgb_hex =
      _nk_rgb_hexPtr.asFunction<nk_color Function(ffi.Pointer<ffi.Char>)>();

  nk_color nk_rgb_factor(
    nk_color col,
    double factor,
  ) {
    return _nk_rgb_factor(
      col,
      factor,
    );
  }

  late final _nk_rgb_factorPtr =
      _lookup<ffi.NativeFunction<nk_color Function(nk_color, ffi.Float)>>(
          'nk_rgb_factor');
  late final _nk_rgb_factor =
      _nk_rgb_factorPtr.asFunction<nk_color Function(nk_color, double)>();

  nk_color nk_rgba(
    int r,
    int g,
    int b,
    int a,
  ) {
    return _nk_rgba(
      r,
      g,
      b,
      a,
    );
  }

  late final _nk_rgbaPtr = _lookup<
      ffi.NativeFunction<
          nk_color Function(ffi.Int, ffi.Int, ffi.Int, ffi.Int)>>('nk_rgba');
  late final _nk_rgba =
      _nk_rgbaPtr.asFunction<nk_color Function(int, int, int, int)>();

  nk_color nk_rgba_u32(
    int arg0,
  ) {
    return _nk_rgba_u32(
      arg0,
    );
  }

  late final _nk_rgba_u32Ptr =
      _lookup<ffi.NativeFunction<nk_color Function(nk_uint)>>('nk_rgba_u32');
  late final _nk_rgba_u32 =
      _nk_rgba_u32Ptr.asFunction<nk_color Function(int)>();

  nk_color nk_rgba_iv(
    ffi.Pointer<ffi.Int> rgba,
  ) {
    return _nk_rgba_iv(
      rgba,
    );
  }

  late final _nk_rgba_ivPtr =
      _lookup<ffi.NativeFunction<nk_color Function(ffi.Pointer<ffi.Int>)>>(
          'nk_rgba_iv');
  late final _nk_rgba_iv =
      _nk_rgba_ivPtr.asFunction<nk_color Function(ffi.Pointer<ffi.Int>)>();

  nk_color nk_rgba_bv(
    ffi.Pointer<nk_byte> rgba,
  ) {
    return _nk_rgba_bv(
      rgba,
    );
  }

  late final _nk_rgba_bvPtr =
      _lookup<ffi.NativeFunction<nk_color Function(ffi.Pointer<nk_byte>)>>(
          'nk_rgba_bv');
  late final _nk_rgba_bv =
      _nk_rgba_bvPtr.asFunction<nk_color Function(ffi.Pointer<nk_byte>)>();

  nk_color nk_rgba_f(
    double r,
    double g,
    double b,
    double a,
  ) {
    return _nk_rgba_f(
      r,
      g,
      b,
      a,
    );
  }

  late final _nk_rgba_fPtr = _lookup<
      ffi.NativeFunction<
          nk_color Function(
              ffi.Float, ffi.Float, ffi.Float, ffi.Float)>>('nk_rgba_f');
  late final _nk_rgba_f = _nk_rgba_fPtr
      .asFunction<nk_color Function(double, double, double, double)>();

  nk_color nk_rgba_fv(
    ffi.Pointer<ffi.Float> rgba,
  ) {
    return _nk_rgba_fv(
      rgba,
    );
  }

  late final _nk_rgba_fvPtr =
      _lookup<ffi.NativeFunction<nk_color Function(ffi.Pointer<ffi.Float>)>>(
          'nk_rgba_fv');
  late final _nk_rgba_fv =
      _nk_rgba_fvPtr.asFunction<nk_color Function(ffi.Pointer<ffi.Float>)>();

  nk_color nk_rgba_cf(
    nk_colorf c,
  ) {
    return _nk_rgba_cf(
      c,
    );
  }

  late final _nk_rgba_cfPtr =
      _lookup<ffi.NativeFunction<nk_color Function(nk_colorf)>>('nk_rgba_cf');
  late final _nk_rgba_cf =
      _nk_rgba_cfPtr.asFunction<nk_color Function(nk_colorf)>();

  nk_color nk_rgba_hex(
    ffi.Pointer<ffi.Char> rgb,
  ) {
    return _nk_rgba_hex(
      rgb,
    );
  }

  late final _nk_rgba_hexPtr =
      _lookup<ffi.NativeFunction<nk_color Function(ffi.Pointer<ffi.Char>)>>(
          'nk_rgba_hex');
  late final _nk_rgba_hex =
      _nk_rgba_hexPtr.asFunction<nk_color Function(ffi.Pointer<ffi.Char>)>();

  nk_colorf nk_hsva_colorf(
    double h,
    double s,
    double v,
    double a,
  ) {
    return _nk_hsva_colorf(
      h,
      s,
      v,
      a,
    );
  }

  late final _nk_hsva_colorfPtr = _lookup<
      ffi.NativeFunction<
          nk_colorf Function(
              ffi.Float, ffi.Float, ffi.Float, ffi.Float)>>('nk_hsva_colorf');
  late final _nk_hsva_colorf = _nk_hsva_colorfPtr
      .asFunction<nk_colorf Function(double, double, double, double)>();

  nk_colorf nk_hsva_colorfv(
    ffi.Pointer<ffi.Float> c,
  ) {
    return _nk_hsva_colorfv(
      c,
    );
  }

  late final _nk_hsva_colorfvPtr =
      _lookup<ffi.NativeFunction<nk_colorf Function(ffi.Pointer<ffi.Float>)>>(
          'nk_hsva_colorfv');
  late final _nk_hsva_colorfv = _nk_hsva_colorfvPtr
      .asFunction<nk_colorf Function(ffi.Pointer<ffi.Float>)>();

  void nk_colorf_hsva_f(
    ffi.Pointer<ffi.Float> out_h,
    ffi.Pointer<ffi.Float> out_s,
    ffi.Pointer<ffi.Float> out_v,
    ffi.Pointer<ffi.Float> out_a,
    nk_colorf in1,
  ) {
    return _nk_colorf_hsva_f(
      out_h,
      out_s,
      out_v,
      out_a,
      in1,
    );
  }

  late final _nk_colorf_hsva_fPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Float>,
              nk_colorf)>>('nk_colorf_hsva_f');
  late final _nk_colorf_hsva_f = _nk_colorf_hsva_fPtr.asFunction<
      void Function(ffi.Pointer<ffi.Float>, ffi.Pointer<ffi.Float>,
          ffi.Pointer<ffi.Float>, ffi.Pointer<ffi.Float>, nk_colorf)>();

  void nk_colorf_hsva_fv(
    ffi.Pointer<ffi.Float> hsva,
    nk_colorf in1,
  ) {
    return _nk_colorf_hsva_fv(
      hsva,
      in1,
    );
  }

  late final _nk_colorf_hsva_fvPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Float>, nk_colorf)>>('nk_colorf_hsva_fv');
  late final _nk_colorf_hsva_fv = _nk_colorf_hsva_fvPtr
      .asFunction<void Function(ffi.Pointer<ffi.Float>, nk_colorf)>();

  nk_color nk_hsv(
    int h,
    int s,
    int v,
  ) {
    return _nk_hsv(
      h,
      s,
      v,
    );
  }

  late final _nk_hsvPtr =
      _lookup<ffi.NativeFunction<nk_color Function(ffi.Int, ffi.Int, ffi.Int)>>(
          'nk_hsv');
  late final _nk_hsv =
      _nk_hsvPtr.asFunction<nk_color Function(int, int, int)>();

  nk_color nk_hsv_iv(
    ffi.Pointer<ffi.Int> hsv,
  ) {
    return _nk_hsv_iv(
      hsv,
    );
  }

  late final _nk_hsv_ivPtr =
      _lookup<ffi.NativeFunction<nk_color Function(ffi.Pointer<ffi.Int>)>>(
          'nk_hsv_iv');
  late final _nk_hsv_iv =
      _nk_hsv_ivPtr.asFunction<nk_color Function(ffi.Pointer<ffi.Int>)>();

  nk_color nk_hsv_bv(
    ffi.Pointer<nk_byte> hsv,
  ) {
    return _nk_hsv_bv(
      hsv,
    );
  }

  late final _nk_hsv_bvPtr =
      _lookup<ffi.NativeFunction<nk_color Function(ffi.Pointer<nk_byte>)>>(
          'nk_hsv_bv');
  late final _nk_hsv_bv =
      _nk_hsv_bvPtr.asFunction<nk_color Function(ffi.Pointer<nk_byte>)>();

  nk_color nk_hsv_f(
    double h,
    double s,
    double v,
  ) {
    return _nk_hsv_f(
      h,
      s,
      v,
    );
  }

  late final _nk_hsv_fPtr = _lookup<
      ffi.NativeFunction<
          nk_color Function(ffi.Float, ffi.Float, ffi.Float)>>('nk_hsv_f');
  late final _nk_hsv_f =
      _nk_hsv_fPtr.asFunction<nk_color Function(double, double, double)>();

  nk_color nk_hsv_fv(
    ffi.Pointer<ffi.Float> hsv,
  ) {
    return _nk_hsv_fv(
      hsv,
    );
  }

  late final _nk_hsv_fvPtr =
      _lookup<ffi.NativeFunction<nk_color Function(ffi.Pointer<ffi.Float>)>>(
          'nk_hsv_fv');
  late final _nk_hsv_fv =
      _nk_hsv_fvPtr.asFunction<nk_color Function(ffi.Pointer<ffi.Float>)>();

  nk_color nk_hsva(
    int h,
    int s,
    int v,
    int a,
  ) {
    return _nk_hsva(
      h,
      s,
      v,
      a,
    );
  }

  late final _nk_hsvaPtr = _lookup<
      ffi.NativeFunction<
          nk_color Function(ffi.Int, ffi.Int, ffi.Int, ffi.Int)>>('nk_hsva');
  late final _nk_hsva =
      _nk_hsvaPtr.asFunction<nk_color Function(int, int, int, int)>();

  nk_color nk_hsva_iv(
    ffi.Pointer<ffi.Int> hsva,
  ) {
    return _nk_hsva_iv(
      hsva,
    );
  }

  late final _nk_hsva_ivPtr =
      _lookup<ffi.NativeFunction<nk_color Function(ffi.Pointer<ffi.Int>)>>(
          'nk_hsva_iv');
  late final _nk_hsva_iv =
      _nk_hsva_ivPtr.asFunction<nk_color Function(ffi.Pointer<ffi.Int>)>();

  nk_color nk_hsva_bv(
    ffi.Pointer<nk_byte> hsva,
  ) {
    return _nk_hsva_bv(
      hsva,
    );
  }

  late final _nk_hsva_bvPtr =
      _lookup<ffi.NativeFunction<nk_color Function(ffi.Pointer<nk_byte>)>>(
          'nk_hsva_bv');
  late final _nk_hsva_bv =
      _nk_hsva_bvPtr.asFunction<nk_color Function(ffi.Pointer<nk_byte>)>();

  nk_color nk_hsva_f(
    double h,
    double s,
    double v,
    double a,
  ) {
    return _nk_hsva_f(
      h,
      s,
      v,
      a,
    );
  }

  late final _nk_hsva_fPtr = _lookup<
      ffi.NativeFunction<
          nk_color Function(
              ffi.Float, ffi.Float, ffi.Float, ffi.Float)>>('nk_hsva_f');
  late final _nk_hsva_f = _nk_hsva_fPtr
      .asFunction<nk_color Function(double, double, double, double)>();

  nk_color nk_hsva_fv(
    ffi.Pointer<ffi.Float> hsva,
  ) {
    return _nk_hsva_fv(
      hsva,
    );
  }

  late final _nk_hsva_fvPtr =
      _lookup<ffi.NativeFunction<nk_color Function(ffi.Pointer<ffi.Float>)>>(
          'nk_hsva_fv');
  late final _nk_hsva_fv =
      _nk_hsva_fvPtr.asFunction<nk_color Function(ffi.Pointer<ffi.Float>)>();

  void nk_color_f(
    ffi.Pointer<ffi.Float> r,
    ffi.Pointer<ffi.Float> g,
    ffi.Pointer<ffi.Float> b,
    ffi.Pointer<ffi.Float> a,
    nk_color arg4,
  ) {
    return _nk_color_f(
      r,
      g,
      b,
      a,
      arg4,
    );
  }

  late final _nk_color_fPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Float>,
              nk_color)>>('nk_color_f');
  late final _nk_color_f = _nk_color_fPtr.asFunction<
      void Function(ffi.Pointer<ffi.Float>, ffi.Pointer<ffi.Float>,
          ffi.Pointer<ffi.Float>, ffi.Pointer<ffi.Float>, nk_color)>();

  void nk_color_fv(
    ffi.Pointer<ffi.Float> rgba_out,
    nk_color arg1,
  ) {
    return _nk_color_fv(
      rgba_out,
      arg1,
    );
  }

  late final _nk_color_fvPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Float>, nk_color)>>('nk_color_fv');
  late final _nk_color_fv = _nk_color_fvPtr
      .asFunction<void Function(ffi.Pointer<ffi.Float>, nk_color)>();

  nk_colorf nk_color_cf(
    nk_color arg0,
  ) {
    return _nk_color_cf(
      arg0,
    );
  }

  late final _nk_color_cfPtr =
      _lookup<ffi.NativeFunction<nk_colorf Function(nk_color)>>('nk_color_cf');
  late final _nk_color_cf =
      _nk_color_cfPtr.asFunction<nk_colorf Function(nk_color)>();

  void nk_color_d(
    ffi.Pointer<ffi.Double> r,
    ffi.Pointer<ffi.Double> g,
    ffi.Pointer<ffi.Double> b,
    ffi.Pointer<ffi.Double> a,
    nk_color arg4,
  ) {
    return _nk_color_d(
      r,
      g,
      b,
      a,
      arg4,
    );
  }

  late final _nk_color_dPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Double>,
              ffi.Pointer<ffi.Double>,
              ffi.Pointer<ffi.Double>,
              ffi.Pointer<ffi.Double>,
              nk_color)>>('nk_color_d');
  late final _nk_color_d = _nk_color_dPtr.asFunction<
      void Function(ffi.Pointer<ffi.Double>, ffi.Pointer<ffi.Double>,
          ffi.Pointer<ffi.Double>, ffi.Pointer<ffi.Double>, nk_color)>();

  void nk_color_dv(
    ffi.Pointer<ffi.Double> rgba_out,
    nk_color arg1,
  ) {
    return _nk_color_dv(
      rgba_out,
      arg1,
    );
  }

  late final _nk_color_dvPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Double>, nk_color)>>('nk_color_dv');
  late final _nk_color_dv = _nk_color_dvPtr
      .asFunction<void Function(ffi.Pointer<ffi.Double>, nk_color)>();

  int nk_color_u32(
    nk_color arg0,
  ) {
    return _nk_color_u32(
      arg0,
    );
  }

  late final _nk_color_u32Ptr =
      _lookup<ffi.NativeFunction<nk_uint Function(nk_color)>>('nk_color_u32');
  late final _nk_color_u32 =
      _nk_color_u32Ptr.asFunction<int Function(nk_color)>();

  void nk_color_hex_rgba(
    ffi.Pointer<ffi.Char> output,
    nk_color arg1,
  ) {
    return _nk_color_hex_rgba(
      output,
      arg1,
    );
  }

  late final _nk_color_hex_rgbaPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Char>, nk_color)>>(
      'nk_color_hex_rgba');
  late final _nk_color_hex_rgba = _nk_color_hex_rgbaPtr
      .asFunction<void Function(ffi.Pointer<ffi.Char>, nk_color)>();

  void nk_color_hex_rgb(
    ffi.Pointer<ffi.Char> output,
    nk_color arg1,
  ) {
    return _nk_color_hex_rgb(
      output,
      arg1,
    );
  }

  late final _nk_color_hex_rgbPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Char>, nk_color)>>(
      'nk_color_hex_rgb');
  late final _nk_color_hex_rgb = _nk_color_hex_rgbPtr
      .asFunction<void Function(ffi.Pointer<ffi.Char>, nk_color)>();

  void nk_color_hsv_i(
    ffi.Pointer<ffi.Int> out_h,
    ffi.Pointer<ffi.Int> out_s,
    ffi.Pointer<ffi.Int> out_v,
    nk_color arg3,
  ) {
    return _nk_color_hsv_i(
      out_h,
      out_s,
      out_v,
      arg3,
    );
  }

  late final _nk_color_hsv_iPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>, nk_color)>>('nk_color_hsv_i');
  late final _nk_color_hsv_i = _nk_color_hsv_iPtr.asFunction<
      void Function(ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Int>, nk_color)>();

  void nk_color_hsv_b(
    ffi.Pointer<nk_byte> out_h,
    ffi.Pointer<nk_byte> out_s,
    ffi.Pointer<nk_byte> out_v,
    nk_color arg3,
  ) {
    return _nk_color_hsv_b(
      out_h,
      out_s,
      out_v,
      arg3,
    );
  }

  late final _nk_color_hsv_bPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_byte>, ffi.Pointer<nk_byte>,
              ffi.Pointer<nk_byte>, nk_color)>>('nk_color_hsv_b');
  late final _nk_color_hsv_b = _nk_color_hsv_bPtr.asFunction<
      void Function(ffi.Pointer<nk_byte>, ffi.Pointer<nk_byte>,
          ffi.Pointer<nk_byte>, nk_color)>();

  void nk_color_hsv_iv(
    ffi.Pointer<ffi.Int> hsv_out,
    nk_color arg1,
  ) {
    return _nk_color_hsv_iv(
      hsv_out,
      arg1,
    );
  }

  late final _nk_color_hsv_ivPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Int>, nk_color)>>(
      'nk_color_hsv_iv');
  late final _nk_color_hsv_iv = _nk_color_hsv_ivPtr
      .asFunction<void Function(ffi.Pointer<ffi.Int>, nk_color)>();

  void nk_color_hsv_bv(
    ffi.Pointer<nk_byte> hsv_out,
    nk_color arg1,
  ) {
    return _nk_color_hsv_bv(
      hsv_out,
      arg1,
    );
  }

  late final _nk_color_hsv_bvPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<nk_byte>, nk_color)>>(
      'nk_color_hsv_bv');
  late final _nk_color_hsv_bv = _nk_color_hsv_bvPtr
      .asFunction<void Function(ffi.Pointer<nk_byte>, nk_color)>();

  void nk_color_hsv_f(
    ffi.Pointer<ffi.Float> out_h,
    ffi.Pointer<ffi.Float> out_s,
    ffi.Pointer<ffi.Float> out_v,
    nk_color arg3,
  ) {
    return _nk_color_hsv_f(
      out_h,
      out_s,
      out_v,
      arg3,
    );
  }

  late final _nk_color_hsv_fPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Float>, ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Float>, nk_color)>>('nk_color_hsv_f');
  late final _nk_color_hsv_f = _nk_color_hsv_fPtr.asFunction<
      void Function(ffi.Pointer<ffi.Float>, ffi.Pointer<ffi.Float>,
          ffi.Pointer<ffi.Float>, nk_color)>();

  void nk_color_hsv_fv(
    ffi.Pointer<ffi.Float> hsv_out,
    nk_color arg1,
  ) {
    return _nk_color_hsv_fv(
      hsv_out,
      arg1,
    );
  }

  late final _nk_color_hsv_fvPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Float>, nk_color)>>(
      'nk_color_hsv_fv');
  late final _nk_color_hsv_fv = _nk_color_hsv_fvPtr
      .asFunction<void Function(ffi.Pointer<ffi.Float>, nk_color)>();

  void nk_color_hsva_i(
    ffi.Pointer<ffi.Int> h,
    ffi.Pointer<ffi.Int> s,
    ffi.Pointer<ffi.Int> v,
    ffi.Pointer<ffi.Int> a,
    nk_color arg4,
  ) {
    return _nk_color_hsva_i(
      h,
      s,
      v,
      a,
      arg4,
    );
  }

  late final _nk_color_hsva_iPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              nk_color)>>('nk_color_hsva_i');
  late final _nk_color_hsva_i = _nk_color_hsva_iPtr.asFunction<
      void Function(ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>, nk_color)>();

  void nk_color_hsva_b(
    ffi.Pointer<nk_byte> h,
    ffi.Pointer<nk_byte> s,
    ffi.Pointer<nk_byte> v,
    ffi.Pointer<nk_byte> a,
    nk_color arg4,
  ) {
    return _nk_color_hsva_b(
      h,
      s,
      v,
      a,
      arg4,
    );
  }

  late final _nk_color_hsva_bPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<nk_byte>,
              ffi.Pointer<nk_byte>,
              ffi.Pointer<nk_byte>,
              ffi.Pointer<nk_byte>,
              nk_color)>>('nk_color_hsva_b');
  late final _nk_color_hsva_b = _nk_color_hsva_bPtr.asFunction<
      void Function(ffi.Pointer<nk_byte>, ffi.Pointer<nk_byte>,
          ffi.Pointer<nk_byte>, ffi.Pointer<nk_byte>, nk_color)>();

  void nk_color_hsva_iv(
    ffi.Pointer<ffi.Int> hsva_out,
    nk_color arg1,
  ) {
    return _nk_color_hsva_iv(
      hsva_out,
      arg1,
    );
  }

  late final _nk_color_hsva_ivPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Int>, nk_color)>>(
      'nk_color_hsva_iv');
  late final _nk_color_hsva_iv = _nk_color_hsva_ivPtr
      .asFunction<void Function(ffi.Pointer<ffi.Int>, nk_color)>();

  void nk_color_hsva_bv(
    ffi.Pointer<nk_byte> hsva_out,
    nk_color arg1,
  ) {
    return _nk_color_hsva_bv(
      hsva_out,
      arg1,
    );
  }

  late final _nk_color_hsva_bvPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<nk_byte>, nk_color)>>(
      'nk_color_hsva_bv');
  late final _nk_color_hsva_bv = _nk_color_hsva_bvPtr
      .asFunction<void Function(ffi.Pointer<nk_byte>, nk_color)>();

  void nk_color_hsva_f(
    ffi.Pointer<ffi.Float> out_h,
    ffi.Pointer<ffi.Float> out_s,
    ffi.Pointer<ffi.Float> out_v,
    ffi.Pointer<ffi.Float> out_a,
    nk_color arg4,
  ) {
    return _nk_color_hsva_f(
      out_h,
      out_s,
      out_v,
      out_a,
      arg4,
    );
  }

  late final _nk_color_hsva_fPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Float>,
              nk_color)>>('nk_color_hsva_f');
  late final _nk_color_hsva_f = _nk_color_hsva_fPtr.asFunction<
      void Function(ffi.Pointer<ffi.Float>, ffi.Pointer<ffi.Float>,
          ffi.Pointer<ffi.Float>, ffi.Pointer<ffi.Float>, nk_color)>();

  void nk_color_hsva_fv(
    ffi.Pointer<ffi.Float> hsva_out,
    nk_color arg1,
  ) {
    return _nk_color_hsva_fv(
      hsva_out,
      arg1,
    );
  }

  late final _nk_color_hsva_fvPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Float>, nk_color)>>(
      'nk_color_hsva_fv');
  late final _nk_color_hsva_fv = _nk_color_hsva_fvPtr
      .asFunction<void Function(ffi.Pointer<ffi.Float>, nk_color)>();

  nk_handle nk_handle_ptr(
    ffi.Pointer<ffi.Void> arg0,
  ) {
    return _nk_handle_ptr(
      arg0,
    );
  }

  late final _nk_handle_ptrPtr =
      _lookup<ffi.NativeFunction<nk_handle Function(ffi.Pointer<ffi.Void>)>>(
          'nk_handle_ptr');
  late final _nk_handle_ptr =
      _nk_handle_ptrPtr.asFunction<nk_handle Function(ffi.Pointer<ffi.Void>)>();

  nk_handle nk_handle_id(
    int arg0,
  ) {
    return _nk_handle_id(
      arg0,
    );
  }

  late final _nk_handle_idPtr =
      _lookup<ffi.NativeFunction<nk_handle Function(ffi.Int)>>('nk_handle_id');
  late final _nk_handle_id =
      _nk_handle_idPtr.asFunction<nk_handle Function(int)>();

  nk_image nk_image_handle(
    nk_handle arg0,
  ) {
    return _nk_image_handle(
      arg0,
    );
  }

  late final _nk_image_handlePtr =
      _lookup<ffi.NativeFunction<nk_image Function(nk_handle)>>(
          'nk_image_handle');
  late final _nk_image_handle =
      _nk_image_handlePtr.asFunction<nk_image Function(nk_handle)>();

  nk_image nk_image_ptr(
    ffi.Pointer<ffi.Void> arg0,
  ) {
    return _nk_image_ptr(
      arg0,
    );
  }

  late final _nk_image_ptrPtr =
      _lookup<ffi.NativeFunction<nk_image Function(ffi.Pointer<ffi.Void>)>>(
          'nk_image_ptr');
  late final _nk_image_ptr =
      _nk_image_ptrPtr.asFunction<nk_image Function(ffi.Pointer<ffi.Void>)>();

  nk_image nk_image_id(
    int arg0,
  ) {
    return _nk_image_id(
      arg0,
    );
  }

  late final _nk_image_idPtr =
      _lookup<ffi.NativeFunction<nk_image Function(ffi.Int)>>('nk_image_id');
  late final _nk_image_id =
      _nk_image_idPtr.asFunction<nk_image Function(int)>();

  int nk_image_is_subimage(
    ffi.Pointer<nk_image> img,
  ) {
    return _nk_image_is_subimage(
      img,
    );
  }

  late final _nk_image_is_subimagePtr =
      _lookup<ffi.NativeFunction<nk_bool Function(ffi.Pointer<nk_image>)>>(
          'nk_image_is_subimage');
  late final _nk_image_is_subimage = _nk_image_is_subimagePtr
      .asFunction<int Function(ffi.Pointer<nk_image>)>();

  nk_image nk_subimage_ptr(
    ffi.Pointer<ffi.Void> arg0,
    int w,
    int h,
    nk_rect sub_region,
  ) {
    return _nk_subimage_ptr(
      arg0,
      w,
      h,
      sub_region,
    );
  }

  late final _nk_subimage_ptrPtr = _lookup<
      ffi.NativeFunction<
          nk_image Function(ffi.Pointer<ffi.Void>, nk_ushort, nk_ushort,
              nk_rect)>>('nk_subimage_ptr');
  late final _nk_subimage_ptr = _nk_subimage_ptrPtr.asFunction<
      nk_image Function(ffi.Pointer<ffi.Void>, int, int, nk_rect)>();

  nk_image nk_subimage_id(
    int arg0,
    int w,
    int h,
    nk_rect sub_region,
  ) {
    return _nk_subimage_id(
      arg0,
      w,
      h,
      sub_region,
    );
  }

  late final _nk_subimage_idPtr = _lookup<
      ffi.NativeFunction<
          nk_image Function(
              ffi.Int, nk_ushort, nk_ushort, nk_rect)>>('nk_subimage_id');
  late final _nk_subimage_id = _nk_subimage_idPtr
      .asFunction<nk_image Function(int, int, int, nk_rect)>();

  nk_image nk_subimage_handle(
    nk_handle arg0,
    int w,
    int h,
    nk_rect sub_region,
  ) {
    return _nk_subimage_handle(
      arg0,
      w,
      h,
      sub_region,
    );
  }

  late final _nk_subimage_handlePtr = _lookup<
      ffi.NativeFunction<
          nk_image Function(
              nk_handle, nk_ushort, nk_ushort, nk_rect)>>('nk_subimage_handle');
  late final _nk_subimage_handle = _nk_subimage_handlePtr
      .asFunction<nk_image Function(nk_handle, int, int, nk_rect)>();

  nk_nine_slice nk_nine_slice_handle(
    nk_handle arg0,
    int l,
    int t,
    int r,
    int b,
  ) {
    return _nk_nine_slice_handle(
      arg0,
      l,
      t,
      r,
      b,
    );
  }

  late final _nk_nine_slice_handlePtr = _lookup<
      ffi.NativeFunction<
          nk_nine_slice Function(nk_handle, nk_ushort, nk_ushort, nk_ushort,
              nk_ushort)>>('nk_nine_slice_handle');
  late final _nk_nine_slice_handle = _nk_nine_slice_handlePtr
      .asFunction<nk_nine_slice Function(nk_handle, int, int, int, int)>();

  nk_nine_slice nk_nine_slice_ptr(
    ffi.Pointer<ffi.Void> arg0,
    int l,
    int t,
    int r,
    int b,
  ) {
    return _nk_nine_slice_ptr(
      arg0,
      l,
      t,
      r,
      b,
    );
  }

  late final _nk_nine_slice_ptrPtr = _lookup<
      ffi.NativeFunction<
          nk_nine_slice Function(ffi.Pointer<ffi.Void>, nk_ushort, nk_ushort,
              nk_ushort, nk_ushort)>>('nk_nine_slice_ptr');
  late final _nk_nine_slice_ptr = _nk_nine_slice_ptrPtr.asFunction<
      nk_nine_slice Function(ffi.Pointer<ffi.Void>, int, int, int, int)>();

  nk_nine_slice nk_nine_slice_id(
    int arg0,
    int l,
    int t,
    int r,
    int b,
  ) {
    return _nk_nine_slice_id(
      arg0,
      l,
      t,
      r,
      b,
    );
  }

  late final _nk_nine_slice_idPtr = _lookup<
      ffi.NativeFunction<
          nk_nine_slice Function(ffi.Int, nk_ushort, nk_ushort, nk_ushort,
              nk_ushort)>>('nk_nine_slice_id');
  late final _nk_nine_slice_id = _nk_nine_slice_idPtr
      .asFunction<nk_nine_slice Function(int, int, int, int, int)>();

  int nk_nine_slice_is_sub9slice(
    ffi.Pointer<nk_nine_slice> img,
  ) {
    return _nk_nine_slice_is_sub9slice(
      img,
    );
  }

  late final _nk_nine_slice_is_sub9slicePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<nk_nine_slice>)>>(
          'nk_nine_slice_is_sub9slice');
  late final _nk_nine_slice_is_sub9slice = _nk_nine_slice_is_sub9slicePtr
      .asFunction<int Function(ffi.Pointer<nk_nine_slice>)>();

  nk_nine_slice nk_sub9slice_ptr(
    ffi.Pointer<ffi.Void> arg0,
    int w,
    int h,
    nk_rect sub_region,
    int l,
    int t,
    int r,
    int b,
  ) {
    return _nk_sub9slice_ptr(
      arg0,
      w,
      h,
      sub_region,
      l,
      t,
      r,
      b,
    );
  }

  late final _nk_sub9slice_ptrPtr = _lookup<
      ffi.NativeFunction<
          nk_nine_slice Function(
              ffi.Pointer<ffi.Void>,
              nk_ushort,
              nk_ushort,
              nk_rect,
              nk_ushort,
              nk_ushort,
              nk_ushort,
              nk_ushort)>>('nk_sub9slice_ptr');
  late final _nk_sub9slice_ptr = _nk_sub9slice_ptrPtr.asFunction<
      nk_nine_slice Function(
          ffi.Pointer<ffi.Void>, int, int, nk_rect, int, int, int, int)>();

  nk_nine_slice nk_sub9slice_id(
    int arg0,
    int w,
    int h,
    nk_rect sub_region,
    int l,
    int t,
    int r,
    int b,
  ) {
    return _nk_sub9slice_id(
      arg0,
      w,
      h,
      sub_region,
      l,
      t,
      r,
      b,
    );
  }

  late final _nk_sub9slice_idPtr = _lookup<
      ffi.NativeFunction<
          nk_nine_slice Function(ffi.Int, nk_ushort, nk_ushort, nk_rect,
              nk_ushort, nk_ushort, nk_ushort, nk_ushort)>>('nk_sub9slice_id');
  late final _nk_sub9slice_id = _nk_sub9slice_idPtr.asFunction<
      nk_nine_slice Function(int, int, int, nk_rect, int, int, int, int)>();

  nk_nine_slice nk_sub9slice_handle(
    nk_handle arg0,
    int w,
    int h,
    nk_rect sub_region,
    int l,
    int t,
    int r,
    int b,
  ) {
    return _nk_sub9slice_handle(
      arg0,
      w,
      h,
      sub_region,
      l,
      t,
      r,
      b,
    );
  }

  late final _nk_sub9slice_handlePtr = _lookup<
      ffi.NativeFunction<
          nk_nine_slice Function(
              nk_handle,
              nk_ushort,
              nk_ushort,
              nk_rect,
              nk_ushort,
              nk_ushort,
              nk_ushort,
              nk_ushort)>>('nk_sub9slice_handle');
  late final _nk_sub9slice_handle = _nk_sub9slice_handlePtr.asFunction<
      nk_nine_slice Function(
          nk_handle, int, int, nk_rect, int, int, int, int)>();

  int nk_murmur_hash(
    ffi.Pointer<ffi.Void> key,
    int len,
    int seed,
  ) {
    return _nk_murmur_hash(
      key,
      len,
      seed,
    );
  }

  late final _nk_murmur_hashPtr = _lookup<
      ffi.NativeFunction<
          nk_hash Function(
              ffi.Pointer<ffi.Void>, ffi.Int, nk_hash)>>('nk_murmur_hash');
  late final _nk_murmur_hash = _nk_murmur_hashPtr
      .asFunction<int Function(ffi.Pointer<ffi.Void>, int, int)>();

  void nk_triangle_from_direction(
    ffi.Pointer<nk_vec2> result,
    nk_rect r,
    double pad_x,
    double pad_y,
    int arg4,
  ) {
    return _nk_triangle_from_direction(
      result,
      r,
      pad_x,
      pad_y,
      arg4,
    );
  }

  late final _nk_triangle_from_directionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_vec2>, nk_rect, ffi.Float, ffi.Float,
              ffi.Int32)>>('nk_triangle_from_direction');
  late final _nk_triangle_from_direction =
      _nk_triangle_from_directionPtr.asFunction<
          void Function(ffi.Pointer<nk_vec2>, nk_rect, double, double, int)>();

  nk_vec2 nk_vec21(
    double x,
    double y,
  ) {
    return _nk_vec21(
      x,
      y,
    );
  }

  late final _nk_vec21Ptr =
      _lookup<ffi.NativeFunction<nk_vec2 Function(ffi.Float, ffi.Float)>>(
          'nk_vec2');
  late final _nk_vec21 =
      _nk_vec21Ptr.asFunction<nk_vec2 Function(double, double)>();

  nk_vec2 nk_vec2i1(
    int x,
    int y,
  ) {
    return _nk_vec2i1(
      x,
      y,
    );
  }

  late final _nk_vec2i1Ptr =
      _lookup<ffi.NativeFunction<nk_vec2 Function(ffi.Int, ffi.Int)>>(
          'nk_vec2i');
  late final _nk_vec2i1 =
      _nk_vec2i1Ptr.asFunction<nk_vec2 Function(int, int)>();

  nk_vec2 nk_vec2v(
    ffi.Pointer<ffi.Float> xy,
  ) {
    return _nk_vec2v(
      xy,
    );
  }

  late final _nk_vec2vPtr =
      _lookup<ffi.NativeFunction<nk_vec2 Function(ffi.Pointer<ffi.Float>)>>(
          'nk_vec2v');
  late final _nk_vec2v =
      _nk_vec2vPtr.asFunction<nk_vec2 Function(ffi.Pointer<ffi.Float>)>();

  nk_vec2 nk_vec2iv(
    ffi.Pointer<ffi.Int> xy,
  ) {
    return _nk_vec2iv(
      xy,
    );
  }

  late final _nk_vec2ivPtr =
      _lookup<ffi.NativeFunction<nk_vec2 Function(ffi.Pointer<ffi.Int>)>>(
          'nk_vec2iv');
  late final _nk_vec2iv =
      _nk_vec2ivPtr.asFunction<nk_vec2 Function(ffi.Pointer<ffi.Int>)>();

  nk_rect nk_get_null_rect() {
    return _nk_get_null_rect();
  }

  late final _nk_get_null_rectPtr =
      _lookup<ffi.NativeFunction<nk_rect Function()>>('nk_get_null_rect');
  late final _nk_get_null_rect =
      _nk_get_null_rectPtr.asFunction<nk_rect Function()>();

  nk_rect nk_rect1(
    double x,
    double y,
    double w,
    double h,
  ) {
    return _nk_rect1(
      x,
      y,
      w,
      h,
    );
  }

  late final _nk_rect1Ptr = _lookup<
      ffi.NativeFunction<
          nk_rect Function(
              ffi.Float, ffi.Float, ffi.Float, ffi.Float)>>('nk_rect');
  late final _nk_rect1 = _nk_rect1Ptr
      .asFunction<nk_rect Function(double, double, double, double)>();

  nk_rect nk_recti1(
    int x,
    int y,
    int w,
    int h,
  ) {
    return _nk_recti1(
      x,
      y,
      w,
      h,
    );
  }

  late final _nk_recti1Ptr = _lookup<
      ffi.NativeFunction<
          nk_rect Function(ffi.Int, ffi.Int, ffi.Int, ffi.Int)>>('nk_recti');
  late final _nk_recti1 =
      _nk_recti1Ptr.asFunction<nk_rect Function(int, int, int, int)>();

  nk_rect nk_recta(
    nk_vec2 pos,
    nk_vec2 size,
  ) {
    return _nk_recta(
      pos,
      size,
    );
  }

  late final _nk_rectaPtr =
      _lookup<ffi.NativeFunction<nk_rect Function(nk_vec2, nk_vec2)>>(
          'nk_recta');
  late final _nk_recta =
      _nk_rectaPtr.asFunction<nk_rect Function(nk_vec2, nk_vec2)>();

  nk_rect nk_rectv(
    ffi.Pointer<ffi.Float> xywh,
  ) {
    return _nk_rectv(
      xywh,
    );
  }

  late final _nk_rectvPtr =
      _lookup<ffi.NativeFunction<nk_rect Function(ffi.Pointer<ffi.Float>)>>(
          'nk_rectv');
  late final _nk_rectv =
      _nk_rectvPtr.asFunction<nk_rect Function(ffi.Pointer<ffi.Float>)>();

  nk_rect nk_rectiv(
    ffi.Pointer<ffi.Int> xywh,
  ) {
    return _nk_rectiv(
      xywh,
    );
  }

  late final _nk_rectivPtr =
      _lookup<ffi.NativeFunction<nk_rect Function(ffi.Pointer<ffi.Int>)>>(
          'nk_rectiv');
  late final _nk_rectiv =
      _nk_rectivPtr.asFunction<nk_rect Function(ffi.Pointer<ffi.Int>)>();

  nk_vec2 nk_rect_pos(
    nk_rect arg0,
  ) {
    return _nk_rect_pos(
      arg0,
    );
  }

  late final _nk_rect_posPtr =
      _lookup<ffi.NativeFunction<nk_vec2 Function(nk_rect)>>('nk_rect_pos');
  late final _nk_rect_pos =
      _nk_rect_posPtr.asFunction<nk_vec2 Function(nk_rect)>();

  nk_vec2 nk_rect_size(
    nk_rect arg0,
  ) {
    return _nk_rect_size(
      arg0,
    );
  }

  late final _nk_rect_sizePtr =
      _lookup<ffi.NativeFunction<nk_vec2 Function(nk_rect)>>('nk_rect_size');
  late final _nk_rect_size =
      _nk_rect_sizePtr.asFunction<nk_vec2 Function(nk_rect)>();

  int nk_strlen(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _nk_strlen(
      str,
    );
  }

  late final _nk_strlenPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'nk_strlen');
  late final _nk_strlen =
      _nk_strlenPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int nk_stricmp(
    ffi.Pointer<ffi.Char> s1,
    ffi.Pointer<ffi.Char> s2,
  ) {
    return _nk_stricmp(
      s1,
      s2,
    );
  }

  late final _nk_stricmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('nk_stricmp');
  late final _nk_stricmp = _nk_stricmpPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int nk_stricmpn(
    ffi.Pointer<ffi.Char> s1,
    ffi.Pointer<ffi.Char> s2,
    int n,
  ) {
    return _nk_stricmpn(
      s1,
      s2,
      n,
    );
  }

  late final _nk_stricmpnPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Int)>>('nk_stricmpn');
  late final _nk_stricmpn = _nk_stricmpnPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int nk_strtoi(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endptr,
  ) {
    return _nk_strtoi(
      str,
      endptr,
    );
  }

  late final _nk_strtoiPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('nk_strtoi');
  late final _nk_strtoi = _nk_strtoiPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  double nk_strtof(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endptr,
  ) {
    return _nk_strtof(
      str,
      endptr,
    );
  }

  late final _nk_strtofPtr = _lookup<
      ffi.NativeFunction<
          ffi.Float Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('nk_strtof');
  late final _nk_strtof = _nk_strtofPtr.asFunction<
      double Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  double nk_strtod(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endptr,
  ) {
    return _nk_strtod(
      str,
      endptr,
    );
  }

  late final _nk_strtodPtr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('nk_strtod');
  late final _nk_strtod = _nk_strtodPtr.asFunction<
      double Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int nk_strfilter(
    ffi.Pointer<ffi.Char> text,
    ffi.Pointer<ffi.Char> regexp,
  ) {
    return _nk_strfilter(
      text,
      regexp,
    );
  }

  late final _nk_strfilterPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('nk_strfilter');
  late final _nk_strfilter = _nk_strfilterPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int nk_strmatch_fuzzy_string(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Char> pattern,
    ffi.Pointer<ffi.Int> out_score,
  ) {
    return _nk_strmatch_fuzzy_string(
      str,
      pattern,
      out_score,
    );
  }

  late final _nk_strmatch_fuzzy_stringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Int>)>>('nk_strmatch_fuzzy_string');
  late final _nk_strmatch_fuzzy_string =
      _nk_strmatch_fuzzy_stringPtr.asFunction<
          int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Int>)>();

  int nk_strmatch_fuzzy_text(
    ffi.Pointer<ffi.Char> txt,
    int txt_len,
    ffi.Pointer<ffi.Char> pattern,
    ffi.Pointer<ffi.Int> out_score,
  ) {
    return _nk_strmatch_fuzzy_text(
      txt,
      txt_len,
      pattern,
      out_score,
    );
  }

  late final _nk_strmatch_fuzzy_textPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Int>)>>('nk_strmatch_fuzzy_text');
  late final _nk_strmatch_fuzzy_text = _nk_strmatch_fuzzy_textPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Int>)>();

  int nk_utf_decode(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<nk_rune> arg1,
    int arg2,
  ) {
    return _nk_utf_decode(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _nk_utf_decodePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<nk_rune>,
              ffi.Int)>>('nk_utf_decode');
  late final _nk_utf_decode = _nk_utf_decodePtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<nk_rune>, int)>();

  int nk_utf_encode(
    int arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
  ) {
    return _nk_utf_encode(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _nk_utf_encodePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              nk_rune, ffi.Pointer<ffi.Char>, ffi.Int)>>('nk_utf_encode');
  late final _nk_utf_encode = _nk_utf_encodePtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Char>, int)>();

  int nk_utf_len(
    ffi.Pointer<ffi.Char> arg0,
    int byte_len,
  ) {
    return _nk_utf_len(
      arg0,
      byte_len,
    );
  }

  late final _nk_utf_lenPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Int)>>(
      'nk_utf_len');
  late final _nk_utf_len =
      _nk_utf_lenPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> nk_utf_at(
    ffi.Pointer<ffi.Char> buffer,
    int length,
    int index,
    ffi.Pointer<nk_rune> unicode,
    ffi.Pointer<ffi.Int> len,
  ) {
    return _nk_utf_at(
      buffer,
      length,
      index,
      unicode,
      len,
    );
  }

  late final _nk_utf_atPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              ffi.Int,
              ffi.Pointer<nk_rune>,
              ffi.Pointer<ffi.Int>)>>('nk_utf_at');
  late final _nk_utf_at = _nk_utf_atPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int, int,
          ffi.Pointer<nk_rune>, ffi.Pointer<ffi.Int>)>();

  /// some language glyph codepoint ranges
  ffi.Pointer<nk_rune> nk_font_default_glyph_ranges() {
    return _nk_font_default_glyph_ranges();
  }

  late final _nk_font_default_glyph_rangesPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<nk_rune> Function()>>(
          'nk_font_default_glyph_ranges');
  late final _nk_font_default_glyph_ranges = _nk_font_default_glyph_rangesPtr
      .asFunction<ffi.Pointer<nk_rune> Function()>();

  ffi.Pointer<nk_rune> nk_font_chinese_glyph_ranges() {
    return _nk_font_chinese_glyph_ranges();
  }

  late final _nk_font_chinese_glyph_rangesPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<nk_rune> Function()>>(
          'nk_font_chinese_glyph_ranges');
  late final _nk_font_chinese_glyph_ranges = _nk_font_chinese_glyph_rangesPtr
      .asFunction<ffi.Pointer<nk_rune> Function()>();

  ffi.Pointer<nk_rune> nk_font_cyrillic_glyph_ranges() {
    return _nk_font_cyrillic_glyph_ranges();
  }

  late final _nk_font_cyrillic_glyph_rangesPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<nk_rune> Function()>>(
          'nk_font_cyrillic_glyph_ranges');
  late final _nk_font_cyrillic_glyph_ranges = _nk_font_cyrillic_glyph_rangesPtr
      .asFunction<ffi.Pointer<nk_rune> Function()>();

  ffi.Pointer<nk_rune> nk_font_korean_glyph_ranges() {
    return _nk_font_korean_glyph_ranges();
  }

  late final _nk_font_korean_glyph_rangesPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<nk_rune> Function()>>(
          'nk_font_korean_glyph_ranges');
  late final _nk_font_korean_glyph_ranges = _nk_font_korean_glyph_rangesPtr
      .asFunction<ffi.Pointer<nk_rune> Function()>();

  void nk_font_atlas_init_default(
    ffi.Pointer<nk_font_atlas> arg0,
  ) {
    return _nk_font_atlas_init_default(
      arg0,
    );
  }

  late final _nk_font_atlas_init_defaultPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<nk_font_atlas>)>>(
      'nk_font_atlas_init_default');
  late final _nk_font_atlas_init_default = _nk_font_atlas_init_defaultPtr
      .asFunction<void Function(ffi.Pointer<nk_font_atlas>)>();

  void nk_font_atlas_init(
    ffi.Pointer<nk_font_atlas> arg0,
    ffi.Pointer<nk_allocator> arg1,
  ) {
    return _nk_font_atlas_init(
      arg0,
      arg1,
    );
  }

  late final _nk_font_atlas_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_font_atlas>,
              ffi.Pointer<nk_allocator>)>>('nk_font_atlas_init');
  late final _nk_font_atlas_init = _nk_font_atlas_initPtr.asFunction<
      void Function(ffi.Pointer<nk_font_atlas>, ffi.Pointer<nk_allocator>)>();

  void nk_font_atlas_init_custom(
    ffi.Pointer<nk_font_atlas> arg0,
    ffi.Pointer<nk_allocator> persistent,
    ffi.Pointer<nk_allocator> transient,
  ) {
    return _nk_font_atlas_init_custom(
      arg0,
      persistent,
      transient,
    );
  }

  late final _nk_font_atlas_init_customPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<nk_font_atlas>,
              ffi.Pointer<nk_allocator>,
              ffi.Pointer<nk_allocator>)>>('nk_font_atlas_init_custom');
  late final _nk_font_atlas_init_custom =
      _nk_font_atlas_init_customPtr.asFunction<
          void Function(ffi.Pointer<nk_font_atlas>, ffi.Pointer<nk_allocator>,
              ffi.Pointer<nk_allocator>)>();

  void nk_font_atlas_begin(
    ffi.Pointer<nk_font_atlas> arg0,
  ) {
    return _nk_font_atlas_begin(
      arg0,
    );
  }

  late final _nk_font_atlas_beginPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<nk_font_atlas>)>>(
      'nk_font_atlas_begin');
  late final _nk_font_atlas_begin = _nk_font_atlas_beginPtr
      .asFunction<void Function(ffi.Pointer<nk_font_atlas>)>();

  nk_font_config nk_font_config1(
    double pixel_height,
  ) {
    return _nk_font_config1(
      pixel_height,
    );
  }

  late final _nk_font_config1Ptr =
      _lookup<ffi.NativeFunction<nk_font_config Function(ffi.Float)>>(
          'nk_font_config');
  late final _nk_font_config1 =
      _nk_font_config1Ptr.asFunction<nk_font_config Function(double)>();

  ffi.Pointer<nk_font> nk_font_atlas_add(
    ffi.Pointer<nk_font_atlas> arg0,
    ffi.Pointer<nk_font_config> arg1,
  ) {
    return _nk_font_atlas_add(
      arg0,
      arg1,
    );
  }

  late final _nk_font_atlas_addPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<nk_font> Function(ffi.Pointer<nk_font_atlas>,
              ffi.Pointer<nk_font_config>)>>('nk_font_atlas_add');
  late final _nk_font_atlas_add = _nk_font_atlas_addPtr.asFunction<
      ffi.Pointer<nk_font> Function(
          ffi.Pointer<nk_font_atlas>, ffi.Pointer<nk_font_config>)>();

  ffi.Pointer<nk_font> nk_font_atlas_add_default(
    ffi.Pointer<nk_font_atlas> arg0,
    double height,
    ffi.Pointer<nk_font_config> arg2,
  ) {
    return _nk_font_atlas_add_default(
      arg0,
      height,
      arg2,
    );
  }

  late final _nk_font_atlas_add_defaultPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<nk_font> Function(ffi.Pointer<nk_font_atlas>, ffi.Float,
              ffi.Pointer<nk_font_config>)>>('nk_font_atlas_add_default');
  late final _nk_font_atlas_add_default =
      _nk_font_atlas_add_defaultPtr.asFunction<
          ffi.Pointer<nk_font> Function(ffi.Pointer<nk_font_atlas>, double,
              ffi.Pointer<nk_font_config>)>();

  ffi.Pointer<nk_font> nk_font_atlas_add_from_memory(
    ffi.Pointer<nk_font_atlas> atlas,
    ffi.Pointer<ffi.Void> memory,
    int size,
    double height,
    ffi.Pointer<nk_font_config> config,
  ) {
    return _nk_font_atlas_add_from_memory(
      atlas,
      memory,
      size,
      height,
      config,
    );
  }

  late final _nk_font_atlas_add_from_memoryPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<nk_font> Function(
              ffi.Pointer<nk_font_atlas>,
              ffi.Pointer<ffi.Void>,
              nk_size,
              ffi.Float,
              ffi.Pointer<nk_font_config>)>>('nk_font_atlas_add_from_memory');
  late final _nk_font_atlas_add_from_memory =
      _nk_font_atlas_add_from_memoryPtr.asFunction<
          ffi.Pointer<nk_font> Function(
              ffi.Pointer<nk_font_atlas>,
              ffi.Pointer<ffi.Void>,
              int,
              double,
              ffi.Pointer<nk_font_config>)>();

  ffi.Pointer<nk_font> nk_font_atlas_add_from_file(
    ffi.Pointer<nk_font_atlas> atlas,
    ffi.Pointer<ffi.Char> file_path,
    double height,
    ffi.Pointer<nk_font_config> arg3,
  ) {
    return _nk_font_atlas_add_from_file(
      atlas,
      file_path,
      height,
      arg3,
    );
  }

  late final _nk_font_atlas_add_from_filePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<nk_font> Function(
              ffi.Pointer<nk_font_atlas>,
              ffi.Pointer<ffi.Char>,
              ffi.Float,
              ffi.Pointer<nk_font_config>)>>('nk_font_atlas_add_from_file');
  late final _nk_font_atlas_add_from_file =
      _nk_font_atlas_add_from_filePtr.asFunction<
          ffi.Pointer<nk_font> Function(ffi.Pointer<nk_font_atlas>,
              ffi.Pointer<ffi.Char>, double, ffi.Pointer<nk_font_config>)>();

  ffi.Pointer<nk_font> nk_font_atlas_add_compressed(
    ffi.Pointer<nk_font_atlas> arg0,
    ffi.Pointer<ffi.Void> memory,
    int size,
    double height,
    ffi.Pointer<nk_font_config> arg4,
  ) {
    return _nk_font_atlas_add_compressed(
      arg0,
      memory,
      size,
      height,
      arg4,
    );
  }

  late final _nk_font_atlas_add_compressedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<nk_font> Function(
              ffi.Pointer<nk_font_atlas>,
              ffi.Pointer<ffi.Void>,
              nk_size,
              ffi.Float,
              ffi.Pointer<nk_font_config>)>>('nk_font_atlas_add_compressed');
  late final _nk_font_atlas_add_compressed =
      _nk_font_atlas_add_compressedPtr.asFunction<
          ffi.Pointer<nk_font> Function(
              ffi.Pointer<nk_font_atlas>,
              ffi.Pointer<ffi.Void>,
              int,
              double,
              ffi.Pointer<nk_font_config>)>();

  ffi.Pointer<nk_font> nk_font_atlas_add_compressed_base85(
    ffi.Pointer<nk_font_atlas> arg0,
    ffi.Pointer<ffi.Char> data,
    double height,
    ffi.Pointer<nk_font_config> config,
  ) {
    return _nk_font_atlas_add_compressed_base85(
      arg0,
      data,
      height,
      config,
    );
  }

  late final _nk_font_atlas_add_compressed_base85Ptr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<nk_font> Function(
                  ffi.Pointer<nk_font_atlas>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Float,
                  ffi.Pointer<nk_font_config>)>>(
      'nk_font_atlas_add_compressed_base85');
  late final _nk_font_atlas_add_compressed_base85 =
      _nk_font_atlas_add_compressed_base85Ptr.asFunction<
          ffi.Pointer<nk_font> Function(ffi.Pointer<nk_font_atlas>,
              ffi.Pointer<ffi.Char>, double, ffi.Pointer<nk_font_config>)>();

  ffi.Pointer<ffi.Void> nk_font_atlas_bake(
    ffi.Pointer<nk_font_atlas> arg0,
    ffi.Pointer<ffi.Int> width,
    ffi.Pointer<ffi.Int> height,
    int arg3,
  ) {
    return _nk_font_atlas_bake(
      arg0,
      width,
      height,
      arg3,
    );
  }

  late final _nk_font_atlas_bakePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<nk_font_atlas>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              ffi.Int32)>>('nk_font_atlas_bake');
  late final _nk_font_atlas_bake = _nk_font_atlas_bakePtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<nk_font_atlas>,
          ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>, int)>();

  void nk_font_atlas_end(
    ffi.Pointer<nk_font_atlas> arg0,
    nk_handle tex,
    ffi.Pointer<nk_draw_null_texture> arg2,
  ) {
    return _nk_font_atlas_end(
      arg0,
      tex,
      arg2,
    );
  }

  late final _nk_font_atlas_endPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_font_atlas>, nk_handle,
              ffi.Pointer<nk_draw_null_texture>)>>('nk_font_atlas_end');
  late final _nk_font_atlas_end = _nk_font_atlas_endPtr.asFunction<
      void Function(ffi.Pointer<nk_font_atlas>, nk_handle,
          ffi.Pointer<nk_draw_null_texture>)>();

  ffi.Pointer<nk_font_glyph> nk_font_find_glyph(
    ffi.Pointer<nk_font> arg0,
    int unicode,
  ) {
    return _nk_font_find_glyph(
      arg0,
      unicode,
    );
  }

  late final _nk_font_find_glyphPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<nk_font_glyph> Function(
              ffi.Pointer<nk_font>, nk_rune)>>('nk_font_find_glyph');
  late final _nk_font_find_glyph = _nk_font_find_glyphPtr.asFunction<
      ffi.Pointer<nk_font_glyph> Function(ffi.Pointer<nk_font>, int)>();

  void nk_font_atlas_cleanup(
    ffi.Pointer<nk_font_atlas> atlas,
  ) {
    return _nk_font_atlas_cleanup(
      atlas,
    );
  }

  late final _nk_font_atlas_cleanupPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<nk_font_atlas>)>>(
      'nk_font_atlas_cleanup');
  late final _nk_font_atlas_cleanup = _nk_font_atlas_cleanupPtr
      .asFunction<void Function(ffi.Pointer<nk_font_atlas>)>();

  void nk_font_atlas_clear(
    ffi.Pointer<nk_font_atlas> arg0,
  ) {
    return _nk_font_atlas_clear(
      arg0,
    );
  }

  late final _nk_font_atlas_clearPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<nk_font_atlas>)>>(
      'nk_font_atlas_clear');
  late final _nk_font_atlas_clear = _nk_font_atlas_clearPtr
      .asFunction<void Function(ffi.Pointer<nk_font_atlas>)>();

  void nk_buffer_init_default(
    ffi.Pointer<nk_buffer> arg0,
  ) {
    return _nk_buffer_init_default(
      arg0,
    );
  }

  late final _nk_buffer_init_defaultPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<nk_buffer>)>>(
          'nk_buffer_init_default');
  late final _nk_buffer_init_default = _nk_buffer_init_defaultPtr
      .asFunction<void Function(ffi.Pointer<nk_buffer>)>();

  void nk_buffer_init(
    ffi.Pointer<nk_buffer> arg0,
    ffi.Pointer<nk_allocator> arg1,
    int size,
  ) {
    return _nk_buffer_init(
      arg0,
      arg1,
      size,
    );
  }

  late final _nk_buffer_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_buffer>, ffi.Pointer<nk_allocator>,
              nk_size)>>('nk_buffer_init');
  late final _nk_buffer_init = _nk_buffer_initPtr.asFunction<
      void Function(ffi.Pointer<nk_buffer>, ffi.Pointer<nk_allocator>, int)>();

  void nk_buffer_init_fixed(
    ffi.Pointer<nk_buffer> arg0,
    ffi.Pointer<ffi.Void> memory,
    int size,
  ) {
    return _nk_buffer_init_fixed(
      arg0,
      memory,
      size,
    );
  }

  late final _nk_buffer_init_fixedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_buffer>, ffi.Pointer<ffi.Void>,
              nk_size)>>('nk_buffer_init_fixed');
  late final _nk_buffer_init_fixed = _nk_buffer_init_fixedPtr.asFunction<
      void Function(ffi.Pointer<nk_buffer>, ffi.Pointer<ffi.Void>, int)>();

  void nk_buffer_info(
    ffi.Pointer<nk_memory_status> arg0,
    ffi.Pointer<nk_buffer> arg1,
  ) {
    return _nk_buffer_info(
      arg0,
      arg1,
    );
  }

  late final _nk_buffer_infoPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_memory_status>,
              ffi.Pointer<nk_buffer>)>>('nk_buffer_info');
  late final _nk_buffer_info = _nk_buffer_infoPtr.asFunction<
      void Function(ffi.Pointer<nk_memory_status>, ffi.Pointer<nk_buffer>)>();

  void nk_buffer_push(
    ffi.Pointer<nk_buffer> arg0,
    int type,
    ffi.Pointer<ffi.Void> memory,
    int size,
    int align,
  ) {
    return _nk_buffer_push(
      arg0,
      type,
      memory,
      size,
      align,
    );
  }

  late final _nk_buffer_pushPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_buffer>, ffi.Int32,
              ffi.Pointer<ffi.Void>, nk_size, nk_size)>>('nk_buffer_push');
  late final _nk_buffer_push = _nk_buffer_pushPtr.asFunction<
      void Function(
          ffi.Pointer<nk_buffer>, int, ffi.Pointer<ffi.Void>, int, int)>();

  void nk_buffer_mark(
    ffi.Pointer<nk_buffer> arg0,
    int type,
  ) {
    return _nk_buffer_mark(
      arg0,
      type,
    );
  }

  late final _nk_buffer_markPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<nk_buffer>, ffi.Int32)>>('nk_buffer_mark');
  late final _nk_buffer_mark = _nk_buffer_markPtr
      .asFunction<void Function(ffi.Pointer<nk_buffer>, int)>();

  void nk_buffer_reset(
    ffi.Pointer<nk_buffer> arg0,
    int type,
  ) {
    return _nk_buffer_reset(
      arg0,
      type,
    );
  }

  late final _nk_buffer_resetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<nk_buffer>, ffi.Int32)>>('nk_buffer_reset');
  late final _nk_buffer_reset = _nk_buffer_resetPtr
      .asFunction<void Function(ffi.Pointer<nk_buffer>, int)>();

  void nk_buffer_clear(
    ffi.Pointer<nk_buffer> arg0,
  ) {
    return _nk_buffer_clear(
      arg0,
    );
  }

  late final _nk_buffer_clearPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<nk_buffer>)>>(
          'nk_buffer_clear');
  late final _nk_buffer_clear =
      _nk_buffer_clearPtr.asFunction<void Function(ffi.Pointer<nk_buffer>)>();

  void nk_buffer_free(
    ffi.Pointer<nk_buffer> arg0,
  ) {
    return _nk_buffer_free(
      arg0,
    );
  }

  late final _nk_buffer_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<nk_buffer>)>>(
          'nk_buffer_free');
  late final _nk_buffer_free =
      _nk_buffer_freePtr.asFunction<void Function(ffi.Pointer<nk_buffer>)>();

  ffi.Pointer<ffi.Void> nk_buffer_memory(
    ffi.Pointer<nk_buffer> arg0,
  ) {
    return _nk_buffer_memory(
      arg0,
    );
  }

  late final _nk_buffer_memoryPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<nk_buffer>)>>('nk_buffer_memory');
  late final _nk_buffer_memory = _nk_buffer_memoryPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<nk_buffer>)>();

  ffi.Pointer<ffi.Void> nk_buffer_memory_const(
    ffi.Pointer<nk_buffer> arg0,
  ) {
    return _nk_buffer_memory_const(
      arg0,
    );
  }

  late final _nk_buffer_memory_constPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<nk_buffer>)>>('nk_buffer_memory_const');
  late final _nk_buffer_memory_const = _nk_buffer_memory_constPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<nk_buffer>)>();

  int nk_buffer_total(
    ffi.Pointer<nk_buffer> arg0,
  ) {
    return _nk_buffer_total(
      arg0,
    );
  }

  late final _nk_buffer_totalPtr =
      _lookup<ffi.NativeFunction<nk_size Function(ffi.Pointer<nk_buffer>)>>(
          'nk_buffer_total');
  late final _nk_buffer_total =
      _nk_buffer_totalPtr.asFunction<int Function(ffi.Pointer<nk_buffer>)>();

  void nk_str_init_default(
    ffi.Pointer<nk_str> arg0,
  ) {
    return _nk_str_init_default(
      arg0,
    );
  }

  late final _nk_str_init_defaultPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<nk_str>)>>(
          'nk_str_init_default');
  late final _nk_str_init_default =
      _nk_str_init_defaultPtr.asFunction<void Function(ffi.Pointer<nk_str>)>();

  void nk_str_init(
    ffi.Pointer<nk_str> arg0,
    ffi.Pointer<nk_allocator> arg1,
    int size,
  ) {
    return _nk_str_init(
      arg0,
      arg1,
      size,
    );
  }

  late final _nk_str_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_str>, ffi.Pointer<nk_allocator>,
              nk_size)>>('nk_str_init');
  late final _nk_str_init = _nk_str_initPtr.asFunction<
      void Function(ffi.Pointer<nk_str>, ffi.Pointer<nk_allocator>, int)>();

  void nk_str_init_fixed(
    ffi.Pointer<nk_str> arg0,
    ffi.Pointer<ffi.Void> memory,
    int size,
  ) {
    return _nk_str_init_fixed(
      arg0,
      memory,
      size,
    );
  }

  late final _nk_str_init_fixedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_str>, ffi.Pointer<ffi.Void>,
              nk_size)>>('nk_str_init_fixed');
  late final _nk_str_init_fixed = _nk_str_init_fixedPtr.asFunction<
      void Function(ffi.Pointer<nk_str>, ffi.Pointer<ffi.Void>, int)>();

  void nk_str_clear(
    ffi.Pointer<nk_str> arg0,
  ) {
    return _nk_str_clear(
      arg0,
    );
  }

  late final _nk_str_clearPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<nk_str>)>>(
          'nk_str_clear');
  late final _nk_str_clear =
      _nk_str_clearPtr.asFunction<void Function(ffi.Pointer<nk_str>)>();

  void nk_str_free(
    ffi.Pointer<nk_str> arg0,
  ) {
    return _nk_str_free(
      arg0,
    );
  }

  late final _nk_str_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<nk_str>)>>(
          'nk_str_free');
  late final _nk_str_free =
      _nk_str_freePtr.asFunction<void Function(ffi.Pointer<nk_str>)>();

  int nk_str_append_text_char(
    ffi.Pointer<nk_str> arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
  ) {
    return _nk_str_append_text_char(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _nk_str_append_text_charPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<nk_str>, ffi.Pointer<ffi.Char>,
              ffi.Int)>>('nk_str_append_text_char');
  late final _nk_str_append_text_char = _nk_str_append_text_charPtr.asFunction<
      int Function(ffi.Pointer<nk_str>, ffi.Pointer<ffi.Char>, int)>();

  int nk_str_append_str_char(
    ffi.Pointer<nk_str> arg0,
    ffi.Pointer<ffi.Char> arg1,
  ) {
    return _nk_str_append_str_char(
      arg0,
      arg1,
    );
  }

  late final _nk_str_append_str_charPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<nk_str>,
              ffi.Pointer<ffi.Char>)>>('nk_str_append_str_char');
  late final _nk_str_append_str_char = _nk_str_append_str_charPtr
      .asFunction<int Function(ffi.Pointer<nk_str>, ffi.Pointer<ffi.Char>)>();

  int nk_str_append_text_utf8(
    ffi.Pointer<nk_str> arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
  ) {
    return _nk_str_append_text_utf8(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _nk_str_append_text_utf8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<nk_str>, ffi.Pointer<ffi.Char>,
              ffi.Int)>>('nk_str_append_text_utf8');
  late final _nk_str_append_text_utf8 = _nk_str_append_text_utf8Ptr.asFunction<
      int Function(ffi.Pointer<nk_str>, ffi.Pointer<ffi.Char>, int)>();

  int nk_str_append_str_utf8(
    ffi.Pointer<nk_str> arg0,
    ffi.Pointer<ffi.Char> arg1,
  ) {
    return _nk_str_append_str_utf8(
      arg0,
      arg1,
    );
  }

  late final _nk_str_append_str_utf8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<nk_str>,
              ffi.Pointer<ffi.Char>)>>('nk_str_append_str_utf8');
  late final _nk_str_append_str_utf8 = _nk_str_append_str_utf8Ptr
      .asFunction<int Function(ffi.Pointer<nk_str>, ffi.Pointer<ffi.Char>)>();

  int nk_str_append_text_runes(
    ffi.Pointer<nk_str> arg0,
    ffi.Pointer<nk_rune> arg1,
    int arg2,
  ) {
    return _nk_str_append_text_runes(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _nk_str_append_text_runesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<nk_str>, ffi.Pointer<nk_rune>,
              ffi.Int)>>('nk_str_append_text_runes');
  late final _nk_str_append_text_runes =
      _nk_str_append_text_runesPtr.asFunction<
          int Function(ffi.Pointer<nk_str>, ffi.Pointer<nk_rune>, int)>();

  int nk_str_append_str_runes(
    ffi.Pointer<nk_str> arg0,
    ffi.Pointer<nk_rune> arg1,
  ) {
    return _nk_str_append_str_runes(
      arg0,
      arg1,
    );
  }

  late final _nk_str_append_str_runesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<nk_str>,
              ffi.Pointer<nk_rune>)>>('nk_str_append_str_runes');
  late final _nk_str_append_str_runes = _nk_str_append_str_runesPtr
      .asFunction<int Function(ffi.Pointer<nk_str>, ffi.Pointer<nk_rune>)>();

  int nk_str_insert_at_char(
    ffi.Pointer<nk_str> arg0,
    int pos,
    ffi.Pointer<ffi.Char> arg2,
    int arg3,
  ) {
    return _nk_str_insert_at_char(
      arg0,
      pos,
      arg2,
      arg3,
    );
  }

  late final _nk_str_insert_at_charPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<nk_str>, ffi.Int, ffi.Pointer<ffi.Char>,
              ffi.Int)>>('nk_str_insert_at_char');
  late final _nk_str_insert_at_char = _nk_str_insert_at_charPtr.asFunction<
      int Function(ffi.Pointer<nk_str>, int, ffi.Pointer<ffi.Char>, int)>();

  int nk_str_insert_at_rune(
    ffi.Pointer<nk_str> arg0,
    int pos,
    ffi.Pointer<ffi.Char> arg2,
    int arg3,
  ) {
    return _nk_str_insert_at_rune(
      arg0,
      pos,
      arg2,
      arg3,
    );
  }

  late final _nk_str_insert_at_runePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<nk_str>, ffi.Int, ffi.Pointer<ffi.Char>,
              ffi.Int)>>('nk_str_insert_at_rune');
  late final _nk_str_insert_at_rune = _nk_str_insert_at_runePtr.asFunction<
      int Function(ffi.Pointer<nk_str>, int, ffi.Pointer<ffi.Char>, int)>();

  int nk_str_insert_text_char(
    ffi.Pointer<nk_str> arg0,
    int pos,
    ffi.Pointer<ffi.Char> arg2,
    int arg3,
  ) {
    return _nk_str_insert_text_char(
      arg0,
      pos,
      arg2,
      arg3,
    );
  }

  late final _nk_str_insert_text_charPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<nk_str>, ffi.Int, ffi.Pointer<ffi.Char>,
              ffi.Int)>>('nk_str_insert_text_char');
  late final _nk_str_insert_text_char = _nk_str_insert_text_charPtr.asFunction<
      int Function(ffi.Pointer<nk_str>, int, ffi.Pointer<ffi.Char>, int)>();

  int nk_str_insert_str_char(
    ffi.Pointer<nk_str> arg0,
    int pos,
    ffi.Pointer<ffi.Char> arg2,
  ) {
    return _nk_str_insert_str_char(
      arg0,
      pos,
      arg2,
    );
  }

  late final _nk_str_insert_str_charPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<nk_str>, ffi.Int,
              ffi.Pointer<ffi.Char>)>>('nk_str_insert_str_char');
  late final _nk_str_insert_str_char = _nk_str_insert_str_charPtr.asFunction<
      int Function(ffi.Pointer<nk_str>, int, ffi.Pointer<ffi.Char>)>();

  int nk_str_insert_text_utf8(
    ffi.Pointer<nk_str> arg0,
    int pos,
    ffi.Pointer<ffi.Char> arg2,
    int arg3,
  ) {
    return _nk_str_insert_text_utf8(
      arg0,
      pos,
      arg2,
      arg3,
    );
  }

  late final _nk_str_insert_text_utf8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<nk_str>, ffi.Int, ffi.Pointer<ffi.Char>,
              ffi.Int)>>('nk_str_insert_text_utf8');
  late final _nk_str_insert_text_utf8 = _nk_str_insert_text_utf8Ptr.asFunction<
      int Function(ffi.Pointer<nk_str>, int, ffi.Pointer<ffi.Char>, int)>();

  int nk_str_insert_str_utf8(
    ffi.Pointer<nk_str> arg0,
    int pos,
    ffi.Pointer<ffi.Char> arg2,
  ) {
    return _nk_str_insert_str_utf8(
      arg0,
      pos,
      arg2,
    );
  }

  late final _nk_str_insert_str_utf8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<nk_str>, ffi.Int,
              ffi.Pointer<ffi.Char>)>>('nk_str_insert_str_utf8');
  late final _nk_str_insert_str_utf8 = _nk_str_insert_str_utf8Ptr.asFunction<
      int Function(ffi.Pointer<nk_str>, int, ffi.Pointer<ffi.Char>)>();

  int nk_str_insert_text_runes(
    ffi.Pointer<nk_str> arg0,
    int pos,
    ffi.Pointer<nk_rune> arg2,
    int arg3,
  ) {
    return _nk_str_insert_text_runes(
      arg0,
      pos,
      arg2,
      arg3,
    );
  }

  late final _nk_str_insert_text_runesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<nk_str>, ffi.Int, ffi.Pointer<nk_rune>,
              ffi.Int)>>('nk_str_insert_text_runes');
  late final _nk_str_insert_text_runes =
      _nk_str_insert_text_runesPtr.asFunction<
          int Function(ffi.Pointer<nk_str>, int, ffi.Pointer<nk_rune>, int)>();

  int nk_str_insert_str_runes(
    ffi.Pointer<nk_str> arg0,
    int pos,
    ffi.Pointer<nk_rune> arg2,
  ) {
    return _nk_str_insert_str_runes(
      arg0,
      pos,
      arg2,
    );
  }

  late final _nk_str_insert_str_runesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<nk_str>, ffi.Int,
              ffi.Pointer<nk_rune>)>>('nk_str_insert_str_runes');
  late final _nk_str_insert_str_runes = _nk_str_insert_str_runesPtr.asFunction<
      int Function(ffi.Pointer<nk_str>, int, ffi.Pointer<nk_rune>)>();

  void nk_str_remove_chars(
    ffi.Pointer<nk_str> arg0,
    int len,
  ) {
    return _nk_str_remove_chars(
      arg0,
      len,
    );
  }

  late final _nk_str_remove_charsPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<nk_str>, ffi.Int)>>(
      'nk_str_remove_chars');
  late final _nk_str_remove_chars = _nk_str_remove_charsPtr
      .asFunction<void Function(ffi.Pointer<nk_str>, int)>();

  void nk_str_remove_runes(
    ffi.Pointer<nk_str> str,
    int len,
  ) {
    return _nk_str_remove_runes(
      str,
      len,
    );
  }

  late final _nk_str_remove_runesPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<nk_str>, ffi.Int)>>(
      'nk_str_remove_runes');
  late final _nk_str_remove_runes = _nk_str_remove_runesPtr
      .asFunction<void Function(ffi.Pointer<nk_str>, int)>();

  void nk_str_delete_chars(
    ffi.Pointer<nk_str> arg0,
    int pos,
    int len,
  ) {
    return _nk_str_delete_chars(
      arg0,
      pos,
      len,
    );
  }

  late final _nk_str_delete_charsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<nk_str>, ffi.Int, ffi.Int)>>('nk_str_delete_chars');
  late final _nk_str_delete_chars = _nk_str_delete_charsPtr
      .asFunction<void Function(ffi.Pointer<nk_str>, int, int)>();

  void nk_str_delete_runes(
    ffi.Pointer<nk_str> arg0,
    int pos,
    int len,
  ) {
    return _nk_str_delete_runes(
      arg0,
      pos,
      len,
    );
  }

  late final _nk_str_delete_runesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<nk_str>, ffi.Int, ffi.Int)>>('nk_str_delete_runes');
  late final _nk_str_delete_runes = _nk_str_delete_runesPtr
      .asFunction<void Function(ffi.Pointer<nk_str>, int, int)>();

  ffi.Pointer<ffi.Char> nk_str_at_char(
    ffi.Pointer<nk_str> arg0,
    int pos,
  ) {
    return _nk_str_at_char(
      arg0,
      pos,
    );
  }

  late final _nk_str_at_charPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<nk_str>, ffi.Int)>>('nk_str_at_char');
  late final _nk_str_at_char = _nk_str_at_charPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<nk_str>, int)>();

  ffi.Pointer<ffi.Char> nk_str_at_rune(
    ffi.Pointer<nk_str> arg0,
    int pos,
    ffi.Pointer<nk_rune> unicode,
    ffi.Pointer<ffi.Int> len,
  ) {
    return _nk_str_at_rune(
      arg0,
      pos,
      unicode,
      len,
    );
  }

  late final _nk_str_at_runePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<nk_str>, ffi.Int,
              ffi.Pointer<nk_rune>, ffi.Pointer<ffi.Int>)>>('nk_str_at_rune');
  late final _nk_str_at_rune = _nk_str_at_runePtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<nk_str>, int,
          ffi.Pointer<nk_rune>, ffi.Pointer<ffi.Int>)>();

  int nk_str_rune_at(
    ffi.Pointer<nk_str> arg0,
    int pos,
  ) {
    return _nk_str_rune_at(
      arg0,
      pos,
    );
  }

  late final _nk_str_rune_atPtr = _lookup<
          ffi.NativeFunction<nk_rune Function(ffi.Pointer<nk_str>, ffi.Int)>>(
      'nk_str_rune_at');
  late final _nk_str_rune_at =
      _nk_str_rune_atPtr.asFunction<int Function(ffi.Pointer<nk_str>, int)>();

  ffi.Pointer<ffi.Char> nk_str_at_char_const(
    ffi.Pointer<nk_str> arg0,
    int pos,
  ) {
    return _nk_str_at_char_const(
      arg0,
      pos,
    );
  }

  late final _nk_str_at_char_constPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<nk_str>, ffi.Int)>>('nk_str_at_char_const');
  late final _nk_str_at_char_const = _nk_str_at_char_constPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<nk_str>, int)>();

  ffi.Pointer<ffi.Char> nk_str_at_const(
    ffi.Pointer<nk_str> arg0,
    int pos,
    ffi.Pointer<nk_rune> unicode,
    ffi.Pointer<ffi.Int> len,
  ) {
    return _nk_str_at_const(
      arg0,
      pos,
      unicode,
      len,
    );
  }

  late final _nk_str_at_constPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<nk_str>, ffi.Int,
              ffi.Pointer<nk_rune>, ffi.Pointer<ffi.Int>)>>('nk_str_at_const');
  late final _nk_str_at_const = _nk_str_at_constPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<nk_str>, int,
          ffi.Pointer<nk_rune>, ffi.Pointer<ffi.Int>)>();

  ffi.Pointer<ffi.Char> nk_str_get(
    ffi.Pointer<nk_str> arg0,
  ) {
    return _nk_str_get(
      arg0,
    );
  }

  late final _nk_str_getPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<nk_str>)>>('nk_str_get');
  late final _nk_str_get = _nk_str_getPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<nk_str>)>();

  ffi.Pointer<ffi.Char> nk_str_get_const(
    ffi.Pointer<nk_str> arg0,
  ) {
    return _nk_str_get_const(
      arg0,
    );
  }

  late final _nk_str_get_constPtr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<nk_str>)>>(
      'nk_str_get_const');
  late final _nk_str_get_const = _nk_str_get_constPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<nk_str>)>();

  int nk_str_len(
    ffi.Pointer<nk_str> arg0,
  ) {
    return _nk_str_len(
      arg0,
    );
  }

  late final _nk_str_lenPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<nk_str>)>>(
          'nk_str_len');
  late final _nk_str_len =
      _nk_str_lenPtr.asFunction<int Function(ffi.Pointer<nk_str>)>();

  int nk_str_len_char(
    ffi.Pointer<nk_str> arg0,
  ) {
    return _nk_str_len_char(
      arg0,
    );
  }

  late final _nk_str_len_charPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<nk_str>)>>(
          'nk_str_len_char');
  late final _nk_str_len_char =
      _nk_str_len_charPtr.asFunction<int Function(ffi.Pointer<nk_str>)>();

  /// filter function
  int nk_filter_default(
    ffi.Pointer<nk_text_edit> arg0,
    int unicode,
  ) {
    return _nk_filter_default(
      arg0,
      unicode,
    );
  }

  late final _nk_filter_defaultPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(
              ffi.Pointer<nk_text_edit>, nk_rune)>>('nk_filter_default');
  late final _nk_filter_default = _nk_filter_defaultPtr
      .asFunction<int Function(ffi.Pointer<nk_text_edit>, int)>();

  int nk_filter_ascii(
    ffi.Pointer<nk_text_edit> arg0,
    int unicode,
  ) {
    return _nk_filter_ascii(
      arg0,
      unicode,
    );
  }

  late final _nk_filter_asciiPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(
              ffi.Pointer<nk_text_edit>, nk_rune)>>('nk_filter_ascii');
  late final _nk_filter_ascii = _nk_filter_asciiPtr
      .asFunction<int Function(ffi.Pointer<nk_text_edit>, int)>();

  int nk_filter_float(
    ffi.Pointer<nk_text_edit> arg0,
    int unicode,
  ) {
    return _nk_filter_float(
      arg0,
      unicode,
    );
  }

  late final _nk_filter_floatPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(
              ffi.Pointer<nk_text_edit>, nk_rune)>>('nk_filter_float');
  late final _nk_filter_float = _nk_filter_floatPtr
      .asFunction<int Function(ffi.Pointer<nk_text_edit>, int)>();

  int nk_filter_decimal(
    ffi.Pointer<nk_text_edit> arg0,
    int unicode,
  ) {
    return _nk_filter_decimal(
      arg0,
      unicode,
    );
  }

  late final _nk_filter_decimalPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(
              ffi.Pointer<nk_text_edit>, nk_rune)>>('nk_filter_decimal');
  late final _nk_filter_decimal = _nk_filter_decimalPtr
      .asFunction<int Function(ffi.Pointer<nk_text_edit>, int)>();

  int nk_filter_hex(
    ffi.Pointer<nk_text_edit> arg0,
    int unicode,
  ) {
    return _nk_filter_hex(
      arg0,
      unicode,
    );
  }

  late final _nk_filter_hexPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(
              ffi.Pointer<nk_text_edit>, nk_rune)>>('nk_filter_hex');
  late final _nk_filter_hex = _nk_filter_hexPtr
      .asFunction<int Function(ffi.Pointer<nk_text_edit>, int)>();

  int nk_filter_oct(
    ffi.Pointer<nk_text_edit> arg0,
    int unicode,
  ) {
    return _nk_filter_oct(
      arg0,
      unicode,
    );
  }

  late final _nk_filter_octPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(
              ffi.Pointer<nk_text_edit>, nk_rune)>>('nk_filter_oct');
  late final _nk_filter_oct = _nk_filter_octPtr
      .asFunction<int Function(ffi.Pointer<nk_text_edit>, int)>();

  int nk_filter_binary(
    ffi.Pointer<nk_text_edit> arg0,
    int unicode,
  ) {
    return _nk_filter_binary(
      arg0,
      unicode,
    );
  }

  late final _nk_filter_binaryPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(
              ffi.Pointer<nk_text_edit>, nk_rune)>>('nk_filter_binary');
  late final _nk_filter_binary = _nk_filter_binaryPtr
      .asFunction<int Function(ffi.Pointer<nk_text_edit>, int)>();

  void nk_textedit_init_default(
    ffi.Pointer<nk_text_edit> arg0,
  ) {
    return _nk_textedit_init_default(
      arg0,
    );
  }

  late final _nk_textedit_init_defaultPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<nk_text_edit>)>>(
          'nk_textedit_init_default');
  late final _nk_textedit_init_default = _nk_textedit_init_defaultPtr
      .asFunction<void Function(ffi.Pointer<nk_text_edit>)>();

  void nk_textedit_init(
    ffi.Pointer<nk_text_edit> arg0,
    ffi.Pointer<nk_allocator> arg1,
    int size,
  ) {
    return _nk_textedit_init(
      arg0,
      arg1,
      size,
    );
  }

  late final _nk_textedit_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_text_edit>,
              ffi.Pointer<nk_allocator>, nk_size)>>('nk_textedit_init');
  late final _nk_textedit_init = _nk_textedit_initPtr.asFunction<
      void Function(
          ffi.Pointer<nk_text_edit>, ffi.Pointer<nk_allocator>, int)>();

  void nk_textedit_init_fixed(
    ffi.Pointer<nk_text_edit> arg0,
    ffi.Pointer<ffi.Void> memory,
    int size,
  ) {
    return _nk_textedit_init_fixed(
      arg0,
      memory,
      size,
    );
  }

  late final _nk_textedit_init_fixedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_text_edit>, ffi.Pointer<ffi.Void>,
              nk_size)>>('nk_textedit_init_fixed');
  late final _nk_textedit_init_fixed = _nk_textedit_init_fixedPtr.asFunction<
      void Function(ffi.Pointer<nk_text_edit>, ffi.Pointer<ffi.Void>, int)>();

  void nk_textedit_free(
    ffi.Pointer<nk_text_edit> arg0,
  ) {
    return _nk_textedit_free(
      arg0,
    );
  }

  late final _nk_textedit_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<nk_text_edit>)>>(
          'nk_textedit_free');
  late final _nk_textedit_free = _nk_textedit_freePtr
      .asFunction<void Function(ffi.Pointer<nk_text_edit>)>();

  void nk_textedit_text(
    ffi.Pointer<nk_text_edit> arg0,
    ffi.Pointer<ffi.Char> arg1,
    int total_len,
  ) {
    return _nk_textedit_text(
      arg0,
      arg1,
      total_len,
    );
  }

  late final _nk_textedit_textPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_text_edit>, ffi.Pointer<ffi.Char>,
              ffi.Int)>>('nk_textedit_text');
  late final _nk_textedit_text = _nk_textedit_textPtr.asFunction<
      void Function(ffi.Pointer<nk_text_edit>, ffi.Pointer<ffi.Char>, int)>();

  void nk_textedit_delete(
    ffi.Pointer<nk_text_edit> arg0,
    int where,
    int len,
  ) {
    return _nk_textedit_delete(
      arg0,
      where,
      len,
    );
  }

  late final _nk_textedit_deletePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_text_edit>, ffi.Int,
              ffi.Int)>>('nk_textedit_delete');
  late final _nk_textedit_delete = _nk_textedit_deletePtr
      .asFunction<void Function(ffi.Pointer<nk_text_edit>, int, int)>();

  void nk_textedit_delete_selection(
    ffi.Pointer<nk_text_edit> arg0,
  ) {
    return _nk_textedit_delete_selection(
      arg0,
    );
  }

  late final _nk_textedit_delete_selectionPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<nk_text_edit>)>>(
          'nk_textedit_delete_selection');
  late final _nk_textedit_delete_selection = _nk_textedit_delete_selectionPtr
      .asFunction<void Function(ffi.Pointer<nk_text_edit>)>();

  void nk_textedit_select_all(
    ffi.Pointer<nk_text_edit> arg0,
  ) {
    return _nk_textedit_select_all(
      arg0,
    );
  }

  late final _nk_textedit_select_allPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<nk_text_edit>)>>(
          'nk_textedit_select_all');
  late final _nk_textedit_select_all = _nk_textedit_select_allPtr
      .asFunction<void Function(ffi.Pointer<nk_text_edit>)>();

  int nk_textedit_cut(
    ffi.Pointer<nk_text_edit> arg0,
  ) {
    return _nk_textedit_cut(
      arg0,
    );
  }

  late final _nk_textedit_cutPtr =
      _lookup<ffi.NativeFunction<nk_bool Function(ffi.Pointer<nk_text_edit>)>>(
          'nk_textedit_cut');
  late final _nk_textedit_cut =
      _nk_textedit_cutPtr.asFunction<int Function(ffi.Pointer<nk_text_edit>)>();

  int nk_textedit_paste(
    ffi.Pointer<nk_text_edit> arg0,
    ffi.Pointer<ffi.Char> arg1,
    int len,
  ) {
    return _nk_textedit_paste(
      arg0,
      arg1,
      len,
    );
  }

  late final _nk_textedit_pastePtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(ffi.Pointer<nk_text_edit>, ffi.Pointer<ffi.Char>,
              ffi.Int)>>('nk_textedit_paste');
  late final _nk_textedit_paste = _nk_textedit_pastePtr.asFunction<
      int Function(ffi.Pointer<nk_text_edit>, ffi.Pointer<ffi.Char>, int)>();

  void nk_textedit_undo(
    ffi.Pointer<nk_text_edit> arg0,
  ) {
    return _nk_textedit_undo(
      arg0,
    );
  }

  late final _nk_textedit_undoPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<nk_text_edit>)>>(
          'nk_textedit_undo');
  late final _nk_textedit_undo = _nk_textedit_undoPtr
      .asFunction<void Function(ffi.Pointer<nk_text_edit>)>();

  void nk_textedit_redo(
    ffi.Pointer<nk_text_edit> arg0,
  ) {
    return _nk_textedit_redo(
      arg0,
    );
  }

  late final _nk_textedit_redoPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<nk_text_edit>)>>(
          'nk_textedit_redo');
  late final _nk_textedit_redo = _nk_textedit_redoPtr
      .asFunction<void Function(ffi.Pointer<nk_text_edit>)>();

  /// shape outlines
  void nk_stroke_line(
    ffi.Pointer<nk_command_buffer> b,
    double x0,
    double y0,
    double x1,
    double y1,
    double line_thickness,
    nk_color arg6,
  ) {
    return _nk_stroke_line(
      b,
      x0,
      y0,
      x1,
      y1,
      line_thickness,
      arg6,
    );
  }

  late final _nk_stroke_linePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<nk_command_buffer>,
              ffi.Float,
              ffi.Float,
              ffi.Float,
              ffi.Float,
              ffi.Float,
              nk_color)>>('nk_stroke_line');
  late final _nk_stroke_line = _nk_stroke_linePtr.asFunction<
      void Function(ffi.Pointer<nk_command_buffer>, double, double, double,
          double, double, nk_color)>();

  void nk_stroke_curve(
    ffi.Pointer<nk_command_buffer> arg0,
    double arg1,
    double arg2,
    double arg3,
    double arg4,
    double arg5,
    double arg6,
    double arg7,
    double arg8,
    double line_thickness,
    nk_color arg10,
  ) {
    return _nk_stroke_curve(
      arg0,
      arg1,
      arg2,
      arg3,
      arg4,
      arg5,
      arg6,
      arg7,
      arg8,
      line_thickness,
      arg10,
    );
  }

  late final _nk_stroke_curvePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<nk_command_buffer>,
              ffi.Float,
              ffi.Float,
              ffi.Float,
              ffi.Float,
              ffi.Float,
              ffi.Float,
              ffi.Float,
              ffi.Float,
              ffi.Float,
              nk_color)>>('nk_stroke_curve');
  late final _nk_stroke_curve = _nk_stroke_curvePtr.asFunction<
      void Function(ffi.Pointer<nk_command_buffer>, double, double, double,
          double, double, double, double, double, double, nk_color)>();

  void nk_stroke_rect(
    ffi.Pointer<nk_command_buffer> arg0,
    nk_rect arg1,
    double rounding,
    double line_thickness,
    nk_color arg4,
  ) {
    return _nk_stroke_rect(
      arg0,
      arg1,
      rounding,
      line_thickness,
      arg4,
    );
  }

  late final _nk_stroke_rectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_command_buffer>, nk_rect, ffi.Float,
              ffi.Float, nk_color)>>('nk_stroke_rect');
  late final _nk_stroke_rect = _nk_stroke_rectPtr.asFunction<
      void Function(
          ffi.Pointer<nk_command_buffer>, nk_rect, double, double, nk_color)>();

  void nk_stroke_circle(
    ffi.Pointer<nk_command_buffer> arg0,
    nk_rect arg1,
    double line_thickness,
    nk_color arg3,
  ) {
    return _nk_stroke_circle(
      arg0,
      arg1,
      line_thickness,
      arg3,
    );
  }

  late final _nk_stroke_circlePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_command_buffer>, nk_rect, ffi.Float,
              nk_color)>>('nk_stroke_circle');
  late final _nk_stroke_circle = _nk_stroke_circlePtr.asFunction<
      void Function(
          ffi.Pointer<nk_command_buffer>, nk_rect, double, nk_color)>();

  void nk_stroke_arc(
    ffi.Pointer<nk_command_buffer> arg0,
    double cx,
    double cy,
    double radius,
    double a_min,
    double a_max,
    double line_thickness,
    nk_color arg7,
  ) {
    return _nk_stroke_arc(
      arg0,
      cx,
      cy,
      radius,
      a_min,
      a_max,
      line_thickness,
      arg7,
    );
  }

  late final _nk_stroke_arcPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<nk_command_buffer>,
              ffi.Float,
              ffi.Float,
              ffi.Float,
              ffi.Float,
              ffi.Float,
              ffi.Float,
              nk_color)>>('nk_stroke_arc');
  late final _nk_stroke_arc = _nk_stroke_arcPtr.asFunction<
      void Function(ffi.Pointer<nk_command_buffer>, double, double, double,
          double, double, double, nk_color)>();

  void nk_stroke_triangle(
    ffi.Pointer<nk_command_buffer> arg0,
    double arg1,
    double arg2,
    double arg3,
    double arg4,
    double arg5,
    double arg6,
    double line_thichness,
    nk_color arg8,
  ) {
    return _nk_stroke_triangle(
      arg0,
      arg1,
      arg2,
      arg3,
      arg4,
      arg5,
      arg6,
      line_thichness,
      arg8,
    );
  }

  late final _nk_stroke_trianglePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<nk_command_buffer>,
              ffi.Float,
              ffi.Float,
              ffi.Float,
              ffi.Float,
              ffi.Float,
              ffi.Float,
              ffi.Float,
              nk_color)>>('nk_stroke_triangle');
  late final _nk_stroke_triangle = _nk_stroke_trianglePtr.asFunction<
      void Function(ffi.Pointer<nk_command_buffer>, double, double, double,
          double, double, double, double, nk_color)>();

  void nk_stroke_polyline(
    ffi.Pointer<nk_command_buffer> arg0,
    ffi.Pointer<ffi.Float> points,
    int point_count,
    double line_thickness,
    nk_color col,
  ) {
    return _nk_stroke_polyline(
      arg0,
      points,
      point_count,
      line_thickness,
      col,
    );
  }

  late final _nk_stroke_polylinePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<nk_command_buffer>,
              ffi.Pointer<ffi.Float>,
              ffi.Int,
              ffi.Float,
              nk_color)>>('nk_stroke_polyline');
  late final _nk_stroke_polyline = _nk_stroke_polylinePtr.asFunction<
      void Function(ffi.Pointer<nk_command_buffer>, ffi.Pointer<ffi.Float>, int,
          double, nk_color)>();

  void nk_stroke_polygon(
    ffi.Pointer<nk_command_buffer> arg0,
    ffi.Pointer<ffi.Float> points,
    int point_count,
    double line_thickness,
    nk_color arg4,
  ) {
    return _nk_stroke_polygon(
      arg0,
      points,
      point_count,
      line_thickness,
      arg4,
    );
  }

  late final _nk_stroke_polygonPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<nk_command_buffer>,
              ffi.Pointer<ffi.Float>,
              ffi.Int,
              ffi.Float,
              nk_color)>>('nk_stroke_polygon');
  late final _nk_stroke_polygon = _nk_stroke_polygonPtr.asFunction<
      void Function(ffi.Pointer<nk_command_buffer>, ffi.Pointer<ffi.Float>, int,
          double, nk_color)>();

  /// filled shades
  void nk_fill_rect(
    ffi.Pointer<nk_command_buffer> arg0,
    nk_rect arg1,
    double rounding,
    nk_color arg3,
  ) {
    return _nk_fill_rect(
      arg0,
      arg1,
      rounding,
      arg3,
    );
  }

  late final _nk_fill_rectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_command_buffer>, nk_rect, ffi.Float,
              nk_color)>>('nk_fill_rect');
  late final _nk_fill_rect = _nk_fill_rectPtr.asFunction<
      void Function(
          ffi.Pointer<nk_command_buffer>, nk_rect, double, nk_color)>();

  void nk_fill_rect_multi_color(
    ffi.Pointer<nk_command_buffer> arg0,
    nk_rect arg1,
    nk_color left,
    nk_color top,
    nk_color right,
    nk_color bottom,
  ) {
    return _nk_fill_rect_multi_color(
      arg0,
      arg1,
      left,
      top,
      right,
      bottom,
    );
  }

  late final _nk_fill_rect_multi_colorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_command_buffer>, nk_rect, nk_color,
              nk_color, nk_color, nk_color)>>('nk_fill_rect_multi_color');
  late final _nk_fill_rect_multi_color =
      _nk_fill_rect_multi_colorPtr.asFunction<
          void Function(ffi.Pointer<nk_command_buffer>, nk_rect, nk_color,
              nk_color, nk_color, nk_color)>();

  void nk_fill_circle(
    ffi.Pointer<nk_command_buffer> arg0,
    nk_rect arg1,
    nk_color arg2,
  ) {
    return _nk_fill_circle(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _nk_fill_circlePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_command_buffer>, nk_rect,
              nk_color)>>('nk_fill_circle');
  late final _nk_fill_circle = _nk_fill_circlePtr.asFunction<
      void Function(ffi.Pointer<nk_command_buffer>, nk_rect, nk_color)>();

  void nk_fill_arc(
    ffi.Pointer<nk_command_buffer> arg0,
    double cx,
    double cy,
    double radius,
    double a_min,
    double a_max,
    nk_color arg6,
  ) {
    return _nk_fill_arc(
      arg0,
      cx,
      cy,
      radius,
      a_min,
      a_max,
      arg6,
    );
  }

  late final _nk_fill_arcPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<nk_command_buffer>,
              ffi.Float,
              ffi.Float,
              ffi.Float,
              ffi.Float,
              ffi.Float,
              nk_color)>>('nk_fill_arc');
  late final _nk_fill_arc = _nk_fill_arcPtr.asFunction<
      void Function(ffi.Pointer<nk_command_buffer>, double, double, double,
          double, double, nk_color)>();

  void nk_fill_triangle(
    ffi.Pointer<nk_command_buffer> arg0,
    double x0,
    double y0,
    double x1,
    double y1,
    double x2,
    double y2,
    nk_color arg7,
  ) {
    return _nk_fill_triangle(
      arg0,
      x0,
      y0,
      x1,
      y1,
      x2,
      y2,
      arg7,
    );
  }

  late final _nk_fill_trianglePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<nk_command_buffer>,
              ffi.Float,
              ffi.Float,
              ffi.Float,
              ffi.Float,
              ffi.Float,
              ffi.Float,
              nk_color)>>('nk_fill_triangle');
  late final _nk_fill_triangle = _nk_fill_trianglePtr.asFunction<
      void Function(ffi.Pointer<nk_command_buffer>, double, double, double,
          double, double, double, nk_color)>();

  void nk_fill_polygon(
    ffi.Pointer<nk_command_buffer> arg0,
    ffi.Pointer<ffi.Float> points,
    int point_count,
    nk_color arg3,
  ) {
    return _nk_fill_polygon(
      arg0,
      points,
      point_count,
      arg3,
    );
  }

  late final _nk_fill_polygonPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_command_buffer>,
              ffi.Pointer<ffi.Float>, ffi.Int, nk_color)>>('nk_fill_polygon');
  late final _nk_fill_polygon = _nk_fill_polygonPtr.asFunction<
      void Function(ffi.Pointer<nk_command_buffer>, ffi.Pointer<ffi.Float>, int,
          nk_color)>();

  /// misc
  void nk_draw_image(
    ffi.Pointer<nk_command_buffer> arg0,
    nk_rect arg1,
    ffi.Pointer<nk_image> arg2,
    nk_color arg3,
  ) {
    return _nk_draw_image(
      arg0,
      arg1,
      arg2,
      arg3,
    );
  }

  late final _nk_draw_imagePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_command_buffer>, nk_rect,
              ffi.Pointer<nk_image>, nk_color)>>('nk_draw_image');
  late final _nk_draw_image = _nk_draw_imagePtr.asFunction<
      void Function(ffi.Pointer<nk_command_buffer>, nk_rect,
          ffi.Pointer<nk_image>, nk_color)>();

  void nk_draw_nine_slice(
    ffi.Pointer<nk_command_buffer> arg0,
    nk_rect arg1,
    ffi.Pointer<nk_nine_slice> arg2,
    nk_color arg3,
  ) {
    return _nk_draw_nine_slice(
      arg0,
      arg1,
      arg2,
      arg3,
    );
  }

  late final _nk_draw_nine_slicePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_command_buffer>, nk_rect,
              ffi.Pointer<nk_nine_slice>, nk_color)>>('nk_draw_nine_slice');
  late final _nk_draw_nine_slice = _nk_draw_nine_slicePtr.asFunction<
      void Function(ffi.Pointer<nk_command_buffer>, nk_rect,
          ffi.Pointer<nk_nine_slice>, nk_color)>();

  void nk_draw_text(
    ffi.Pointer<nk_command_buffer> arg0,
    nk_rect arg1,
    ffi.Pointer<ffi.Char> text,
    int len,
    ffi.Pointer<nk_user_font> arg4,
    nk_color arg5,
    nk_color arg6,
  ) {
    return _nk_draw_text(
      arg0,
      arg1,
      text,
      len,
      arg4,
      arg5,
      arg6,
    );
  }

  late final _nk_draw_textPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<nk_command_buffer>,
              nk_rect,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              ffi.Pointer<nk_user_font>,
              nk_color,
              nk_color)>>('nk_draw_text');
  late final _nk_draw_text = _nk_draw_textPtr.asFunction<
      void Function(
          ffi.Pointer<nk_command_buffer>,
          nk_rect,
          ffi.Pointer<ffi.Char>,
          int,
          ffi.Pointer<nk_user_font>,
          nk_color,
          nk_color)>();

  void nk_push_scissor(
    ffi.Pointer<nk_command_buffer> arg0,
    nk_rect arg1,
  ) {
    return _nk_push_scissor(
      arg0,
      arg1,
    );
  }

  late final _nk_push_scissorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<nk_command_buffer>, nk_rect)>>('nk_push_scissor');
  late final _nk_push_scissor = _nk_push_scissorPtr
      .asFunction<void Function(ffi.Pointer<nk_command_buffer>, nk_rect)>();

  void nk_push_custom(
    ffi.Pointer<nk_command_buffer> arg0,
    nk_rect arg1,
    nk_command_custom_callback arg2,
    nk_handle usr,
  ) {
    return _nk_push_custom(
      arg0,
      arg1,
      arg2,
      usr,
    );
  }

  late final _nk_push_customPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_command_buffer>, nk_rect,
              nk_command_custom_callback, nk_handle)>>('nk_push_custom');
  late final _nk_push_custom = _nk_push_customPtr.asFunction<
      void Function(ffi.Pointer<nk_command_buffer>, nk_rect,
          nk_command_custom_callback, nk_handle)>();

  int nk_input_has_mouse_click(
    ffi.Pointer<nk_input> arg0,
    int arg1,
  ) {
    return _nk_input_has_mouse_click(
      arg0,
      arg1,
    );
  }

  late final _nk_input_has_mouse_clickPtr = _lookup<
          ffi
          .NativeFunction<nk_bool Function(ffi.Pointer<nk_input>, ffi.Int32)>>(
      'nk_input_has_mouse_click');
  late final _nk_input_has_mouse_click = _nk_input_has_mouse_clickPtr
      .asFunction<int Function(ffi.Pointer<nk_input>, int)>();

  int nk_input_has_mouse_click_in_rect(
    ffi.Pointer<nk_input> arg0,
    int arg1,
    nk_rect arg2,
  ) {
    return _nk_input_has_mouse_click_in_rect(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _nk_input_has_mouse_click_in_rectPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(ffi.Pointer<nk_input>, ffi.Int32,
              nk_rect)>>('nk_input_has_mouse_click_in_rect');
  late final _nk_input_has_mouse_click_in_rect =
      _nk_input_has_mouse_click_in_rectPtr
          .asFunction<int Function(ffi.Pointer<nk_input>, int, nk_rect)>();

  int nk_input_has_mouse_click_in_button_rect(
    ffi.Pointer<nk_input> arg0,
    int arg1,
    nk_rect arg2,
  ) {
    return _nk_input_has_mouse_click_in_button_rect(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _nk_input_has_mouse_click_in_button_rectPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(ffi.Pointer<nk_input>, ffi.Int32,
              nk_rect)>>('nk_input_has_mouse_click_in_button_rect');
  late final _nk_input_has_mouse_click_in_button_rect =
      _nk_input_has_mouse_click_in_button_rectPtr
          .asFunction<int Function(ffi.Pointer<nk_input>, int, nk_rect)>();

  int nk_input_has_mouse_click_down_in_rect(
    ffi.Pointer<nk_input> arg0,
    int arg1,
    nk_rect arg2,
    int down,
  ) {
    return _nk_input_has_mouse_click_down_in_rect(
      arg0,
      arg1,
      arg2,
      down,
    );
  }

  late final _nk_input_has_mouse_click_down_in_rectPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(ffi.Pointer<nk_input>, ffi.Int32, nk_rect,
              nk_bool)>>('nk_input_has_mouse_click_down_in_rect');
  late final _nk_input_has_mouse_click_down_in_rect =
      _nk_input_has_mouse_click_down_in_rectPtr
          .asFunction<int Function(ffi.Pointer<nk_input>, int, nk_rect, int)>();

  int nk_input_is_mouse_click_in_rect(
    ffi.Pointer<nk_input> arg0,
    int arg1,
    nk_rect arg2,
  ) {
    return _nk_input_is_mouse_click_in_rect(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _nk_input_is_mouse_click_in_rectPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(ffi.Pointer<nk_input>, ffi.Int32,
              nk_rect)>>('nk_input_is_mouse_click_in_rect');
  late final _nk_input_is_mouse_click_in_rect =
      _nk_input_is_mouse_click_in_rectPtr
          .asFunction<int Function(ffi.Pointer<nk_input>, int, nk_rect)>();

  int nk_input_is_mouse_click_down_in_rect(
    ffi.Pointer<nk_input> i,
    int id,
    nk_rect b,
    int down,
  ) {
    return _nk_input_is_mouse_click_down_in_rect(
      i,
      id,
      b,
      down,
    );
  }

  late final _nk_input_is_mouse_click_down_in_rectPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(ffi.Pointer<nk_input>, ffi.Int32, nk_rect,
              nk_bool)>>('nk_input_is_mouse_click_down_in_rect');
  late final _nk_input_is_mouse_click_down_in_rect =
      _nk_input_is_mouse_click_down_in_rectPtr
          .asFunction<int Function(ffi.Pointer<nk_input>, int, nk_rect, int)>();

  int nk_input_any_mouse_click_in_rect(
    ffi.Pointer<nk_input> arg0,
    nk_rect arg1,
  ) {
    return _nk_input_any_mouse_click_in_rect(
      arg0,
      arg1,
    );
  }

  late final _nk_input_any_mouse_click_in_rectPtr = _lookup<
          ffi.NativeFunction<nk_bool Function(ffi.Pointer<nk_input>, nk_rect)>>(
      'nk_input_any_mouse_click_in_rect');
  late final _nk_input_any_mouse_click_in_rect =
      _nk_input_any_mouse_click_in_rectPtr
          .asFunction<int Function(ffi.Pointer<nk_input>, nk_rect)>();

  int nk_input_is_mouse_prev_hovering_rect(
    ffi.Pointer<nk_input> arg0,
    nk_rect arg1,
  ) {
    return _nk_input_is_mouse_prev_hovering_rect(
      arg0,
      arg1,
    );
  }

  late final _nk_input_is_mouse_prev_hovering_rectPtr = _lookup<
          ffi.NativeFunction<nk_bool Function(ffi.Pointer<nk_input>, nk_rect)>>(
      'nk_input_is_mouse_prev_hovering_rect');
  late final _nk_input_is_mouse_prev_hovering_rect =
      _nk_input_is_mouse_prev_hovering_rectPtr
          .asFunction<int Function(ffi.Pointer<nk_input>, nk_rect)>();

  int nk_input_is_mouse_hovering_rect(
    ffi.Pointer<nk_input> arg0,
    nk_rect arg1,
  ) {
    return _nk_input_is_mouse_hovering_rect(
      arg0,
      arg1,
    );
  }

  late final _nk_input_is_mouse_hovering_rectPtr = _lookup<
          ffi.NativeFunction<nk_bool Function(ffi.Pointer<nk_input>, nk_rect)>>(
      'nk_input_is_mouse_hovering_rect');
  late final _nk_input_is_mouse_hovering_rect =
      _nk_input_is_mouse_hovering_rectPtr
          .asFunction<int Function(ffi.Pointer<nk_input>, nk_rect)>();

  int nk_input_mouse_clicked(
    ffi.Pointer<nk_input> arg0,
    int arg1,
    nk_rect arg2,
  ) {
    return _nk_input_mouse_clicked(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _nk_input_mouse_clickedPtr = _lookup<
      ffi.NativeFunction<
          nk_bool Function(ffi.Pointer<nk_input>, ffi.Int32,
              nk_rect)>>('nk_input_mouse_clicked');
  late final _nk_input_mouse_clicked = _nk_input_mouse_clickedPtr
      .asFunction<int Function(ffi.Pointer<nk_input>, int, nk_rect)>();

  int nk_input_is_mouse_down(
    ffi.Pointer<nk_input> arg0,
    int arg1,
  ) {
    return _nk_input_is_mouse_down(
      arg0,
      arg1,
    );
  }

  late final _nk_input_is_mouse_downPtr = _lookup<
          ffi
          .NativeFunction<nk_bool Function(ffi.Pointer<nk_input>, ffi.Int32)>>(
      'nk_input_is_mouse_down');
  late final _nk_input_is_mouse_down = _nk_input_is_mouse_downPtr
      .asFunction<int Function(ffi.Pointer<nk_input>, int)>();

  int nk_input_is_mouse_pressed(
    ffi.Pointer<nk_input> arg0,
    int arg1,
  ) {
    return _nk_input_is_mouse_pressed(
      arg0,
      arg1,
    );
  }

  late final _nk_input_is_mouse_pressedPtr = _lookup<
          ffi
          .NativeFunction<nk_bool Function(ffi.Pointer<nk_input>, ffi.Int32)>>(
      'nk_input_is_mouse_pressed');
  late final _nk_input_is_mouse_pressed = _nk_input_is_mouse_pressedPtr
      .asFunction<int Function(ffi.Pointer<nk_input>, int)>();

  int nk_input_is_mouse_released(
    ffi.Pointer<nk_input> arg0,
    int arg1,
  ) {
    return _nk_input_is_mouse_released(
      arg0,
      arg1,
    );
  }

  late final _nk_input_is_mouse_releasedPtr = _lookup<
          ffi
          .NativeFunction<nk_bool Function(ffi.Pointer<nk_input>, ffi.Int32)>>(
      'nk_input_is_mouse_released');
  late final _nk_input_is_mouse_released = _nk_input_is_mouse_releasedPtr
      .asFunction<int Function(ffi.Pointer<nk_input>, int)>();

  int nk_input_is_key_pressed(
    ffi.Pointer<nk_input> arg0,
    int arg1,
  ) {
    return _nk_input_is_key_pressed(
      arg0,
      arg1,
    );
  }

  late final _nk_input_is_key_pressedPtr = _lookup<
          ffi
          .NativeFunction<nk_bool Function(ffi.Pointer<nk_input>, ffi.Int32)>>(
      'nk_input_is_key_pressed');
  late final _nk_input_is_key_pressed = _nk_input_is_key_pressedPtr
      .asFunction<int Function(ffi.Pointer<nk_input>, int)>();

  int nk_input_is_key_released(
    ffi.Pointer<nk_input> arg0,
    int arg1,
  ) {
    return _nk_input_is_key_released(
      arg0,
      arg1,
    );
  }

  late final _nk_input_is_key_releasedPtr = _lookup<
          ffi
          .NativeFunction<nk_bool Function(ffi.Pointer<nk_input>, ffi.Int32)>>(
      'nk_input_is_key_released');
  late final _nk_input_is_key_released = _nk_input_is_key_releasedPtr
      .asFunction<int Function(ffi.Pointer<nk_input>, int)>();

  int nk_input_is_key_down(
    ffi.Pointer<nk_input> arg0,
    int arg1,
  ) {
    return _nk_input_is_key_down(
      arg0,
      arg1,
    );
  }

  late final _nk_input_is_key_downPtr = _lookup<
          ffi
          .NativeFunction<nk_bool Function(ffi.Pointer<nk_input>, ffi.Int32)>>(
      'nk_input_is_key_down');
  late final _nk_input_is_key_down = _nk_input_is_key_downPtr
      .asFunction<int Function(ffi.Pointer<nk_input>, int)>();

  void nk_draw_list_init(
    ffi.Pointer<nk_draw_list> arg0,
  ) {
    return _nk_draw_list_init(
      arg0,
    );
  }

  late final _nk_draw_list_initPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<nk_draw_list>)>>(
          'nk_draw_list_init');
  late final _nk_draw_list_init = _nk_draw_list_initPtr
      .asFunction<void Function(ffi.Pointer<nk_draw_list>)>();

  void nk_draw_list_setup(
    ffi.Pointer<nk_draw_list> arg0,
    ffi.Pointer<nk_convert_config> arg1,
    ffi.Pointer<nk_buffer> cmds,
    ffi.Pointer<nk_buffer> vertices,
    ffi.Pointer<nk_buffer> elements,
    int line_aa,
    int shape_aa,
  ) {
    return _nk_draw_list_setup(
      arg0,
      arg1,
      cmds,
      vertices,
      elements,
      line_aa,
      shape_aa,
    );
  }

  late final _nk_draw_list_setupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<nk_draw_list>,
              ffi.Pointer<nk_convert_config>,
              ffi.Pointer<nk_buffer>,
              ffi.Pointer<nk_buffer>,
              ffi.Pointer<nk_buffer>,
              ffi.Int32,
              ffi.Int32)>>('nk_draw_list_setup');
  late final _nk_draw_list_setup = _nk_draw_list_setupPtr.asFunction<
      void Function(
          ffi.Pointer<nk_draw_list>,
          ffi.Pointer<nk_convert_config>,
          ffi.Pointer<nk_buffer>,
          ffi.Pointer<nk_buffer>,
          ffi.Pointer<nk_buffer>,
          int,
          int)>();

  ffi.Pointer<nk_draw_command> nk__draw_list_begin(
    ffi.Pointer<nk_draw_list> arg0,
    ffi.Pointer<nk_buffer> arg1,
  ) {
    return _nk__draw_list_begin(
      arg0,
      arg1,
    );
  }

  late final _nk__draw_list_beginPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<nk_draw_command> Function(ffi.Pointer<nk_draw_list>,
              ffi.Pointer<nk_buffer>)>>('nk__draw_list_begin');
  late final _nk__draw_list_begin = _nk__draw_list_beginPtr.asFunction<
      ffi.Pointer<nk_draw_command> Function(
          ffi.Pointer<nk_draw_list>, ffi.Pointer<nk_buffer>)>();

  ffi.Pointer<nk_draw_command> nk__draw_list_next(
    ffi.Pointer<nk_draw_command> arg0,
    ffi.Pointer<nk_buffer> arg1,
    ffi.Pointer<nk_draw_list> arg2,
  ) {
    return _nk__draw_list_next(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _nk__draw_list_nextPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<nk_draw_command> Function(
              ffi.Pointer<nk_draw_command>,
              ffi.Pointer<nk_buffer>,
              ffi.Pointer<nk_draw_list>)>>('nk__draw_list_next');
  late final _nk__draw_list_next = _nk__draw_list_nextPtr.asFunction<
      ffi.Pointer<nk_draw_command> Function(ffi.Pointer<nk_draw_command>,
          ffi.Pointer<nk_buffer>, ffi.Pointer<nk_draw_list>)>();

  ffi.Pointer<nk_draw_command> nk__draw_list_end(
    ffi.Pointer<nk_draw_list> arg0,
    ffi.Pointer<nk_buffer> arg1,
  ) {
    return _nk__draw_list_end(
      arg0,
      arg1,
    );
  }

  late final _nk__draw_list_endPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<nk_draw_command> Function(ffi.Pointer<nk_draw_list>,
              ffi.Pointer<nk_buffer>)>>('nk__draw_list_end');
  late final _nk__draw_list_end = _nk__draw_list_endPtr.asFunction<
      ffi.Pointer<nk_draw_command> Function(
          ffi.Pointer<nk_draw_list>, ffi.Pointer<nk_buffer>)>();

  void nk_draw_list_path_clear(
    ffi.Pointer<nk_draw_list> arg0,
  ) {
    return _nk_draw_list_path_clear(
      arg0,
    );
  }

  late final _nk_draw_list_path_clearPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<nk_draw_list>)>>(
          'nk_draw_list_path_clear');
  late final _nk_draw_list_path_clear = _nk_draw_list_path_clearPtr
      .asFunction<void Function(ffi.Pointer<nk_draw_list>)>();

  void nk_draw_list_path_line_to(
    ffi.Pointer<nk_draw_list> arg0,
    nk_vec2 pos,
  ) {
    return _nk_draw_list_path_line_to(
      arg0,
      pos,
    );
  }

  late final _nk_draw_list_path_line_toPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_draw_list>,
              nk_vec2)>>('nk_draw_list_path_line_to');
  late final _nk_draw_list_path_line_to = _nk_draw_list_path_line_toPtr
      .asFunction<void Function(ffi.Pointer<nk_draw_list>, nk_vec2)>();

  void nk_draw_list_path_arc_to_fast(
    ffi.Pointer<nk_draw_list> arg0,
    nk_vec2 center,
    double radius,
    int a_min,
    int a_max,
  ) {
    return _nk_draw_list_path_arc_to_fast(
      arg0,
      center,
      radius,
      a_min,
      a_max,
    );
  }

  late final _nk_draw_list_path_arc_to_fastPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_draw_list>, nk_vec2, ffi.Float,
              ffi.Int, ffi.Int)>>('nk_draw_list_path_arc_to_fast');
  late final _nk_draw_list_path_arc_to_fast =
      _nk_draw_list_path_arc_to_fastPtr.asFunction<
          void Function(
              ffi.Pointer<nk_draw_list>, nk_vec2, double, int, int)>();

  void nk_draw_list_path_arc_to(
    ffi.Pointer<nk_draw_list> arg0,
    nk_vec2 center,
    double radius,
    double a_min,
    double a_max,
    int segments,
  ) {
    return _nk_draw_list_path_arc_to(
      arg0,
      center,
      radius,
      a_min,
      a_max,
      segments,
    );
  }

  late final _nk_draw_list_path_arc_toPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<nk_draw_list>,
              nk_vec2,
              ffi.Float,
              ffi.Float,
              ffi.Float,
              ffi.UnsignedInt)>>('nk_draw_list_path_arc_to');
  late final _nk_draw_list_path_arc_to =
      _nk_draw_list_path_arc_toPtr.asFunction<
          void Function(ffi.Pointer<nk_draw_list>, nk_vec2, double, double,
              double, int)>();

  void nk_draw_list_path_rect_to(
    ffi.Pointer<nk_draw_list> arg0,
    nk_vec2 a,
    nk_vec2 b,
    double rounding,
  ) {
    return _nk_draw_list_path_rect_to(
      arg0,
      a,
      b,
      rounding,
    );
  }

  late final _nk_draw_list_path_rect_toPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_draw_list>, nk_vec2, nk_vec2,
              ffi.Float)>>('nk_draw_list_path_rect_to');
  late final _nk_draw_list_path_rect_to =
      _nk_draw_list_path_rect_toPtr.asFunction<
          void Function(ffi.Pointer<nk_draw_list>, nk_vec2, nk_vec2, double)>();

  void nk_draw_list_path_curve_to(
    ffi.Pointer<nk_draw_list> arg0,
    nk_vec2 p2,
    nk_vec2 p3,
    nk_vec2 p4,
    int num_segments,
  ) {
    return _nk_draw_list_path_curve_to(
      arg0,
      p2,
      p3,
      p4,
      num_segments,
    );
  }

  late final _nk_draw_list_path_curve_toPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_draw_list>, nk_vec2, nk_vec2,
              nk_vec2, ffi.UnsignedInt)>>('nk_draw_list_path_curve_to');
  late final _nk_draw_list_path_curve_to =
      _nk_draw_list_path_curve_toPtr.asFunction<
          void Function(
              ffi.Pointer<nk_draw_list>, nk_vec2, nk_vec2, nk_vec2, int)>();

  void nk_draw_list_path_fill(
    ffi.Pointer<nk_draw_list> arg0,
    nk_color arg1,
  ) {
    return _nk_draw_list_path_fill(
      arg0,
      arg1,
    );
  }

  late final _nk_draw_list_path_fillPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<nk_draw_list>, nk_color)>>('nk_draw_list_path_fill');
  late final _nk_draw_list_path_fill = _nk_draw_list_path_fillPtr
      .asFunction<void Function(ffi.Pointer<nk_draw_list>, nk_color)>();

  void nk_draw_list_path_stroke(
    ffi.Pointer<nk_draw_list> arg0,
    nk_color arg1,
    int closed,
    double thickness,
  ) {
    return _nk_draw_list_path_stroke(
      arg0,
      arg1,
      closed,
      thickness,
    );
  }

  late final _nk_draw_list_path_strokePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_draw_list>, nk_color, ffi.Int32,
              ffi.Float)>>('nk_draw_list_path_stroke');
  late final _nk_draw_list_path_stroke =
      _nk_draw_list_path_strokePtr.asFunction<
          void Function(ffi.Pointer<nk_draw_list>, nk_color, int, double)>();

  void nk_draw_list_stroke_line(
    ffi.Pointer<nk_draw_list> arg0,
    nk_vec2 a,
    nk_vec2 b,
    nk_color arg3,
    double thickness,
  ) {
    return _nk_draw_list_stroke_line(
      arg0,
      a,
      b,
      arg3,
      thickness,
    );
  }

  late final _nk_draw_list_stroke_linePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_draw_list>, nk_vec2, nk_vec2,
              nk_color, ffi.Float)>>('nk_draw_list_stroke_line');
  late final _nk_draw_list_stroke_line =
      _nk_draw_list_stroke_linePtr.asFunction<
          void Function(
              ffi.Pointer<nk_draw_list>, nk_vec2, nk_vec2, nk_color, double)>();

  void nk_draw_list_stroke_rect(
    ffi.Pointer<nk_draw_list> arg0,
    nk_rect rect,
    nk_color arg2,
    double rounding,
    double thickness,
  ) {
    return _nk_draw_list_stroke_rect(
      arg0,
      rect,
      arg2,
      rounding,
      thickness,
    );
  }

  late final _nk_draw_list_stroke_rectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_draw_list>, nk_rect, nk_color,
              ffi.Float, ffi.Float)>>('nk_draw_list_stroke_rect');
  late final _nk_draw_list_stroke_rect =
      _nk_draw_list_stroke_rectPtr.asFunction<
          void Function(
              ffi.Pointer<nk_draw_list>, nk_rect, nk_color, double, double)>();

  void nk_draw_list_stroke_triangle(
    ffi.Pointer<nk_draw_list> arg0,
    nk_vec2 a,
    nk_vec2 b,
    nk_vec2 c,
    nk_color arg4,
    double thickness,
  ) {
    return _nk_draw_list_stroke_triangle(
      arg0,
      a,
      b,
      c,
      arg4,
      thickness,
    );
  }

  late final _nk_draw_list_stroke_trianglePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_draw_list>, nk_vec2, nk_vec2,
              nk_vec2, nk_color, ffi.Float)>>('nk_draw_list_stroke_triangle');
  late final _nk_draw_list_stroke_triangle =
      _nk_draw_list_stroke_trianglePtr.asFunction<
          void Function(ffi.Pointer<nk_draw_list>, nk_vec2, nk_vec2, nk_vec2,
              nk_color, double)>();

  void nk_draw_list_stroke_circle(
    ffi.Pointer<nk_draw_list> arg0,
    nk_vec2 center,
    double radius,
    nk_color arg3,
    int segs,
    double thickness,
  ) {
    return _nk_draw_list_stroke_circle(
      arg0,
      center,
      radius,
      arg3,
      segs,
      thickness,
    );
  }

  late final _nk_draw_list_stroke_circlePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<nk_draw_list>,
              nk_vec2,
              ffi.Float,
              nk_color,
              ffi.UnsignedInt,
              ffi.Float)>>('nk_draw_list_stroke_circle');
  late final _nk_draw_list_stroke_circle =
      _nk_draw_list_stroke_circlePtr.asFunction<
          void Function(ffi.Pointer<nk_draw_list>, nk_vec2, double, nk_color,
              int, double)>();

  void nk_draw_list_stroke_curve(
    ffi.Pointer<nk_draw_list> arg0,
    nk_vec2 p0,
    nk_vec2 cp0,
    nk_vec2 cp1,
    nk_vec2 p1,
    nk_color arg5,
    int segments,
    double thickness,
  ) {
    return _nk_draw_list_stroke_curve(
      arg0,
      p0,
      cp0,
      cp1,
      p1,
      arg5,
      segments,
      thickness,
    );
  }

  late final _nk_draw_list_stroke_curvePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<nk_draw_list>,
              nk_vec2,
              nk_vec2,
              nk_vec2,
              nk_vec2,
              nk_color,
              ffi.UnsignedInt,
              ffi.Float)>>('nk_draw_list_stroke_curve');
  late final _nk_draw_list_stroke_curve =
      _nk_draw_list_stroke_curvePtr.asFunction<
          void Function(ffi.Pointer<nk_draw_list>, nk_vec2, nk_vec2, nk_vec2,
              nk_vec2, nk_color, int, double)>();

  void nk_draw_list_stroke_poly_line(
    ffi.Pointer<nk_draw_list> arg0,
    ffi.Pointer<nk_vec2> pnts,
    int cnt,
    nk_color arg3,
    int arg4,
    double thickness,
    int arg6,
  ) {
    return _nk_draw_list_stroke_poly_line(
      arg0,
      pnts,
      cnt,
      arg3,
      arg4,
      thickness,
      arg6,
    );
  }

  late final _nk_draw_list_stroke_poly_linePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<nk_draw_list>,
              ffi.Pointer<nk_vec2>,
              ffi.UnsignedInt,
              nk_color,
              ffi.Int32,
              ffi.Float,
              ffi.Int32)>>('nk_draw_list_stroke_poly_line');
  late final _nk_draw_list_stroke_poly_line =
      _nk_draw_list_stroke_poly_linePtr.asFunction<
          void Function(ffi.Pointer<nk_draw_list>, ffi.Pointer<nk_vec2>, int,
              nk_color, int, double, int)>();

  void nk_draw_list_fill_rect(
    ffi.Pointer<nk_draw_list> arg0,
    nk_rect rect,
    nk_color arg2,
    double rounding,
  ) {
    return _nk_draw_list_fill_rect(
      arg0,
      rect,
      arg2,
      rounding,
    );
  }

  late final _nk_draw_list_fill_rectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_draw_list>, nk_rect, nk_color,
              ffi.Float)>>('nk_draw_list_fill_rect');
  late final _nk_draw_list_fill_rect = _nk_draw_list_fill_rectPtr.asFunction<
      void Function(ffi.Pointer<nk_draw_list>, nk_rect, nk_color, double)>();

  void nk_draw_list_fill_rect_multi_color(
    ffi.Pointer<nk_draw_list> arg0,
    nk_rect rect,
    nk_color left,
    nk_color top,
    nk_color right,
    nk_color bottom,
  ) {
    return _nk_draw_list_fill_rect_multi_color(
      arg0,
      rect,
      left,
      top,
      right,
      bottom,
    );
  }

  late final _nk_draw_list_fill_rect_multi_colorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<nk_draw_list>,
              nk_rect,
              nk_color,
              nk_color,
              nk_color,
              nk_color)>>('nk_draw_list_fill_rect_multi_color');
  late final _nk_draw_list_fill_rect_multi_color =
      _nk_draw_list_fill_rect_multi_colorPtr.asFunction<
          void Function(ffi.Pointer<nk_draw_list>, nk_rect, nk_color, nk_color,
              nk_color, nk_color)>();

  void nk_draw_list_fill_triangle(
    ffi.Pointer<nk_draw_list> arg0,
    nk_vec2 a,
    nk_vec2 b,
    nk_vec2 c,
    nk_color arg4,
  ) {
    return _nk_draw_list_fill_triangle(
      arg0,
      a,
      b,
      c,
      arg4,
    );
  }

  late final _nk_draw_list_fill_trianglePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_draw_list>, nk_vec2, nk_vec2,
              nk_vec2, nk_color)>>('nk_draw_list_fill_triangle');
  late final _nk_draw_list_fill_triangle =
      _nk_draw_list_fill_trianglePtr.asFunction<
          void Function(ffi.Pointer<nk_draw_list>, nk_vec2, nk_vec2, nk_vec2,
              nk_color)>();

  void nk_draw_list_fill_circle(
    ffi.Pointer<nk_draw_list> arg0,
    nk_vec2 center,
    double radius,
    nk_color col,
    int segs,
  ) {
    return _nk_draw_list_fill_circle(
      arg0,
      center,
      radius,
      col,
      segs,
    );
  }

  late final _nk_draw_list_fill_circlePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_draw_list>, nk_vec2, ffi.Float,
              nk_color, ffi.UnsignedInt)>>('nk_draw_list_fill_circle');
  late final _nk_draw_list_fill_circle =
      _nk_draw_list_fill_circlePtr.asFunction<
          void Function(
              ffi.Pointer<nk_draw_list>, nk_vec2, double, nk_color, int)>();

  void nk_draw_list_fill_poly_convex(
    ffi.Pointer<nk_draw_list> arg0,
    ffi.Pointer<nk_vec2> points,
    int count,
    nk_color arg3,
    int arg4,
  ) {
    return _nk_draw_list_fill_poly_convex(
      arg0,
      points,
      count,
      arg3,
      arg4,
    );
  }

  late final _nk_draw_list_fill_poly_convexPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<nk_draw_list>,
              ffi.Pointer<nk_vec2>,
              ffi.UnsignedInt,
              nk_color,
              ffi.Int32)>>('nk_draw_list_fill_poly_convex');
  late final _nk_draw_list_fill_poly_convex =
      _nk_draw_list_fill_poly_convexPtr.asFunction<
          void Function(ffi.Pointer<nk_draw_list>, ffi.Pointer<nk_vec2>, int,
              nk_color, int)>();

  void nk_draw_list_add_image(
    ffi.Pointer<nk_draw_list> arg0,
    nk_image texture,
    nk_rect rect,
    nk_color arg3,
  ) {
    return _nk_draw_list_add_image(
      arg0,
      texture,
      rect,
      arg3,
    );
  }

  late final _nk_draw_list_add_imagePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<nk_draw_list>, nk_image, nk_rect,
              nk_color)>>('nk_draw_list_add_image');
  late final _nk_draw_list_add_image = _nk_draw_list_add_imagePtr.asFunction<
      void Function(ffi.Pointer<nk_draw_list>, nk_image, nk_rect, nk_color)>();

  void nk_draw_list_add_text(
    ffi.Pointer<nk_draw_list> arg0,
    ffi.Pointer<nk_user_font> arg1,
    nk_rect arg2,
    ffi.Pointer<ffi.Char> text,
    int len,
    double font_height,
    nk_color arg6,
  ) {
    return _nk_draw_list_add_text(
      arg0,
      arg1,
      arg2,
      text,
      len,
      font_height,
      arg6,
    );
  }

  late final _nk_draw_list_add_textPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<nk_draw_list>,
              ffi.Pointer<nk_user_font>,
              nk_rect,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              ffi.Float,
              nk_color)>>('nk_draw_list_add_text');
  late final _nk_draw_list_add_text = _nk_draw_list_add_textPtr.asFunction<
      void Function(ffi.Pointer<nk_draw_list>, ffi.Pointer<nk_user_font>,
          nk_rect, ffi.Pointer<ffi.Char>, int, double, nk_color)>();

  nk_style_item nk_style_item_color(
    nk_color arg0,
  ) {
    return _nk_style_item_color(
      arg0,
    );
  }

  late final _nk_style_item_colorPtr =
      _lookup<ffi.NativeFunction<nk_style_item Function(nk_color)>>(
          'nk_style_item_color');
  late final _nk_style_item_color =
      _nk_style_item_colorPtr.asFunction<nk_style_item Function(nk_color)>();

  nk_style_item nk_style_item_image(
    nk_image img,
  ) {
    return _nk_style_item_image(
      img,
    );
  }

  late final _nk_style_item_imagePtr =
      _lookup<ffi.NativeFunction<nk_style_item Function(nk_image)>>(
          'nk_style_item_image');
  late final _nk_style_item_image =
      _nk_style_item_imagePtr.asFunction<nk_style_item Function(nk_image)>();

  nk_style_item nk_style_item_nine_slice(
    nk_nine_slice slice,
  ) {
    return _nk_style_item_nine_slice(
      slice,
    );
  }

  late final _nk_style_item_nine_slicePtr =
      _lookup<ffi.NativeFunction<nk_style_item Function(nk_nine_slice)>>(
          'nk_style_item_nine_slice');
  late final _nk_style_item_nine_slice = _nk_style_item_nine_slicePtr
      .asFunction<nk_style_item Function(nk_nine_slice)>();

  nk_style_item nk_style_item_hide() {
    return _nk_style_item_hide();
  }

  late final _nk_style_item_hidePtr =
      _lookup<ffi.NativeFunction<nk_style_item Function()>>(
          'nk_style_item_hide');
  late final _nk_style_item_hide =
      _nk_style_item_hidePtr.asFunction<nk_style_item Function()>();

  ffi.Pointer<ffi.Char> nk_cmd_text_ptr(
    ffi.Pointer<nk_command_text> t,
  ) {
    return _nk_cmd_text_ptr(
      t,
    );
  }

  late final _nk_cmd_text_ptrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<nk_command_text>)>>('nk_cmd_text_ptr');
  late final _nk_cmd_text_ptr = _nk_cmd_text_ptrPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<nk_command_text>)>();

  int nk_cmd_text_off_string() {
    return _nk_cmd_text_off_string();
  }

  late final _nk_cmd_text_off_stringPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedLong Function()>>(
          'nk_cmd_text_off_string');
  late final _nk_cmd_text_off_string =
      _nk_cmd_text_off_stringPtr.asFunction<int Function()>();
}

final class nk_buffer extends ffi.Struct {
  @ffi.Array.multi([2])
  external ffi.Array<nk_buffer_marker> marker;

  /// !< buffer marker to free a buffer to a certain offset
  external nk_allocator pool;

  /// !< allocator callback for dynamic buffers
  @ffi.Int32()
  external int type;

  /// !< memory management type
  external nk_memory memory;

  /// !< memory and size of the current memory block
  @ffi.Float()
  external double grow_factor;

  /// !< growing factor for dynamic memory management
  @nk_size()
  external int allocated;

  /// !< total amount of memory allocated
  @nk_size()
  external int needed;

  /// !< totally consumed memory given that enough memory is present
  @nk_size()
  external int calls;

  /// !< number of allocation calls
  @nk_size()
  external int size;
}

final class nk_buffer_marker extends ffi.Struct {
  @nk_bool()
  external int active;

  @nk_size()
  external int offset;
}

typedef nk_bool = ffi.Int;
typedef Dartnk_bool = int;
typedef nk_size = ffi.UintPtr;
typedef Dartnk_size = int;

final class nk_allocator extends ffi.Struct {
  external nk_handle userdata;

  external nk_plugin_alloc alloc;

  external nk_plugin_free free;
}

final class nk_handle extends ffi.Union {
  external ffi.Pointer<ffi.Void> ptr;

  @ffi.Int()
  external int id;
}

typedef nk_plugin_alloc
    = ffi.Pointer<ffi.NativeFunction<nk_plugin_allocFunction>>;
typedef nk_plugin_allocFunction = ffi.Pointer<ffi.Void> Function(
    nk_handle, ffi.Pointer<ffi.Void>, nk_size);
typedef Dartnk_plugin_allocFunction = ffi.Pointer<ffi.Void> Function(
    nk_handle, ffi.Pointer<ffi.Void>, Dartnk_size);
typedef nk_plugin_free
    = ffi.Pointer<ffi.NativeFunction<nk_plugin_freeFunction>>;
typedef nk_plugin_freeFunction = ffi.Void Function(
    nk_handle, ffi.Pointer<ffi.Void>);
typedef Dartnk_plugin_freeFunction = void Function(
    nk_handle, ffi.Pointer<ffi.Void>);

abstract class nk_allocation_type {
  static const int NK_BUFFER_FIXED = 0;
  static const int NK_BUFFER_DYNAMIC = 1;
}

final class nk_memory extends ffi.Struct {
  external ffi.Pointer<ffi.Void> ptr;

  @nk_size()
  external int size;
}

final class nk_command_buffer extends ffi.Struct {
  external ffi.Pointer<nk_buffer> base;

  external nk_rect clip;

  @ffi.Int()
  external int use_clipping;

  external nk_handle userdata;

  @nk_size()
  external int begin;

  @nk_size()
  external int end;

  @nk_size()
  external int last;
}

final class nk_rect extends ffi.Struct {
  @ffi.Float()
  external double x;

  @ffi.Float()
  external double y;

  @ffi.Float()
  external double w;

  @ffi.Float()
  external double h;
}

final class nk_draw_command extends ffi.Struct {
  /// < number of elements in the current draw batch
  @ffi.UnsignedInt()
  external int elem_count;

  /// < current screen clipping rectangle
  external nk_rect clip_rect;

  /// < current texture to set
  external nk_handle texture;
}

final class nk_convert_config extends ffi.Struct {
  @ffi.Float()
  external double global_alpha;

  /// !< global alpha value
  @ffi.Int32()
  external int line_AA;

  /// !< line anti-aliasing flag can be turned off if you are tight on memory
  @ffi.Int32()
  external int shape_AA;

  /// !< shape anti-aliasing flag can be turned off if you are tight on memory
  @ffi.UnsignedInt()
  external int circle_segment_count;

  /// !< number of segments used for circles: default to 22
  @ffi.UnsignedInt()
  external int arc_segment_count;

  /// !< number of segments used for arcs: default to 22
  @ffi.UnsignedInt()
  external int curve_segment_count;

  /// !< number of segments used for curves: default to 22
  external nk_draw_null_texture tex_null;

  /// !< handle to texture with a white pixel for shape drawing
  external ffi.Pointer<nk_draw_vertex_layout_element> vertex_layout;

  /// !< describes the vertex output format and packing
  @nk_size()
  external int vertex_size;

  /// !< sizeof one vertex for vertex packing
  @nk_size()
  external int vertex_alignment;
}

/// =============================================================================
///
/// DRAWING
///
/// =============================================================================*/
/// /**
/// \page Drawing
/// This library was designed to be render backend agnostic so it does
/// not draw anything to screen directly. Instead all drawn shapes, widgets
/// are made of, are buffered into memory and make up a command queue.
/// Each frame therefore fills the command buffer with draw commands
/// that then need to be executed by the user and his own render backend.
/// After that the command buffer needs to be cleared and a new frame can be
/// started. It is probably important to note that the command buffer is the main
/// drawing API and the optional vertex buffer API only takes this format and
/// converts it into a hardware accessible format.
///
/// # Usage
/// To draw all draw commands accumulated over a frame you need your own render
/// backend able to draw a number of 2D primitives. This includes at least
/// filled and stroked rectangles, circles, text, lines, triangles and scissors.
/// As soon as this criterion is met you can iterate over each draw command
/// and execute each draw command in a interpreter like fashion:
///
/// ```c
/// const struct nk_command *cmd = 0;
/// nk_foreach(cmd, &ctx) {
/// switch (cmd->type) {
/// case NK_COMMAND_LINE:
/// your_draw_line_function(...)
/// break;
/// case NK_COMMAND_RECT
/// your_draw_rect_function(...)
/// break;
/// case //...:
/// //[...]
/// }
/// }
/// ```
///
/// In program flow context draw commands need to be executed after input has been
/// gathered and the complete UI with windows and their contained widgets have
/// been executed and before calling `nk_clear` which frees all previously
/// allocated draw commands.
///
/// ```c
/// struct nk_context ctx;
/// nk_init_xxx(&ctx, ...);
/// while (1) {
/// Event evt;
/// nk_input_begin(&ctx);
/// while (GetEvent(&evt)) {
/// if (evt.type == MOUSE_MOVE)
/// nk_input_motion(&ctx, evt.motion.x, evt.motion.y);
/// else if (evt.type == [...]) {
/// [...]
/// }
/// }
/// nk_input_end(&ctx);
/// //
/// // [...]
/// //
/// const struct nk_command *cmd = 0;
/// nk_foreach(cmd, &ctx) {
/// switch (cmd->type) {
/// case NK_COMMAND_LINE:
/// your_draw_line_function(...)
/// break;
/// case NK_COMMAND_RECT
/// your_draw_rect_function(...)
/// break;
/// case ...:
/// // [...]
/// }
/// nk_clear(&ctx);
/// }
/// nk_free(&ctx);
/// ```
///
/// You probably noticed that you have to draw all of the UI each frame which is
/// quite wasteful. While the actual UI updating loop is quite fast rendering
/// without actually needing it is not. So there are multiple things you could do.
///
/// First is only update on input. This of course is only an option if your
/// application only depends on the UI and does not require any outside calculations.
/// If you actually only update on input make sure to update the UI two times each
/// frame and call `nk_clear` directly after the first pass and only draw in
/// the second pass. In addition it is recommended to also add additional timers
/// to make sure the UI is not drawn more than a fixed number of frames per second.
///
/// ```c
/// struct nk_context ctx;
/// nk_init_xxx(&ctx, ...);
/// while (1) {
/// // [...wait for input ]
/// // [...do two UI passes ...]
/// do_ui(...)
/// nk_clear(&ctx);
/// do_ui(...)
/// //
/// // draw
/// const struct nk_command *cmd = 0;
/// nk_foreach(cmd, &ctx) {
/// switch (cmd->type) {
/// case NK_COMMAND_LINE:
/// your_draw_line_function(...)
/// break;
/// case NK_COMMAND_RECT
/// your_draw_rect_function(...)
/// break;
/// case ...:
/// //[...]
/// }
/// nk_clear(&ctx);
/// }
/// nk_free(&ctx);
/// ```
///
/// The second probably more applicable trick is to only draw if anything changed.
/// It is not really useful for applications with continuous draw loop but
/// quite useful for desktop applications. To actually get nuklear to only
/// draw on changes you first have to define `NK_ZERO_COMMAND_MEMORY` and
/// allocate a memory buffer that will store each unique drawing output.
/// After each frame you compare the draw command memory inside the library
/// with your allocated buffer by memcmp. If memcmp detects differences
/// you have to copy the command buffer into the allocated buffer
/// and then draw like usual (this example uses fixed memory but you could
/// use dynamically allocated memory).
///
/// ```c
/// //[... other defines ...]
/// #define NK_ZERO_COMMAND_MEMORY
/// #include "nuklear.h"
/// //
/// // setup context
/// struct nk_context ctx;
/// void *last = calloc(1,64*1024);
/// void *buf = calloc(1,64*1024);
/// nk_init_fixed(&ctx, buf, 64*1024);
/// //
/// // loop
/// while (1) {
/// // [...input...]
/// // [...ui...]
/// void *cmds = nk_buffer_memory(&ctx.memory);
/// if (memcmp(cmds, last, ctx.memory.allocated)) {
/// memcpy(last,cmds,ctx.memory.allocated);
/// const struct nk_command *cmd = 0;
/// nk_foreach(cmd, &ctx) {
/// switch (cmd->type) {
/// case NK_COMMAND_LINE:
/// your_draw_line_function(...)
/// break;
/// case NK_COMMAND_RECT
/// your_draw_rect_function(...)
/// break;
/// case ...:
/// // [...]
/// }
/// }
/// }
/// nk_clear(&ctx);
/// }
/// nk_free(&ctx);
/// ```
///
/// Finally while using draw commands makes sense for higher abstracted platforms like
/// X11 and Win32 or drawing libraries it is often desirable to use graphics
/// hardware directly. Therefore it is possible to just define
/// `NK_INCLUDE_VERTEX_BUFFER_OUTPUT` which includes optional vertex output.
/// To access the vertex output you first have to convert all draw commands into
/// vertexes by calling `nk_convert` which takes in your preferred vertex format.
/// After successfully converting all draw commands just iterate over and execute all
/// vertex draw commands:
///
/// ```c
/// // fill configuration
/// struct your_vertex
/// {
/// float pos[2]; // important to keep it to 2 floats
/// float uv[2];
/// unsigned char col[4];
/// };
/// struct nk_convert_config cfg = {};
/// static const struct nk_draw_vertex_layout_element vertex_layout[] = {
/// {NK_VERTEX_POSITION, NK_FORMAT_FLOAT, NK_OFFSETOF(struct your_vertex, pos)},
/// {NK_VERTEX_TEXCOORD, NK_FORMAT_FLOAT, NK_OFFSETOF(struct your_vertex, uv)},
/// {NK_VERTEX_COLOR, NK_FORMAT_R8G8B8A8, NK_OFFSETOF(struct your_vertex, col)},
/// {NK_VERTEX_LAYOUT_END}
/// };
/// cfg.shape_AA = NK_ANTI_ALIASING_ON;
/// cfg.line_AA = NK_ANTI_ALIASING_ON;
/// cfg.vertex_layout = vertex_layout;
/// cfg.vertex_size = sizeof(struct your_vertex);
/// cfg.vertex_alignment = NK_ALIGNOF(struct your_vertex);
/// cfg.circle_segment_count = 22;
/// cfg.curve_segment_count = 22;
/// cfg.arc_segment_count = 22;
/// cfg.global_alpha = 1.0f;
/// cfg.tex_null = dev->tex_null;
/// //
/// // setup buffers and convert
/// struct nk_buffer cmds, verts, idx;
/// nk_buffer_init_default(&cmds);
/// nk_buffer_init_default(&verts);
/// nk_buffer_init_default(&idx);
/// nk_convert(&ctx, &cmds, &verts, &idx, &cfg);
/// //
/// // draw
/// nk_draw_foreach(cmd, &ctx, &cmds) {
/// if (!cmd->elem_count) continue;
/// //[...]
/// }
/// nk_buffer_free(&cms);
/// nk_buffer_free(&verts);
/// nk_buffer_free(&idx);
/// ```
///
/// # Reference
/// Function            | Description
/// --------------------|-------------------------------------------------------
/// \ref nk__begin       | Returns the first draw command in the context draw command list to be drawn
/// \ref nk__next        | Increments the draw command iterator to the next command inside the context draw command list
/// \ref nk_foreach      | Iterates over each draw command inside the context draw command list
/// \ref nk_convert      | Converts from the abstract draw commands list into a hardware accessible vertex format
/// \ref nk_draw_begin   | Returns the first vertex command in the context vertex draw list to be executed
/// \ref nk__draw_next   | Increments the vertex command iterator to the next command inside the context vertex command list
/// \ref nk__draw_end    | Returns the end of the vertex draw list
/// \ref nk_draw_foreach | Iterates over each vertex draw command inside the vertex draw list
abstract class nk_anti_aliasing {
  static const int NK_ANTI_ALIASING_OFF = 0;
  static const int NK_ANTI_ALIASING_ON = 1;
}

final class nk_draw_null_texture extends ffi.Struct {
  external nk_handle texture;

  /// !< texture handle to a texture with a white pixel
  external nk_vec2 uv;
}

final class nk_vec2 extends ffi.Struct {
  @ffi.Float()
  external double x;

  @ffi.Float()
  external double y;
}

final class nk_draw_vertex_layout_element extends ffi.Struct {
  @ffi.Int32()
  external int attribute;

  @ffi.Int32()
  external int format;

  @nk_size()
  external int offset;
}

abstract class nk_draw_vertex_layout_attribute {
  static const int NK_VERTEX_POSITION = 0;
  static const int NK_VERTEX_COLOR = 1;
  static const int NK_VERTEX_TEXCOORD = 2;
  static const int NK_VERTEX_ATTRIBUTE_COUNT = 3;
}

abstract class nk_draw_vertex_layout_format {
  static const int NK_FORMAT_SCHAR = 0;
  static const int NK_FORMAT_SSHORT = 1;
  static const int NK_FORMAT_SINT = 2;
  static const int NK_FORMAT_UCHAR = 3;
  static const int NK_FORMAT_USHORT = 4;
  static const int NK_FORMAT_UINT = 5;
  static const int NK_FORMAT_FLOAT = 6;
  static const int NK_FORMAT_DOUBLE = 7;
  static const int NK_FORMAT_COLOR_BEGIN = 8;
  static const int NK_FORMAT_R8G8B8 = 8;
  static const int NK_FORMAT_R16G15B16 = 9;
  static const int NK_FORMAT_R32G32B32 = 10;
  static const int NK_FORMAT_R8G8B8A8 = 11;
  static const int NK_FORMAT_B8G8R8A8 = 12;
  static const int NK_FORMAT_R16G15B16A16 = 13;
  static const int NK_FORMAT_R32G32B32A32 = 14;
  static const int NK_FORMAT_R32G32B32A32_FLOAT = 15;
  static const int NK_FORMAT_R32G32B32A32_DOUBLE = 16;
  static const int NK_FORMAT_RGB32 = 17;
  static const int NK_FORMAT_RGBA32 = 18;
  static const int NK_FORMAT_COLOR_END = 18;
  static const int NK_FORMAT_COUNT = 19;
}

final class nk_style_item extends ffi.Struct {
  @ffi.Int32()
  external int type;

  external nk_style_item_data data;
}

abstract class nk_style_item_type {
  static const int NK_STYLE_ITEM_COLOR = 0;
  static const int NK_STYLE_ITEM_IMAGE = 1;
  static const int NK_STYLE_ITEM_NINE_SLICE = 2;
}

final class nk_style_item_data extends ffi.Union {
  external nk_color color;

  external nk_image image;

  external nk_nine_slice slice;
}

final class nk_color extends ffi.Struct {
  @nk_byte()
  external int r;

  @nk_byte()
  external int g;

  @nk_byte()
  external int b;

  @nk_byte()
  external int a;
}

typedef nk_byte = ffi.Uint8;
typedef Dartnk_byte = int;

final class nk_image extends ffi.Struct {
  external nk_handle handle;

  @nk_ushort()
  external int w;

  @nk_ushort()
  external int h;

  @ffi.Array.multi([4])
  external ffi.Array<nk_ushort> region;
}

typedef nk_ushort = ffi.Uint16;
typedef Dartnk_ushort = int;

final class nk_nine_slice extends ffi.Struct {
  external nk_image img;

  @nk_ushort()
  external int l;

  @nk_ushort()
  external int t;

  @nk_ushort()
  external int r;

  @nk_ushort()
  external int b;
}

final class nk_text_edit extends ffi.Struct {
  external nk_clipboard clip;

  external nk_str string;

  external nk_plugin_filter filter;

  external nk_vec2 scrollbar;

  @ffi.Int()
  external int cursor;

  @ffi.Int()
  external int select_start;

  @ffi.Int()
  external int select_end;

  @ffi.UnsignedChar()
  external int mode;

  @ffi.UnsignedChar()
  external int cursor_at_end_of_line;

  @ffi.UnsignedChar()
  external int initialized;

  @ffi.UnsignedChar()
  external int has_preferred_x;

  @ffi.UnsignedChar()
  external int single_line;

  @ffi.UnsignedChar()
  external int active;

  @ffi.UnsignedChar()
  external int padding1;

  @ffi.Float()
  external double preferred_x;

  external nk_text_undo_state undo;
}

final class nk_clipboard extends ffi.Struct {
  external nk_handle userdata;

  external nk_plugin_paste paste;

  external nk_plugin_copy copy;
}

typedef nk_plugin_paste
    = ffi.Pointer<ffi.NativeFunction<nk_plugin_pasteFunction>>;
typedef nk_plugin_pasteFunction = ffi.Void Function(
    nk_handle, ffi.Pointer<nk_text_edit>);
typedef Dartnk_plugin_pasteFunction = void Function(
    nk_handle, ffi.Pointer<nk_text_edit>);
typedef nk_plugin_copy
    = ffi.Pointer<ffi.NativeFunction<nk_plugin_copyFunction>>;
typedef nk_plugin_copyFunction = ffi.Void Function(
    nk_handle, ffi.Pointer<ffi.Char>, ffi.Int);
typedef Dartnk_plugin_copyFunction = void Function(
    nk_handle, ffi.Pointer<ffi.Char>, int);

/// ==============================================================
///
/// STRING
///
/// ===============================================================*/
/// /**  Basic string buffer which is only used in context with the text editor
/// to manage and manipulate dynamic or fixed size string content. This is _NOT_
/// the default string handling method. The only instance you should have any contact
/// with this API is if you interact with an `nk_text_edit` object inside one of the
/// copy and paste functions and even there only for more advanced cases.
final class nk_str extends ffi.Struct {
  external nk_buffer buffer;

  @ffi.Int()
  external int len;
}

typedef nk_plugin_filter
    = ffi.Pointer<ffi.NativeFunction<nk_plugin_filterFunction>>;
typedef nk_plugin_filterFunction = nk_bool Function(
    ffi.Pointer<nk_text_edit>, nk_rune);
typedef Dartnk_plugin_filterFunction = Dartnk_bool Function(
    ffi.Pointer<nk_text_edit>, Dartnk_uint);
typedef nk_rune = nk_uint;
typedef nk_uint = ffi.Uint32;
typedef Dartnk_uint = int;

final class nk_text_undo_state extends ffi.Struct {
  @ffi.Array.multi([99])
  external ffi.Array<nk_text_undo_record> undo_rec;

  @ffi.Array.multi([999])
  external ffi.Array<nk_rune> undo_char;

  @ffi.Short()
  external int undo_point;

  @ffi.Short()
  external int redo_point;

  @ffi.Short()
  external int undo_char_point;

  @ffi.Short()
  external int redo_char_point;
}

final class nk_text_undo_record extends ffi.Struct {
  @ffi.Int()
  external int where;

  @ffi.Short()
  external int insert_length;

  @ffi.Short()
  external int delete_length;

  @ffi.Short()
  external int char_storage;
}

final class nk_draw_list extends ffi.Struct {
  external nk_rect clip_rect;

  @ffi.Array.multi([12])
  external ffi.Array<nk_vec2> circle_vtx;

  external nk_convert_config config;

  external ffi.Pointer<nk_buffer> buffer;

  external ffi.Pointer<nk_buffer> vertices;

  external ffi.Pointer<nk_buffer> elements;

  @ffi.UnsignedInt()
  external int element_count;

  @ffi.UnsignedInt()
  external int vertex_count;

  @ffi.UnsignedInt()
  external int cmd_count;

  @nk_size()
  external int cmd_offset;

  @ffi.UnsignedInt()
  external int path_count;

  @ffi.UnsignedInt()
  external int path_offset;

  @ffi.Int32()
  external int line_AA;

  @ffi.Int32()
  external int shape_AA;
}

final class nk_user_font extends ffi.Struct {
  external nk_handle userdata;

  /// !< user provided font handle
  @ffi.Float()
  external double height;

  /// !< max height of the font
  external nk_text_width_f width;

  external nk_query_font_glyph_f query;

  /// !< font glyph callback to query drawing info
  external nk_handle texture;
}

typedef nk_text_width_f
    = ffi.Pointer<ffi.NativeFunction<nk_text_width_fFunction>>;
typedef nk_text_width_fFunction = ffi.Float Function(
    nk_handle, ffi.Float, ffi.Pointer<ffi.Char>, ffi.Int);
typedef Dartnk_text_width_fFunction = double Function(
    nk_handle, double, ffi.Pointer<ffi.Char>, int);
typedef nk_query_font_glyph_f
    = ffi.Pointer<ffi.NativeFunction<nk_query_font_glyph_fFunction>>;
typedef nk_query_font_glyph_fFunction = ffi.Void Function(
    nk_handle handle,
    ffi.Float font_height,
    ffi.Pointer<nk_user_font_glyph> glyph,
    nk_rune codepoint,
    nk_rune next_codepoint);
typedef Dartnk_query_font_glyph_fFunction = void Function(
    nk_handle handle,
    double font_height,
    ffi.Pointer<nk_user_font_glyph> glyph,
    Dartnk_uint codepoint,
    Dartnk_uint next_codepoint);

/// \page Font
/// Font handling in this library was designed to be quite customizable and lets
/// you decide what you want to use and what you want to provide. There are three
/// different ways to use the font atlas. The first two will use your font
/// handling scheme and only requires essential data to run nuklear. The next
/// slightly more advanced features is font handling with vertex buffer output.
/// Finally the most complex API wise is using nuklear's font baking API.
///
/// # Using your own implementation without vertex buffer output
///
/// So first up the easiest way to do font handling is by just providing a
/// `nk_user_font` struct which only requires the height in pixel of the used
/// font and a callback to calculate the width of a string. This way of handling
/// fonts is best fitted for using the normal draw shape command API where you
/// do all the text drawing yourself and the library does not require any kind
/// of deeper knowledge about which font handling mechanism you use.
/// IMPORTANT: the `nk_user_font` pointer provided to nuklear has to persist
/// over the complete life time! I know this sucks but it is currently the only
/// way to switch between fonts.
///
/// ```c
/// float your_text_width_calculation(nk_handle handle, float height, const char *text, int len)
/// {
/// your_font_type *type = handle.ptr;
/// float text_width = ...;
/// return text_width;
/// }
///
/// struct nk_user_font font;
/// font.userdata.ptr = &your_font_class_or_struct;
/// font.height = your_font_height;
/// font.width = your_text_width_calculation;
///
/// struct nk_context ctx;
/// nk_init_default(&ctx, &font);
/// ```
/// # Using your own implementation with vertex buffer output
///
/// While the first approach works fine if you don't want to use the optional
/// vertex buffer output it is not enough if you do. To get font handling working
/// for these cases you have to provide two additional parameters inside the
/// `nk_user_font`. First a texture atlas handle used to draw text as subimages
/// of a bigger font atlas texture and a callback to query a character's glyph
/// information (offset, size, ...). So it is still possible to provide your own
/// font and use the vertex buffer output.
///
/// ```c
/// float your_text_width_calculation(nk_handle handle, float height, const char *text, int len)
/// {
/// your_font_type *type = handle.ptr;
/// float text_width = ...;
/// return text_width;
/// }
/// void query_your_font_glyph(nk_handle handle, float font_height, struct nk_user_font_glyph *glyph, nk_rune codepoint, nk_rune next_codepoint)
/// {
/// your_font_type *type = handle.ptr;
/// glyph.width = ...;
/// glyph.height = ...;
/// glyph.xadvance = ...;
/// glyph.uv[0].x = ...;
/// glyph.uv[0].y = ...;
/// glyph.uv[1].x = ...;
/// glyph.uv[1].y = ...;
/// glyph.offset.x = ...;
/// glyph.offset.y = ...;
/// }
///
/// struct nk_user_font font;
/// font.userdata.ptr = &your_font_class_or_struct;
/// font.height = your_font_height;
/// font.width = your_text_width_calculation;
/// font.query = query_your_font_glyph;
/// font.texture.id = your_font_texture;
///
/// struct nk_context ctx;
/// nk_init_default(&ctx, &font);
/// ```
///
/// # Nuklear font baker
///
/// The final approach if you do not have a font handling functionality or don't
/// want to use it in this library is by using the optional font baker.
/// The font baker APIs can be used to create a font plus font atlas texture
/// and can be used with or without the vertex buffer output.
///
/// It still uses the `nk_user_font` struct and the two different approaches
/// previously stated still work. The font baker is not located inside
/// `nk_context` like all other systems since it can be understood as more of
/// an extension to nuklear and does not really depend on any `nk_context` state.
///
/// Font baker need to be initialized first by one of the nk_font_atlas_init_xxx
/// functions. If you don't care about memory just call the default version
/// `nk_font_atlas_init_default` which will allocate all memory from the standard library.
/// If you want to control memory allocation but you don't care if the allocated
/// memory is temporary and therefore can be freed directly after the baking process
/// is over or permanent you can call `nk_font_atlas_init`.
///
/// After successfully initializing the font baker you can add Truetype(.ttf) fonts from
/// different sources like memory or from file by calling one of the `nk_font_atlas_add_xxx`.
/// functions. Adding font will permanently store each font, font config and ttf memory block(!)
/// inside the font atlas and allows to reuse the font atlas. If you don't want to reuse
/// the font baker by for example adding additional fonts you can call
/// `nk_font_atlas_cleanup` after the baking process is over (after calling nk_font_atlas_end).
///
/// As soon as you added all fonts you wanted you can now start the baking process
/// for every selected glyph to image by calling `nk_font_atlas_bake`.
/// The baking process returns image memory, width and height which can be used to
/// either create your own image object or upload it to any graphics library.
/// No matter which case you finally have to call `nk_font_atlas_end` which
/// will free all temporary memory including the font atlas image so make sure
/// you created our texture beforehand. `nk_font_atlas_end` requires a handle
/// to your font texture or object and optionally fills a `struct nk_draw_null_texture`
/// which can be used for the optional vertex output. If you don't want it just
/// set the argument to `NULL`.
///
/// At this point you are done and if you don't want to reuse the font atlas you
/// can call `nk_font_atlas_cleanup` to free all truetype blobs and configuration
/// memory. Finally if you don't use the font atlas and any of it's fonts anymore
/// you need to call `nk_font_atlas_clear` to free all memory still being used.
///
/// ```c
/// struct nk_font_atlas atlas;
/// nk_font_atlas_init_default(&atlas);
/// nk_font_atlas_begin(&atlas);
/// nk_font *font = nk_font_atlas_add_from_file(&atlas, "Path/To/Your/TTF_Font.ttf", 13, 0);
/// nk_font *font2 = nk_font_atlas_add_from_file(&atlas, "Path/To/Your/TTF_Font2.ttf", 16, 0);
/// const void* img = nk_font_atlas_bake(&atlas, &img_width, &img_height, NK_FONT_ATLAS_RGBA32);
/// nk_font_atlas_end(&atlas, nk_handle_id(texture), 0);
///
/// struct nk_context ctx;
/// nk_init_default(&ctx, &font->handle);
/// while (1) {
///
/// }
/// nk_font_atlas_clear(&atlas);
/// ```
/// The font baker API is probably the most complex API inside this library and
/// I would suggest reading some of my examples `example/` to get a grip on how
/// to use the font atlas. There are a number of details I left out. For example
/// how to merge fonts, configure a font with `nk_font_config` to use other languages,
/// use another texture coordinate format and a lot more:
///
/// ```c
/// struct nk_font_config cfg = nk_font_config(font_pixel_height);
/// cfg.merge_mode = nk_false or nk_true;
/// cfg.range = nk_font_korean_glyph_ranges();
/// cfg.coord_type = NK_COORD_PIXEL;
/// nk_font *font = nk_font_atlas_add_from_file(&atlas, "Path/To/Your/TTF_Font.ttf", 13, &cfg);
/// ```
final class nk_user_font_glyph extends ffi.Struct {
  @ffi.Array.multi([2])
  external ffi.Array<nk_vec2> uv;

  /// !< texture coordinates
  external nk_vec2 offset;

  /// !< offset between top left and glyph
  @ffi.Float()
  external double width;

  @ffi.Float()
  external double height;

  /// !< size of the glyph
  @ffi.Float()
  external double xadvance;
}

final class nk_panel extends ffi.Struct {
  @ffi.Int32()
  external int type;

  @nk_flags()
  external int flags;

  external nk_rect bounds;

  external ffi.Pointer<nk_uint> offset_x;

  external ffi.Pointer<nk_uint> offset_y;

  @ffi.Float()
  external double at_x;

  @ffi.Float()
  external double at_y;

  @ffi.Float()
  external double max_x;

  @ffi.Float()
  external double footer_height;

  @ffi.Float()
  external double header_height;

  @ffi.Float()
  external double border;

  @ffi.UnsignedInt()
  external int has_scrolling;

  external nk_rect clip;

  external nk_menu_state menu;

  external nk_row_layout row;

  external nk_chart chart;

  external ffi.Pointer<nk_command_buffer> buffer;

  external ffi.Pointer<nk_panel> parent;
}

abstract class nk_panel_type {
  static const int NK_PANEL_NONE = 0;
  static const int NK_PANEL_WINDOW = 1;
  static const int NK_PANEL_GROUP = 2;
  static const int NK_PANEL_POPUP = 4;
  static const int NK_PANEL_CONTEXTUAL = 16;
  static const int NK_PANEL_COMBO = 32;
  static const int NK_PANEL_MENU = 64;
  static const int NK_PANEL_TOOLTIP = 128;
}

typedef nk_flags = nk_uint;

final class nk_menu_state extends ffi.Struct {
  @ffi.Float()
  external double x;

  @ffi.Float()
  external double y;

  @ffi.Float()
  external double w;

  @ffi.Float()
  external double h;

  external nk_scroll offset;
}

final class nk_scroll extends ffi.Struct {
  @nk_uint()
  external int x;

  @nk_uint()
  external int y;
}

final class nk_row_layout extends ffi.Struct {
  @ffi.Int32()
  external int type;

  @ffi.Int()
  external int index;

  @ffi.Float()
  external double height;

  @ffi.Float()
  external double min_height;

  @ffi.Int()
  external int columns;

  external ffi.Pointer<ffi.Float> ratio;

  @ffi.Float()
  external double item_width;

  @ffi.Float()
  external double item_height;

  @ffi.Float()
  external double item_offset;

  @ffi.Float()
  external double filled;

  external nk_rect item;

  @ffi.Int()
  external int tree_depth;

  @ffi.Array.multi([16])
  external ffi.Array<ffi.Float> templates;
}

abstract class nk_panel_row_layout_type {
  static const int NK_LAYOUT_DYNAMIC_FIXED = 0;
  static const int NK_LAYOUT_DYNAMIC_ROW = 1;
  static const int NK_LAYOUT_DYNAMIC_FREE = 2;
  static const int NK_LAYOUT_DYNAMIC = 3;
  static const int NK_LAYOUT_STATIC_FIXED = 4;
  static const int NK_LAYOUT_STATIC_ROW = 5;
  static const int NK_LAYOUT_STATIC_FREE = 6;
  static const int NK_LAYOUT_STATIC = 7;
  static const int NK_LAYOUT_TEMPLATE = 8;
  static const int NK_LAYOUT_COUNT = 9;
}

final class nk_chart extends ffi.Struct {
  @ffi.Int()
  external int slot;

  @ffi.Float()
  external double x;

  @ffi.Float()
  external double y;

  @ffi.Float()
  external double w;

  @ffi.Float()
  external double h;

  @ffi.Array.multi([4])
  external ffi.Array<nk_chart_slot> slots;
}

final class nk_chart_slot extends ffi.Struct {
  @ffi.Int32()
  external int type;

  external nk_color color;

  external nk_color highlight;

  @ffi.Float()
  external double min;

  @ffi.Float()
  external double max;

  @ffi.Float()
  external double range;

  @ffi.Int()
  external int count;

  external nk_vec2 last;

  @ffi.Int()
  external int index;

  @nk_bool()
  external int show_markers;
}

abstract class nk_chart_type {
  static const int NK_CHART_LINES = 0;
  static const int NK_CHART_COLUMN = 1;
  static const int NK_CHART_MAX = 2;
}

final class nk_context extends ffi.Struct {
  external nk_input input;

  external nk_style style;

  external nk_buffer memory;

  external nk_clipboard clip;

  @nk_flags()
  external int last_widget_state;

  @ffi.Int32()
  external int button_behavior;

  external nk_configuration_stacks stacks;

  @ffi.Float()
  external double delta_time_seconds;

  external nk_draw_list draw_list;

  /// text editor objects are quite big because of an internal
  /// undo/redo stack. Therefore it does not make sense to have one for
  /// each window for temporary use cases, so I only provide *one* instance
  /// for all windows. This works because the content is cleared anyway
  external nk_text_edit text_edit;

  /// draw buffer used for overlay drawing operation like cursor
  external nk_command_buffer overlay;

  /// windows
  @ffi.Int()
  external int build;

  @ffi.Int()
  external int use_pool;

  external nk_pool pool;

  external ffi.Pointer<nk_window> begin;

  external ffi.Pointer<nk_window> end;

  external ffi.Pointer<nk_window> active;

  external ffi.Pointer<nk_window> current;

  external ffi.Pointer<nk_page_element> freelist;

  @ffi.UnsignedInt()
  external int count;

  @ffi.UnsignedInt()
  external int seq;
}

final class nk_input extends ffi.Struct {
  external nk_keyboard keyboard;

  external nk_mouse mouse;
}

final class nk_keyboard extends ffi.Struct {
  @ffi.Array.multi([30])
  external ffi.Array<nk_key> keys;

  @ffi.Array.multi([16])
  external ffi.Array<ffi.Char> text;

  @ffi.Int()
  external int text_len;
}

final class nk_key extends ffi.Struct {
  @nk_bool()
  external int down;

  @ffi.UnsignedInt()
  external int clicked;
}

final class nk_mouse extends ffi.Struct {
  @ffi.Array.multi([4])
  external ffi.Array<nk_mouse_button> buttons;

  external nk_vec2 pos;

  external nk_vec2 prev;

  external nk_vec2 delta;

  external nk_vec2 scroll_delta;

  @ffi.UnsignedChar()
  external int grab;

  @ffi.UnsignedChar()
  external int grabbed;

  @ffi.UnsignedChar()
  external int ungrab;
}

final class nk_mouse_button extends ffi.Struct {
  @nk_bool()
  external int down;

  @ffi.UnsignedInt()
  external int clicked;

  external nk_vec2 clicked_pos;
}

final class nk_style extends ffi.Struct {
  external ffi.Pointer<nk_user_font> font;

  @ffi.Array.multi([7])
  external ffi.Array<ffi.Pointer<nk_cursor>> cursors;

  external ffi.Pointer<nk_cursor> cursor_active;

  external ffi.Pointer<nk_cursor> cursor_last;

  @ffi.Int()
  external int cursor_visible;

  external nk_style_text text;

  external nk_style_button button;

  external nk_style_button contextual_button;

  external nk_style_button menu_button;

  external nk_style_toggle option;

  external nk_style_toggle checkbox;

  external nk_style_selectable selectable;

  external nk_style_slider slider;

  external nk_style_knob knob;

  external nk_style_progress progress;

  external nk_style_property property;

  external nk_style_edit edit;

  external nk_style_chart chart;

  external nk_style_scrollbar scrollh;

  external nk_style_scrollbar scrollv;

  external nk_style_tab tab;

  external nk_style_combo combo;

  external nk_style_window window;
}

final class nk_cursor extends ffi.Struct {
  external nk_image img;

  external nk_vec2 size;

  external nk_vec2 offset;
}

final class nk_style_text extends ffi.Struct {
  external nk_color color;

  external nk_vec2 padding;

  @ffi.Float()
  external double color_factor;

  @ffi.Float()
  external double disabled_factor;
}

final class nk_style_button extends ffi.Struct {
  external nk_style_item normal;

  external nk_style_item hover;

  external nk_style_item active;

  external nk_color border_color;

  @ffi.Float()
  external double color_factor_background;

  external nk_color text_background;

  external nk_color text_normal;

  external nk_color text_hover;

  external nk_color text_active;

  @nk_flags()
  external int text_alignment;

  @ffi.Float()
  external double color_factor_text;

  @ffi.Float()
  external double border;

  @ffi.Float()
  external double rounding;

  external nk_vec2 padding;

  external nk_vec2 image_padding;

  external nk_vec2 touch_padding;

  @ffi.Float()
  external double disabled_factor;

  external nk_handle userdata;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<nk_command_buffer>, nk_handle)>>
      draw_begin;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<nk_command_buffer>, nk_handle)>>
      draw_end;
}

final class nk_style_toggle extends ffi.Struct {
  external nk_style_item normal;

  external nk_style_item hover;

  external nk_style_item active;

  external nk_color border_color;

  external nk_style_item cursor_normal;

  external nk_style_item cursor_hover;

  external nk_color text_normal;

  external nk_color text_hover;

  external nk_color text_active;

  external nk_color text_background;

  @nk_flags()
  external int text_alignment;

  external nk_vec2 padding;

  external nk_vec2 touch_padding;

  @ffi.Float()
  external double spacing;

  @ffi.Float()
  external double border;

  @ffi.Float()
  external double color_factor;

  @ffi.Float()
  external double disabled_factor;

  external nk_handle userdata;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<nk_command_buffer>, nk_handle)>>
      draw_begin;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<nk_command_buffer>, nk_handle)>>
      draw_end;
}

final class nk_style_selectable extends ffi.Struct {
  external nk_style_item normal;

  external nk_style_item hover;

  external nk_style_item pressed;

  external nk_style_item normal_active;

  external nk_style_item hover_active;

  external nk_style_item pressed_active;

  external nk_color text_normal;

  external nk_color text_hover;

  external nk_color text_pressed;

  external nk_color text_normal_active;

  external nk_color text_hover_active;

  external nk_color text_pressed_active;

  external nk_color text_background;

  @nk_flags()
  external int text_alignment;

  @ffi.Float()
  external double rounding;

  external nk_vec2 padding;

  external nk_vec2 touch_padding;

  external nk_vec2 image_padding;

  @ffi.Float()
  external double color_factor;

  @ffi.Float()
  external double disabled_factor;

  external nk_handle userdata;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<nk_command_buffer>, nk_handle)>>
      draw_begin;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<nk_command_buffer>, nk_handle)>>
      draw_end;
}

final class nk_style_slider extends ffi.Struct {
  external nk_style_item normal;

  external nk_style_item hover;

  external nk_style_item active;

  external nk_color border_color;

  external nk_color bar_normal;

  external nk_color bar_hover;

  external nk_color bar_active;

  external nk_color bar_filled;

  external nk_style_item cursor_normal;

  external nk_style_item cursor_hover;

  external nk_style_item cursor_active;

  @ffi.Float()
  external double border;

  @ffi.Float()
  external double rounding;

  @ffi.Float()
  external double bar_height;

  external nk_vec2 padding;

  external nk_vec2 spacing;

  external nk_vec2 cursor_size;

  @ffi.Float()
  external double color_factor;

  @ffi.Float()
  external double disabled_factor;

  @ffi.Int()
  external int show_buttons;

  external nk_style_button inc_button;

  external nk_style_button dec_button;

  @ffi.Int32()
  external int inc_symbol;

  @ffi.Int32()
  external int dec_symbol;

  external nk_handle userdata;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<nk_command_buffer>, nk_handle)>>
      draw_begin;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<nk_command_buffer>, nk_handle)>>
      draw_end;
}

abstract class nk_symbol_type {
  static const int NK_SYMBOL_NONE = 0;
  static const int NK_SYMBOL_X = 1;
  static const int NK_SYMBOL_UNDERSCORE = 2;
  static const int NK_SYMBOL_CIRCLE_SOLID = 3;
  static const int NK_SYMBOL_CIRCLE_OUTLINE = 4;
  static const int NK_SYMBOL_RECT_SOLID = 5;
  static const int NK_SYMBOL_RECT_OUTLINE = 6;
  static const int NK_SYMBOL_TRIANGLE_UP = 7;
  static const int NK_SYMBOL_TRIANGLE_DOWN = 8;
  static const int NK_SYMBOL_TRIANGLE_LEFT = 9;
  static const int NK_SYMBOL_TRIANGLE_RIGHT = 10;
  static const int NK_SYMBOL_PLUS = 11;
  static const int NK_SYMBOL_MINUS = 12;
  static const int NK_SYMBOL_TRIANGLE_UP_OUTLINE = 13;
  static const int NK_SYMBOL_TRIANGLE_DOWN_OUTLINE = 14;
  static const int NK_SYMBOL_TRIANGLE_LEFT_OUTLINE = 15;
  static const int NK_SYMBOL_TRIANGLE_RIGHT_OUTLINE = 16;
  static const int NK_SYMBOL_MAX = 17;
}

final class nk_style_knob extends ffi.Struct {
  external nk_style_item normal;

  external nk_style_item hover;

  external nk_style_item active;

  external nk_color border_color;

  external nk_color knob_normal;

  external nk_color knob_hover;

  external nk_color knob_active;

  external nk_color knob_border_color;

  external nk_color cursor_normal;

  external nk_color cursor_hover;

  external nk_color cursor_active;

  @ffi.Float()
  external double border;

  @ffi.Float()
  external double knob_border;

  external nk_vec2 padding;

  external nk_vec2 spacing;

  @ffi.Float()
  external double cursor_width;

  @ffi.Float()
  external double color_factor;

  @ffi.Float()
  external double disabled_factor;

  external nk_handle userdata;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<nk_command_buffer>, nk_handle)>>
      draw_begin;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<nk_command_buffer>, nk_handle)>>
      draw_end;
}

final class nk_style_progress extends ffi.Struct {
  external nk_style_item normal;

  external nk_style_item hover;

  external nk_style_item active;

  external nk_color border_color;

  external nk_style_item cursor_normal;

  external nk_style_item cursor_hover;

  external nk_style_item cursor_active;

  external nk_color cursor_border_color;

  @ffi.Float()
  external double rounding;

  @ffi.Float()
  external double border;

  @ffi.Float()
  external double cursor_border;

  @ffi.Float()
  external double cursor_rounding;

  external nk_vec2 padding;

  @ffi.Float()
  external double color_factor;

  @ffi.Float()
  external double disabled_factor;

  external nk_handle userdata;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<nk_command_buffer>, nk_handle)>>
      draw_begin;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<nk_command_buffer>, nk_handle)>>
      draw_end;
}

final class nk_style_property extends ffi.Struct {
  external nk_style_item normal;

  external nk_style_item hover;

  external nk_style_item active;

  external nk_color border_color;

  external nk_color label_normal;

  external nk_color label_hover;

  external nk_color label_active;

  @ffi.Int32()
  external int sym_left;

  @ffi.Int32()
  external int sym_right;

  @ffi.Float()
  external double border;

  @ffi.Float()
  external double rounding;

  external nk_vec2 padding;

  @ffi.Float()
  external double color_factor;

  @ffi.Float()
  external double disabled_factor;

  external nk_style_edit edit;

  external nk_style_button inc_button;

  external nk_style_button dec_button;

  external nk_handle userdata;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<nk_command_buffer>, nk_handle)>>
      draw_begin;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<nk_command_buffer>, nk_handle)>>
      draw_end;
}

final class nk_style_edit extends ffi.Struct {
  external nk_style_item normal;

  external nk_style_item hover;

  external nk_style_item active;

  external nk_color border_color;

  external nk_style_scrollbar scrollbar;

  external nk_color cursor_normal;

  external nk_color cursor_hover;

  external nk_color cursor_text_normal;

  external nk_color cursor_text_hover;

  external nk_color text_normal;

  external nk_color text_hover;

  external nk_color text_active;

  external nk_color selected_normal;

  external nk_color selected_hover;

  external nk_color selected_text_normal;

  external nk_color selected_text_hover;

  @ffi.Float()
  external double border;

  @ffi.Float()
  external double rounding;

  @ffi.Float()
  external double cursor_size;

  external nk_vec2 scrollbar_size;

  external nk_vec2 padding;

  @ffi.Float()
  external double row_padding;

  @ffi.Float()
  external double color_factor;

  @ffi.Float()
  external double disabled_factor;
}

final class nk_style_scrollbar extends ffi.Struct {
  external nk_style_item normal;

  external nk_style_item hover;

  external nk_style_item active;

  external nk_color border_color;

  external nk_style_item cursor_normal;

  external nk_style_item cursor_hover;

  external nk_style_item cursor_active;

  external nk_color cursor_border_color;

  @ffi.Float()
  external double border;

  @ffi.Float()
  external double rounding;

  @ffi.Float()
  external double border_cursor;

  @ffi.Float()
  external double rounding_cursor;

  external nk_vec2 padding;

  @ffi.Float()
  external double color_factor;

  @ffi.Float()
  external double disabled_factor;

  @ffi.Int()
  external int show_buttons;

  external nk_style_button inc_button;

  external nk_style_button dec_button;

  @ffi.Int32()
  external int inc_symbol;

  @ffi.Int32()
  external int dec_symbol;

  external nk_handle userdata;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<nk_command_buffer>, nk_handle)>>
      draw_begin;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<nk_command_buffer>, nk_handle)>>
      draw_end;
}

final class nk_style_chart extends ffi.Struct {
  external nk_style_item background;

  external nk_color border_color;

  external nk_color selected_color;

  external nk_color color;

  @ffi.Float()
  external double border;

  @ffi.Float()
  external double rounding;

  external nk_vec2 padding;

  @ffi.Float()
  external double color_factor;

  @ffi.Float()
  external double disabled_factor;

  @nk_bool()
  external int show_markers;
}

final class nk_style_tab extends ffi.Struct {
  external nk_style_item background;

  external nk_color border_color;

  external nk_color text;

  external nk_style_button tab_maximize_button;

  external nk_style_button tab_minimize_button;

  external nk_style_button node_maximize_button;

  external nk_style_button node_minimize_button;

  @ffi.Int32()
  external int sym_minimize;

  @ffi.Int32()
  external int sym_maximize;

  @ffi.Float()
  external double border;

  @ffi.Float()
  external double rounding;

  @ffi.Float()
  external double indent;

  external nk_vec2 padding;

  external nk_vec2 spacing;

  @ffi.Float()
  external double color_factor;

  @ffi.Float()
  external double disabled_factor;
}

final class nk_style_combo extends ffi.Struct {
  external nk_style_item normal;

  external nk_style_item hover;

  external nk_style_item active;

  external nk_color border_color;

  external nk_color label_normal;

  external nk_color label_hover;

  external nk_color label_active;

  external nk_color symbol_normal;

  external nk_color symbol_hover;

  external nk_color symbol_active;

  external nk_style_button button;

  @ffi.Int32()
  external int sym_normal;

  @ffi.Int32()
  external int sym_hover;

  @ffi.Int32()
  external int sym_active;

  @ffi.Float()
  external double border;

  @ffi.Float()
  external double rounding;

  external nk_vec2 content_padding;

  external nk_vec2 button_padding;

  external nk_vec2 spacing;

  @ffi.Float()
  external double color_factor;

  @ffi.Float()
  external double disabled_factor;
}

final class nk_style_window extends ffi.Struct {
  external nk_style_window_header header;

  external nk_style_item fixed_background;

  external nk_color background;

  external nk_color border_color;

  external nk_color popup_border_color;

  external nk_color combo_border_color;

  external nk_color contextual_border_color;

  external nk_color menu_border_color;

  external nk_color group_border_color;

  external nk_color tooltip_border_color;

  external nk_style_item scaler;

  @ffi.Float()
  external double border;

  @ffi.Float()
  external double combo_border;

  @ffi.Float()
  external double contextual_border;

  @ffi.Float()
  external double menu_border;

  @ffi.Float()
  external double group_border;

  @ffi.Float()
  external double tooltip_border;

  @ffi.Float()
  external double popup_border;

  @ffi.Float()
  external double min_row_height_padding;

  @ffi.Float()
  external double rounding;

  external nk_vec2 spacing;

  external nk_vec2 scrollbar_size;

  external nk_vec2 min_size;

  external nk_vec2 padding;

  external nk_vec2 group_padding;

  external nk_vec2 popup_padding;

  external nk_vec2 combo_padding;

  external nk_vec2 contextual_padding;

  external nk_vec2 menu_padding;

  external nk_vec2 tooltip_padding;
}

final class nk_style_window_header extends ffi.Struct {
  external nk_style_item normal;

  external nk_style_item hover;

  external nk_style_item active;

  external nk_style_button close_button;

  external nk_style_button minimize_button;

  @ffi.Int32()
  external int close_symbol;

  @ffi.Int32()
  external int minimize_symbol;

  @ffi.Int32()
  external int maximize_symbol;

  external nk_color label_normal;

  external nk_color label_hover;

  external nk_color label_active;

  @ffi.Int32()
  external int align;

  external nk_vec2 padding;

  external nk_vec2 label_padding;

  external nk_vec2 spacing;
}

abstract class nk_style_header_align {
  static const int NK_HEADER_LEFT = 0;
  static const int NK_HEADER_RIGHT = 1;
}

abstract class nk_button_behavior {
  static const int NK_BUTTON_DEFAULT = 0;
  static const int NK_BUTTON_REPEATER = 1;
}

final class nk_configuration_stacks extends ffi.Struct {
  external nk_config_stack_style_item style_items;

  external nk_config_stack_float floats;

  external nk_config_stack_vec2 vectors;

  external nk_config_stack_flags flags;

  external nk_config_stack_color colors;

  external nk_config_stack_user_font fonts;

  external nk_config_stack_button_behavior button_behaviors;
}

final class nk_config_stack_style_item extends ffi.Struct {
  @ffi.Int()
  external int head;

  @ffi.Array.multi([16])
  external ffi.Array<nk_config_stack_style_item_element> elements;
}

final class nk_config_stack_style_item_element extends ffi.Struct {
  external ffi.Pointer<nk_style_item> address;

  external nk_style_item old_value;
}

final class nk_config_stack_float extends ffi.Struct {
  @ffi.Int()
  external int head;

  @ffi.Array.multi([32])
  external ffi.Array<nk_config_stack_float_element> elements;
}

final class nk_config_stack_float_element extends ffi.Struct {
  external ffi.Pointer<ffi.Float> address;

  @ffi.Float()
  external double old_value;
}

final class nk_config_stack_vec2 extends ffi.Struct {
  @ffi.Int()
  external int head;

  @ffi.Array.multi([16])
  external ffi.Array<nk_config_stack_vec2_element> elements;
}

final class nk_config_stack_vec2_element extends ffi.Struct {
  external ffi.Pointer<nk_vec2> address;

  external nk_vec2 old_value;
}

final class nk_config_stack_flags extends ffi.Struct {
  @ffi.Int()
  external int head;

  @ffi.Array.multi([32])
  external ffi.Array<nk_config_stack_flags_element> elements;
}

final class nk_config_stack_flags_element extends ffi.Struct {
  external ffi.Pointer<nk_flags> address;

  @nk_flags()
  external int old_value;
}

final class nk_config_stack_color extends ffi.Struct {
  @ffi.Int()
  external int head;

  @ffi.Array.multi([32])
  external ffi.Array<nk_config_stack_color_element> elements;
}

final class nk_config_stack_color_element extends ffi.Struct {
  external ffi.Pointer<nk_color> address;

  external nk_color old_value;
}

final class nk_config_stack_user_font extends ffi.Struct {
  @ffi.Int()
  external int head;

  @ffi.Array.multi([8])
  external ffi.Array<nk_config_stack_user_font_element> elements;
}

final class nk_config_stack_user_font_element extends ffi.Struct {
  external ffi.Pointer<ffi.Pointer<nk_user_font>> address;

  external ffi.Pointer<nk_user_font> old_value;
}

final class nk_config_stack_button_behavior extends ffi.Struct {
  @ffi.Int()
  external int head;

  @ffi.Array.multi([8])
  external ffi.Array<nk_config_stack_button_behavior_element> elements;
}

final class nk_config_stack_button_behavior_element extends ffi.Struct {
  external ffi.Pointer<ffi.Int32> address;

  @ffi.Int32()
  external int old_value;
}

final class nk_pool extends ffi.Struct {
  external nk_allocator alloc;

  @ffi.Int32()
  external int type;

  @ffi.UnsignedInt()
  external int page_count;

  external ffi.Pointer<nk_page> pages;

  external ffi.Pointer<nk_page_element> freelist;

  @ffi.UnsignedInt()
  external int capacity;

  @nk_size()
  external int size;

  @nk_size()
  external int cap;
}

final class nk_page extends ffi.Struct {
  @ffi.UnsignedInt()
  external int size;

  external ffi.Pointer<nk_page> next;

  @ffi.Array.multi([1])
  external ffi.Array<nk_page_element> win;
}

final class nk_page_element extends ffi.Struct {
  external nk_page_data data;

  external ffi.Pointer<nk_page_element> next;

  external ffi.Pointer<nk_page_element> prev;
}

final class nk_page_data extends ffi.Union {
  external nk_table tbl;

  external nk_panel pan;

  external nk_window win;
}

final class nk_table extends ffi.Struct {
  @ffi.UnsignedInt()
  external int seq;

  @ffi.UnsignedInt()
  external int size;

  @ffi.Array.multi([60])
  external ffi.Array<nk_hash> keys;

  @ffi.Array.multi([60])
  external ffi.Array<nk_uint> values;

  external ffi.Pointer<nk_table> next;

  external ffi.Pointer<nk_table> prev;
}

typedef nk_hash = nk_uint;

final class nk_window extends ffi.Struct {
  @ffi.UnsignedInt()
  external int seq;

  @nk_hash()
  external int name;

  @ffi.Array.multi([64])
  external ffi.Array<ffi.Char> name_string;

  @nk_flags()
  external int flags;

  external nk_rect bounds;

  external nk_scroll scrollbar;

  external nk_command_buffer buffer;

  external ffi.Pointer<nk_panel> layout;

  @ffi.Float()
  external double scrollbar_hiding_timer;

  external nk_property_state property;

  external nk_popup_state popup;

  external nk_edit_state edit;

  @ffi.UnsignedInt()
  external int scrolled;

  @nk_bool()
  external int widgets_disabled;

  external ffi.Pointer<nk_table> tables;

  @ffi.UnsignedInt()
  external int table_count;

  external ffi.Pointer<nk_window> next;

  external ffi.Pointer<nk_window> prev;

  external ffi.Pointer<nk_window> parent;
}

final class nk_property_state extends ffi.Struct {
  @ffi.Int()
  external int active;

  @ffi.Int()
  external int prev;

  @ffi.Array.multi([64])
  external ffi.Array<ffi.Char> buffer;

  @ffi.Int()
  external int length;

  @ffi.Int()
  external int cursor;

  @ffi.Int()
  external int select_start;

  @ffi.Int()
  external int select_end;

  @nk_hash()
  external int name;

  @ffi.UnsignedInt()
  external int seq;

  @ffi.UnsignedInt()
  external int old;

  @ffi.Int()
  external int state;
}

final class nk_popup_state extends ffi.Struct {
  external ffi.Pointer<nk_window> win;

  @ffi.Int32()
  external int type;

  external nk_popup_buffer buf;

  @nk_hash()
  external int name;

  @nk_bool()
  external int active;

  @ffi.UnsignedInt()
  external int combo_count;

  @ffi.UnsignedInt()
  external int con_count;

  @ffi.UnsignedInt()
  external int con_old;

  @ffi.UnsignedInt()
  external int active_con;

  external nk_rect header;
}

final class nk_popup_buffer extends ffi.Struct {
  @nk_size()
  external int begin;

  @nk_size()
  external int parent;

  @nk_size()
  external int last;

  @nk_size()
  external int end;

  @nk_bool()
  external int active;
}

final class nk_edit_state extends ffi.Struct {
  @nk_hash()
  external int name;

  @ffi.UnsignedInt()
  external int seq;

  @ffi.UnsignedInt()
  external int old;

  @ffi.Int()
  external int active;

  @ffi.Int()
  external int prev;

  @ffi.Int()
  external int cursor;

  @ffi.Int()
  external int sel_start;

  @ffi.Int()
  external int sel_end;

  external nk_scroll scrollbar;

  @ffi.UnsignedChar()
  external int mode;

  @ffi.UnsignedChar()
  external int single_line;
}

final class nk_style_slide extends ffi.Opaque {}

final class nk_colorf extends ffi.Struct {
  @ffi.Float()
  external double r;

  @ffi.Float()
  external double g;

  @ffi.Float()
  external double b;

  @ffi.Float()
  external double a;
}

final class nk_vec2i extends ffi.Struct {
  @ffi.Short()
  external int x;

  @ffi.Short()
  external int y;
}

final class nk_recti extends ffi.Struct {
  @ffi.Short()
  external int x;

  @ffi.Short()
  external int y;

  @ffi.Short()
  external int w;

  @ffi.Short()
  external int h;
}

abstract class nk_heading {
  static const int NK_UP = 0;
  static const int NK_RIGHT = 1;
  static const int NK_DOWN = 2;
  static const int NK_LEFT = 3;
}

abstract class nk_modify {
  static const int NK_FIXED = 0;
  static const int NK_MODIFIABLE = 1;
}

abstract class nk_orientation {
  static const int NK_VERTICAL = 0;
  static const int NK_HORIZONTAL = 1;
}

abstract class nk_collapse_states {
  static const int NK_MINIMIZED = 0;
  static const int NK_MAXIMIZED = 1;
}

abstract class nk_show_states {
  static const int NK_HIDDEN = 0;
  static const int NK_SHOWN = 1;
}

abstract class nk_chart_event {
  static const int NK_CHART_HOVERING = 1;
  static const int NK_CHART_CLICKED = 2;
}

abstract class nk_color_format {
  static const int NK_RGB = 0;
  static const int NK_RGBA = 1;
}

abstract class nk_popup_type {
  static const int NK_POPUP_STATIC = 0;
  static const int NK_POPUP_DYNAMIC = 1;
}

abstract class nk_layout_format {
  static const int NK_DYNAMIC = 0;
  static const int NK_STATIC = 1;
}

abstract class nk_tree_type {
  static const int NK_TREE_NODE = 0;
  static const int NK_TREE_TAB = 1;
}

/// \page Input
///
/// The input API is responsible for holding the current input state composed of
/// mouse, key and text input states.
/// It is worth noting that no direct OS or window handling is done in nuklear.
/// Instead all input state has to be provided by platform specific code. This on one hand
/// expects more work from the user and complicates usage but on the other hand
/// provides simple abstraction over a big number of platforms, libraries and other
/// already provided functionality.
///
/// ```c
/// nk_input_begin(&ctx);
/// while (GetEvent(&evt)) {
/// if (evt.type == MOUSE_MOVE)
/// nk_input_motion(&ctx, evt.motion.x, evt.motion.y);
/// else if (evt.type == [...]) {
/// // [...]
/// }
/// } nk_input_end(&ctx);
/// ```
///
/// # Usage
/// Input state needs to be provided to nuklear by first calling `nk_input_begin`
/// which resets internal state like delta mouse position and button transitions.
/// After `nk_input_begin` all current input state needs to be provided. This includes
/// mouse motion, button and key pressed and released, text input and scrolling.
/// Both event- or state-based input handling are supported by this API
/// and should work without problems. Finally after all input state has been
/// mirrored `nk_input_end` needs to be called to finish input process.
///
/// ```c
/// struct nk_context ctx;
/// nk_init_xxx(&ctx, ...);
/// while (1) {
/// Event evt;
/// nk_input_begin(&ctx);
/// while (GetEvent(&evt)) {
/// if (evt.type == MOUSE_MOVE)
/// nk_input_motion(&ctx, evt.motion.x, evt.motion.y);
/// else if (evt.type == [...]) {
/// // [...]
/// }
/// }
/// nk_input_end(&ctx);
/// // [...]
/// nk_clear(&ctx);
/// } nk_free(&ctx);
/// ```
///
/// # Reference
/// Function            | Description
/// --------------------|-------------------------------------------------------
/// \ref nk_input_begin  | Begins the input mirroring process. Needs to be called before all other `nk_input_xxx` calls
/// \ref nk_input_motion | Mirrors mouse cursor position
/// \ref nk_input_key    | Mirrors key state with either pressed or released
/// \ref nk_input_button | Mirrors mouse button state with either pressed or released
/// \ref nk_input_scroll | Mirrors mouse scroll values
/// \ref nk_input_char   | Adds a single ASCII text character into an internal text buffer
/// \ref nk_input_glyph  | Adds a single multi-byte UTF-8 character into an internal text buffer
/// \ref nk_input_unicode| Adds a single unicode rune into an internal text buffer
/// \ref nk_input_end    | Ends the input mirroring process by calculating state changes. Don't call any `nk_input_xxx` function referenced above after this call
abstract class nk_keys {
  static const int NK_KEY_NONE = 0;
  static const int NK_KEY_SHIFT = 1;
  static const int NK_KEY_CTRL = 2;
  static const int NK_KEY_DEL = 3;
  static const int NK_KEY_ENTER = 4;
  static const int NK_KEY_TAB = 5;
  static const int NK_KEY_BACKSPACE = 6;
  static const int NK_KEY_COPY = 7;
  static const int NK_KEY_CUT = 8;
  static const int NK_KEY_PASTE = 9;
  static const int NK_KEY_UP = 10;
  static const int NK_KEY_DOWN = 11;
  static const int NK_KEY_LEFT = 12;
  static const int NK_KEY_RIGHT = 13;
  static const int NK_KEY_TEXT_INSERT_MODE = 14;
  static const int NK_KEY_TEXT_REPLACE_MODE = 15;
  static const int NK_KEY_TEXT_RESET_MODE = 16;
  static const int NK_KEY_TEXT_LINE_START = 17;
  static const int NK_KEY_TEXT_LINE_END = 18;
  static const int NK_KEY_TEXT_START = 19;
  static const int NK_KEY_TEXT_END = 20;
  static const int NK_KEY_TEXT_UNDO = 21;
  static const int NK_KEY_TEXT_REDO = 22;
  static const int NK_KEY_TEXT_SELECT_ALL = 23;
  static const int NK_KEY_TEXT_WORD_LEFT = 24;
  static const int NK_KEY_TEXT_WORD_RIGHT = 25;
  static const int NK_KEY_SCROLL_START = 26;
  static const int NK_KEY_SCROLL_END = 27;
  static const int NK_KEY_SCROLL_DOWN = 28;
  static const int NK_KEY_SCROLL_UP = 29;
  static const int NK_KEY_MAX = 30;
}

abstract class nk_buttons {
  static const int NK_BUTTON_LEFT = 0;
  static const int NK_BUTTON_MIDDLE = 1;
  static const int NK_BUTTON_RIGHT = 2;
  static const int NK_BUTTON_DOUBLE = 3;
  static const int NK_BUTTON_MAX = 4;
}

abstract class nk_convert_result {
  static const int NK_CONVERT_SUCCESS = 0;
  static const int NK_CONVERT_INVALID_PARAM = 1;
  static const int NK_CONVERT_COMMAND_BUFFER_FULL = 2;
  static const int NK_CONVERT_VERTEX_BUFFER_FULL = 4;
  static const int NK_CONVERT_ELEMENT_BUFFER_FULL = 8;
}

/// command base and header of every command inside the buffer
final class nk_command extends ffi.Struct {
  @ffi.Int32()
  external int type;

  @nk_size()
  external int next;
}

/// \page Drawing
/// This library was designed to be render backend agnostic so it does
/// not draw anything to screen. Instead all drawn shapes, widgets
/// are made of, are buffered into memory and make up a command queue.
/// Each frame therefore fills the command buffer with draw commands
/// that then need to be executed by the user and his own render backend.
/// After that the command buffer needs to be cleared and a new frame can be
/// started. It is probably important to note that the command buffer is the main
/// drawing API and the optional vertex buffer API only takes this format and
/// converts it into a hardware accessible format.
///
/// To use the command queue to draw your own widgets you can access the
/// command buffer of each window by calling `nk_window_get_canvas` after
/// previously having called `nk_begin`:
///
/// ```c
/// void draw_red_rectangle_widget(struct nk_context *ctx)
/// {
/// struct nk_command_buffer *canvas;
/// struct nk_input *input = &ctx->input;
/// canvas = nk_window_get_canvas(ctx);
///
/// struct nk_rect space;
/// enum nk_widget_layout_states state;
/// state = nk_widget(&space, ctx);
/// if (!state) return;
///
/// if (state != NK_WIDGET_ROM)
/// update_your_widget_by_user_input(...);
/// nk_fill_rect(canvas, space, 0, nk_rgb(255,0,0));
/// }
///
/// if (nk_begin(...)) {
/// nk_layout_row_dynamic(ctx, 25, 1);
/// draw_red_rectangle_widget(ctx);
/// }
/// nk_end(..)
///
/// ```
/// Important to know if you want to create your own widgets is the `nk_widget`
/// call. It allocates space on the panel reserved for this widget to be used,
/// but also returns the state of the widget space. If your widget is not seen and does
/// not have to be updated it is '0' and you can just return. If it only has
/// to be drawn the state will be `NK_WIDGET_ROM` otherwise you can do both
/// update and draw your widget. The reason for separating is to only draw and
/// update what is actually necessary which is crucial for performance.
abstract class nk_command_type {
  static const int NK_COMMAND_NOP = 0;
  static const int NK_COMMAND_SCISSOR = 1;
  static const int NK_COMMAND_LINE = 2;
  static const int NK_COMMAND_CURVE = 3;
  static const int NK_COMMAND_RECT = 4;
  static const int NK_COMMAND_RECT_FILLED = 5;
  static const int NK_COMMAND_RECT_MULTI_COLOR = 6;
  static const int NK_COMMAND_CIRCLE = 7;
  static const int NK_COMMAND_CIRCLE_FILLED = 8;
  static const int NK_COMMAND_ARC = 9;
  static const int NK_COMMAND_ARC_FILLED = 10;
  static const int NK_COMMAND_TRIANGLE = 11;
  static const int NK_COMMAND_TRIANGLE_FILLED = 12;
  static const int NK_COMMAND_POLYGON = 13;
  static const int NK_COMMAND_POLYGON_FILLED = 14;
  static const int NK_COMMAND_POLYLINE = 15;
  static const int NK_COMMAND_TEXT = 16;
  static const int NK_COMMAND_IMAGE = 17;
  static const int NK_COMMAND_CUSTOM = 18;
}

/// =============================================================================
///
/// WINDOW
///
/// =============================================================================*/
/// /**
/// \page Window
/// Windows are the main persistent state used inside nuklear and are life time
/// controlled by simply "retouching" (i.e. calling) each window each frame.
/// All widgets inside nuklear can only be added inside the function pair `nk_begin_xxx`
/// and `nk_end`. Calling any widgets outside these two functions will result in an
/// assert in debug or no state change in release mode.<br /><br />
///
/// Each window holds frame persistent state like position, size, flags, state tables,
/// and some garbage collected internal persistent widget state. Each window
/// is linked into a window stack list which determines the drawing and overlapping
/// order. The topmost window thereby is the currently active window.<br /><br />
///
/// To change window position inside the stack occurs either automatically by
/// user input by being clicked on or programmatically by calling `nk_window_focus`.
/// Windows by default are visible unless explicitly being defined with flag
/// `NK_WINDOW_HIDDEN`, the user clicked the close button on windows with flag
/// `NK_WINDOW_CLOSABLE` or if a window was explicitly hidden by calling
/// `nk_window_show`. To explicitly close and destroy a window call `nk_window_close`.<br /><br />
///
/// # Usage
/// To create and keep a window you have to call one of the two `nk_begin_xxx`
/// functions to start window declarations and `nk_end` at the end. Furthermore it
/// is recommended to check the return value of `nk_begin_xxx` and only process
/// widgets inside the window if the value is not 0. Either way you have to call
/// `nk_end` at the end of window declarations. Furthermore, do not attempt to
/// nest `nk_begin_xxx` calls which will hopefully result in an assert or if not
/// in a segmentation fault.
///
/// ```c
/// if (nk_begin_xxx(...) {
/// // [... widgets ...]
/// }
/// nk_end(ctx);
/// ```
///
/// In the grand concept window and widget declarations need to occur after input
/// handling and before drawing to screen. Not doing so can result in higher
/// latency or at worst invalid behavior. Furthermore make sure that `nk_clear`
/// is called at the end of the frame. While nuklear's default platform backends
/// already call `nk_clear` for you if you write your own backend not calling
/// `nk_clear` can cause asserts or even worse undefined behavior.
///
/// ```c
/// struct nk_context ctx;
/// nk_init_xxx(&ctx, ...);
/// while (1) {
/// Event evt;
/// nk_input_begin(&ctx);
/// while (GetEvent(&evt)) {
/// if (evt.type == MOUSE_MOVE)
/// nk_input_motion(&ctx, evt.motion.x, evt.motion.y);
/// else if (evt.type == [...]) {
/// nk_input_xxx(...);
/// }
/// }
/// nk_input_end(&ctx);
///
/// if (nk_begin_xxx(...) {
/// //[...]
/// }
/// nk_end(ctx);
///
/// const struct nk_command *cmd = 0;
/// nk_foreach(cmd, &ctx) {
/// case NK_COMMAND_LINE:
/// your_draw_line_function(...)
/// break;
/// case NK_COMMAND_RECT
/// your_draw_rect_function(...)
/// break;
/// case //...:
/// //[...]
/// }
/// nk_clear(&ctx);
/// }
/// nk_free(&ctx);
/// ```
///
/// # Reference
/// Function                            | Description
/// ------------------------------------|----------------------------------------
/// \ref nk_begin                            | Starts a new window; needs to be called every frame for every window (unless hidden) or otherwise the window gets removed
/// \ref nk_begin_titled                     | Extended window start with separated title and identifier to allow multiple windows with same name but not title
/// \ref nk_end                              | Needs to be called at the end of the window building process to process scaling, scrollbars and general cleanup
///
/// \ref nk_window_find                      | Finds and returns the window with give name
/// \ref nk_window_get_bounds                | Returns a rectangle with screen position and size of the currently processed window.
/// \ref nk_window_get_position              | Returns the position of the currently processed window
/// \ref nk_window_get_size                  | Returns the size with width and height of the currently processed window
/// \ref nk_window_get_width                 | Returns the width of the currently processed window
/// \ref nk_window_get_height                | Returns the height of the currently processed window
/// \ref nk_window_get_panel                 | Returns the underlying panel which contains all processing state of the current window
/// \ref nk_window_get_content_region        | Returns the position and size of the currently visible and non-clipped space inside the currently processed window
/// \ref nk_window_get_content_region_min    | Returns the upper rectangle position of the currently visible and non-clipped space inside the currently processed window
/// \ref nk_window_get_content_region_max    | Returns the upper rectangle position of the currently visible and non-clipped space inside the currently processed window
/// \ref nk_window_get_content_region_size   | Returns the size of the currently visible and non-clipped space inside the currently processed window
/// \ref nk_window_get_canvas                | Returns the draw command buffer. Can be used to draw custom widgets
/// \ref nk_window_get_scroll                | Gets the scroll offset of the current window
/// \ref nk_window_has_focus                 | Returns if the currently processed window is currently active
/// \ref nk_window_is_collapsed              | Returns if the window with given name is currently minimized/collapsed
/// \ref nk_window_is_closed                 | Returns if the currently processed window was closed
/// \ref nk_window_is_hidden                 | Returns if the currently processed window was hidden
/// \ref nk_window_is_active                 | Same as nk_window_has_focus for some reason
/// \ref nk_window_is_hovered                | Returns if the currently processed window is currently being hovered by mouse
/// \ref nk_window_is_any_hovered            | Return if any window currently hovered
/// \ref nk_item_is_any_active               | Returns if any window or widgets is currently hovered or active
/// //
/// \ref nk_window_set_bounds                | Updates position and size of the currently processed window
/// \ref nk_window_set_position              | Updates position of the currently process window
/// \ref nk_window_set_size                  | Updates the size of the currently processed window
/// \ref nk_window_set_focus                 | Set the currently processed window as active window
/// \ref nk_window_set_scroll                | Sets the scroll offset of the current window
/// //
/// \ref nk_window_close                     | Closes the window with given window name which deletes the window at the end of the frame
/// \ref nk_window_collapse                  | Collapses the window with given window name
/// \ref nk_window_collapse_if               | Collapses the window with given window name if the given condition was met
/// \ref nk_window_show                      | Hides a visible or reshows a hidden window
/// \ref nk_window_show_if                   | Hides/shows a window depending on condition
///
/// # nk_panel_flags
/// Flag                        | Description
/// ----------------------------|----------------------------------------
/// NK_WINDOW_BORDER            | Draws a border around the window to visually separate window from the background
/// NK_WINDOW_MOVABLE           | The movable flag indicates that a window can be moved by user input or by dragging the window header
/// NK_WINDOW_SCALABLE          | The scalable flag indicates that a window can be scaled by user input by dragging a scaler icon at the button of the window
/// NK_WINDOW_CLOSABLE          | Adds a closable icon into the header
/// NK_WINDOW_MINIMIZABLE       | Adds a minimize icon into the header
/// NK_WINDOW_NO_SCROLLBAR      | Removes the scrollbar from the window
/// NK_WINDOW_TITLE             | Forces a header at the top at the window showing the title
/// NK_WINDOW_SCROLL_AUTO_HIDE  | Automatically hides the window scrollbar if no user interaction: also requires delta time in `nk_context` to be set each frame
/// NK_WINDOW_BACKGROUND        | Always keep window in the background
/// NK_WINDOW_SCALE_LEFT        | Puts window scaler in the left-bottom corner instead right-bottom
/// NK_WINDOW_NO_INPUT          | Prevents window of scaling, moving or getting focus
///
/// # nk_collapse_states
/// State           | Description
/// ----------------|-----------------------------------------------------------
/// NK_MINIMIZED| UI section is collapsed and not visible until maximized
/// NK_MAXIMIZED| UI section is extended and visible until minimized
abstract class nk_panel_flags {
  static const int NK_WINDOW_BORDER = 1;
  static const int NK_WINDOW_MOVABLE = 2;
  static const int NK_WINDOW_SCALABLE = 4;
  static const int NK_WINDOW_CLOSABLE = 8;
  static const int NK_WINDOW_MINIMIZABLE = 16;
  static const int NK_WINDOW_NO_SCROLLBAR = 32;
  static const int NK_WINDOW_TITLE = 64;
  static const int NK_WINDOW_SCROLL_AUTO_HIDE = 128;
  static const int NK_WINDOW_BACKGROUND = 256;
  static const int NK_WINDOW_SCALE_LEFT = 512;
  static const int NK_WINDOW_NO_INPUT = 1024;
}

/// \page Layouting
/// Layouting in general describes placing widget inside a window with position and size.
/// While in this particular implementation there are five different APIs for layouting
/// each with different trade offs between control and ease of use. <br /><br />
///
/// All layouting methods in this library are based around the concept of a row.
/// A row has a height the window content grows by and a number of columns and each
/// layouting method specifies how each widget is placed inside the row.
/// After a row has been allocated by calling a layouting functions and then
/// filled with widgets will advance an internal pointer over the allocated row. <br /><br />
///
/// To actually define a layout you just call the appropriate layouting function
/// and each subsequent widget call will place the widget as specified. Important
/// here is that if you define more widgets then columns defined inside the layout
/// functions it will allocate the next row without you having to make another layouting <br /><br />
/// call.
///
/// Biggest limitation with using all these APIs outside the `nk_layout_space_xxx` API
/// is that you have to define the row height for each. However the row height
/// often depends on the height of the font. <br /><br />
///
/// To fix that internally nuklear uses a minimum row height that is set to the
/// height plus padding of currently active font and overwrites the row height
/// value if zero. <br /><br />
///
/// If you manually want to change the minimum row height then
/// use nk_layout_set_min_row_height, and use nk_layout_reset_min_row_height to
/// reset it back to be derived from font height. <br /><br />
///
/// Also if you change the font in nuklear it will automatically change the minimum
/// row height for you and. This means if you change the font but still want
/// a minimum row height smaller than the font you have to repush your value. <br /><br />
///
/// For actually more advanced UI I would even recommend using the `nk_layout_space_xxx`
/// layouting method in combination with a cassowary constraint solver (there are
/// some versions on github with permissive license model) to take over all control over widget
/// layouting yourself. However for quick and dirty layouting using all the other layouting
/// functions should be fine.
///
/// # Usage
/// 1.  __nk_layout_row_dynamic__<br /><br />
/// The easiest layouting function is `nk_layout_row_dynamic`. It provides each
/// widgets with same horizontal space inside the row and dynamically grows
/// if the owning window grows in width. So the number of columns dictates
/// the size of each widget dynamically by formula:
///
/// ```c
/// widget_width = (window_width - padding - spacing) * (1/column_count)
/// ```
///
/// Just like all other layouting APIs if you define more widget than columns this
/// library will allocate a new row and keep all layouting parameters previously
/// defined.
///
/// ```c
/// if (nk_begin_xxx(...) {
/// // first row with height: 30 composed of two widgets
/// nk_layout_row_dynamic(&ctx, 30, 2);
/// nk_widget(...);
/// nk_widget(...);
/// //
/// // second row with same parameter as defined above
/// nk_widget(...);
/// nk_widget(...);
/// //
/// // third row uses 0 for height which will use auto layouting
/// nk_layout_row_dynamic(&ctx, 0, 2);
/// nk_widget(...);
/// nk_widget(...);
/// }
/// nk_end(...);
/// ```
///
/// 2.  __nk_layout_row_static__<br /><br />
/// Another easy layouting function is `nk_layout_row_static`. It provides each
/// widget with same horizontal pixel width inside the row and does not grow
/// if the owning window scales smaller or bigger.
///
/// ```c
/// if (nk_begin_xxx(...) {
/// // first row with height: 30 composed of two widgets with width: 80
/// nk_layout_row_static(&ctx, 30, 80, 2);
/// nk_widget(...);
/// nk_widget(...);
/// //
/// // second row with same parameter as defined above
/// nk_widget(...);
/// nk_widget(...);
/// //
/// // third row uses 0 for height which will use auto layouting
/// nk_layout_row_static(&ctx, 0, 80, 2);
/// nk_widget(...);
/// nk_widget(...);
/// }
/// nk_end(...);
/// ```
///
/// 3.  __nk_layout_row_xxx__<br /><br />
/// A little bit more advanced layouting API are functions `nk_layout_row_begin`,
/// `nk_layout_row_push` and `nk_layout_row_end`. They allow to directly
/// specify each column pixel or window ratio in a row. It supports either
/// directly setting per column pixel width or widget window ratio but not
/// both. Furthermore it is a immediate mode API so each value is directly
/// pushed before calling a widget. Therefore the layout is not automatically
/// repeating like the last two layouting functions.
///
/// ```c
/// if (nk_begin_xxx(...) {
/// // first row with height: 25 composed of two widgets with width 60 and 40
/// nk_layout_row_begin(ctx, NK_STATIC, 25, 2);
/// nk_layout_row_push(ctx, 60);
/// nk_widget(...);
/// nk_layout_row_push(ctx, 40);
/// nk_widget(...);
/// nk_layout_row_end(ctx);
/// //
/// // second row with height: 25 composed of two widgets with window ratio 0.25 and 0.75
/// nk_layout_row_begin(ctx, NK_DYNAMIC, 25, 2);
/// nk_layout_row_push(ctx, 0.25f);
/// nk_widget(...);
/// nk_layout_row_push(ctx, 0.75f);
/// nk_widget(...);
/// nk_layout_row_end(ctx);
/// //
/// // third row with auto generated height: composed of two widgets with window ratio 0.25 and 0.75
/// nk_layout_row_begin(ctx, NK_DYNAMIC, 0, 2);
/// nk_layout_row_push(ctx, 0.25f);
/// nk_widget(...);
/// nk_layout_row_push(ctx, 0.75f);
/// nk_widget(...);
/// nk_layout_row_end(ctx);
/// }
/// nk_end(...);
/// ```
///
/// 4.  __nk_layout_row__<br /><br />
/// The array counterpart to API nk_layout_row_xxx is the single nk_layout_row
/// functions. Instead of pushing either pixel or window ratio for every widget
/// it allows to define it by array. The trade of for less control is that
/// `nk_layout_row` is automatically repeating. Otherwise the behavior is the
/// same.
///
/// ```c
/// if (nk_begin_xxx(...) {
/// // two rows with height: 30 composed of two widgets with width 60 and 40
/// const float ratio[] = {60,40};
/// nk_layout_row(ctx, NK_STATIC, 30, 2, ratio);
/// nk_widget(...);
/// nk_widget(...);
/// nk_widget(...);
/// nk_widget(...);
/// //
/// // two rows with height: 30 composed of two widgets with window ratio 0.25 and 0.75
/// const float ratio[] = {0.25, 0.75};
/// nk_layout_row(ctx, NK_DYNAMIC, 30, 2, ratio);
/// nk_widget(...);
/// nk_widget(...);
/// nk_widget(...);
/// nk_widget(...);
/// //
/// // two rows with auto generated height composed of two widgets with window ratio 0.25 and 0.75
/// const float ratio[] = {0.25, 0.75};
/// nk_layout_row(ctx, NK_DYNAMIC, 30, 2, ratio);
/// nk_widget(...);
/// nk_widget(...);
/// nk_widget(...);
/// nk_widget(...);
/// }
/// nk_end(...);
/// ```
///
/// 5.  __nk_layout_row_template_xxx__<br /><br />
/// The most complex and second most flexible API is a simplified flexbox version without
/// line wrapping and weights for dynamic widgets. It is an immediate mode API but
/// unlike `nk_layout_row_xxx` it has auto repeat behavior and needs to be called
/// before calling the templated widgets.
/// The row template layout has three different per widget size specifier. The first
/// one is the `nk_layout_row_template_push_static`  with fixed widget pixel width.
/// They do not grow if the row grows and will always stay the same.
/// The second size specifier is `nk_layout_row_template_push_variable`
/// which defines a minimum widget size but it also can grow if more space is available
/// not taken by other widgets.
/// Finally there are dynamic widgets with `nk_layout_row_template_push_dynamic`
/// which are completely flexible and unlike variable widgets can even shrink
/// to zero if not enough space is provided.
///
/// ```c
/// if (nk_begin_xxx(...) {
/// // two rows with height: 30 composed of three widgets
/// nk_layout_row_template_begin(ctx, 30);
/// nk_layout_row_template_push_dynamic(ctx);
/// nk_layout_row_template_push_variable(ctx, 80);
/// nk_layout_row_template_push_static(ctx, 80);
/// nk_layout_row_template_end(ctx);
/// //
/// // first row
/// nk_widget(...); // dynamic widget can go to zero if not enough space
/// nk_widget(...); // variable widget with min 80 pixel but can grow bigger if enough space
/// nk_widget(...); // static widget with fixed 80 pixel width
/// //
/// // second row same layout
/// nk_widget(...);
/// nk_widget(...);
/// nk_widget(...);
/// }
/// nk_end(...);
/// ```
///
/// 6.  __nk_layout_space_xxx__<br /><br />
/// Finally the most flexible API directly allows you to place widgets inside the
/// window. The space layout API is an immediate mode API which does not support
/// row auto repeat and directly sets position and size of a widget. Position
/// and size hereby can be either specified as ratio of allocated space or
/// allocated space local position and pixel size. Since this API is quite
/// powerful there are a number of utility functions to get the available space
/// and convert between local allocated space and screen space.
///
/// ```c
/// if (nk_begin_xxx(...) {
/// // static row with height: 500 (you can set column count to INT_MAX if you don't want to be bothered)
/// nk_layout_space_begin(ctx, NK_STATIC, 500, INT_MAX);
/// nk_layout_space_push(ctx, nk_rect(0,0,150,200));
/// nk_widget(...);
/// nk_layout_space_push(ctx, nk_rect(200,200,100,200));
/// nk_widget(...);
/// nk_layout_space_end(ctx);
/// //
/// // dynamic row with height: 500 (you can set column count to INT_MAX if you don't want to be bothered)
/// nk_layout_space_begin(ctx, NK_DYNAMIC, 500, INT_MAX);
/// nk_layout_space_push(ctx, nk_rect(0.5,0.5,0.1,0.1));
/// nk_widget(...);
/// nk_layout_space_push(ctx, nk_rect(0.7,0.6,0.1,0.1));
/// nk_widget(...);
/// }
/// nk_end(...);
/// ```
///
/// # Reference
/// Function                                     | Description
/// ---------------------------------------------|------------------------------------
/// \ref nk_layout_set_min_row_height            | Set the currently used minimum row height to a specified value
/// \ref nk_layout_reset_min_row_height          | Resets the currently used minimum row height to font height
/// \ref nk_layout_widget_bounds                 | Calculates current width a static layout row can fit inside a window
/// \ref nk_layout_ratio_from_pixel              | Utility functions to calculate window ratio from pixel size
/// \ref nk_layout_row_dynamic                   | Current layout is divided into n same sized growing columns
/// \ref nk_layout_row_static                    | Current layout is divided into n same fixed sized columns
/// \ref nk_layout_row_begin                     | Starts a new row with given height and number of columns
/// \ref nk_layout_row_push                      | Pushes another column with given size or window ratio
/// \ref nk_layout_row_end                       | Finished previously started row
/// \ref nk_layout_row                           | Specifies row columns in array as either window ratio or size
/// \ref nk_layout_row_template_begin            | Begins the row template declaration
/// \ref nk_layout_row_template_push_dynamic     | Adds a dynamic column that dynamically grows and can go to zero if not enough space
/// \ref nk_layout_row_template_push_variable    | Adds a variable column that dynamically grows but does not shrink below specified pixel width
/// \ref nk_layout_row_template_push_static      | Adds a static column that does not grow and will always have the same size
/// \ref nk_layout_row_template_end              | Marks the end of the row template
/// \ref nk_layout_space_begin                   | Begins a new layouting space that allows to specify each widgets position and size
/// \ref nk_layout_space_push                    | Pushes position and size of the next widget in own coordinate space either as pixel or ratio
/// \ref nk_layout_space_end                     | Marks the end of the layouting space
/// \ref nk_layout_space_bounds                  | Callable after nk_layout_space_begin and returns total space allocated
/// \ref nk_layout_space_to_screen               | Converts vector from nk_layout_space coordinate space into screen space
/// \ref nk_layout_space_to_local                | Converts vector from screen space into nk_layout_space coordinates
/// \ref nk_layout_space_rect_to_screen          | Converts rectangle from nk_layout_space coordinate space into screen space
/// \ref nk_layout_space_rect_to_local           | Converts rectangle from screen space into nk_layout_space coordinates
abstract class nk_widget_align {
  static const int NK_WIDGET_ALIGN_LEFT = 1;
  static const int NK_WIDGET_ALIGN_CENTERED = 2;
  static const int NK_WIDGET_ALIGN_RIGHT = 4;
  static const int NK_WIDGET_ALIGN_TOP = 8;
  static const int NK_WIDGET_ALIGN_MIDDLE = 16;
  static const int NK_WIDGET_ALIGN_BOTTOM = 32;
}

abstract class nk_widget_alignment {
  static const int NK_WIDGET_LEFT = 17;
  static const int NK_WIDGET_CENTERED = 18;
  static const int NK_WIDGET_RIGHT = 20;
}

final class nk_list_view extends ffi.Struct {
  @ffi.Int()
  external int begin;

  @ffi.Int()
  external int end;

  @ffi.Int()
  external int count;

  @ffi.Int()
  external int total_height;

  external ffi.Pointer<nk_context> ctx;

  external ffi.Pointer<nk_uint> scroll_pointer;

  @nk_uint()
  external int scroll_value;
}

abstract class nk_widget_layout_states {
  /// < The widget cannot be seen and is completely out of view
  static const int NK_WIDGET_INVALID = 0;

  /// < The widget is completely inside the window and can be updated and drawn
  static const int NK_WIDGET_VALID = 1;

  /// < The widget is partially visible and cannot be updated
  static const int NK_WIDGET_ROM = 2;

  /// < The widget is manually disabled and acts like NK_WIDGET_ROM
  static const int NK_WIDGET_DISABLED = 3;
}

abstract class nk_widget_states {
  static const int NK_WIDGET_STATE_MODIFIED = 2;
  static const int NK_WIDGET_STATE_INACTIVE = 4;

  /// !< widget is neither active nor hovered
  static const int NK_WIDGET_STATE_ENTERED = 8;

  /// !< widget has been hovered on the current frame
  static const int NK_WIDGET_STATE_HOVER = 16;

  /// !< widget is being hovered
  static const int NK_WIDGET_STATE_ACTIVED = 32;

  /// !< widget is currently activated
  static const int NK_WIDGET_STATE_LEFT = 64;

  /// !< widget is from this frame on not hovered anymore
  static const int NK_WIDGET_STATE_HOVERED = 18;

  /// !< widget is being hovered
  static const int NK_WIDGET_STATE_ACTIVE = 34;
}

abstract class nk_text_align {
  static const int NK_TEXT_ALIGN_LEFT = 1;
  static const int NK_TEXT_ALIGN_CENTERED = 2;
  static const int NK_TEXT_ALIGN_RIGHT = 4;
  static const int NK_TEXT_ALIGN_TOP = 8;
  static const int NK_TEXT_ALIGN_MIDDLE = 16;
  static const int NK_TEXT_ALIGN_BOTTOM = 32;
}

abstract class nk_text_alignment {
  static const int NK_TEXT_LEFT = 17;
  static const int NK_TEXT_CENTERED = 18;
  static const int NK_TEXT_RIGHT = 20;
}

typedef va_list = ffi.Pointer<ffi.Char>;

abstract class nk_edit_flags {
  static const int NK_EDIT_DEFAULT = 0;
  static const int NK_EDIT_READ_ONLY = 1;
  static const int NK_EDIT_AUTO_SELECT = 2;
  static const int NK_EDIT_SIG_ENTER = 4;
  static const int NK_EDIT_ALLOW_TAB = 8;
  static const int NK_EDIT_NO_CURSOR = 16;
  static const int NK_EDIT_SELECTABLE = 32;
  static const int NK_EDIT_CLIPBOARD = 64;
  static const int NK_EDIT_CTRL_ENTER_NEWLINE = 128;
  static const int NK_EDIT_NO_HORIZONTAL_SCROLL = 256;
  static const int NK_EDIT_ALWAYS_INSERT_MODE = 512;
  static const int NK_EDIT_MULTILINE = 1024;
  static const int NK_EDIT_GOTO_END_ON_ACTIVATE = 2048;
}

abstract class nk_edit_types {
  static const int NK_EDIT_SIMPLE = 512;
  static const int NK_EDIT_FIELD = 608;
  static const int NK_EDIT_BOX = 1640;
  static const int NK_EDIT_EDITOR = 1128;
}

abstract class nk_edit_events {
  static const int NK_EDIT_ACTIVE = 1;

  /// !< edit widget is currently being modified
  static const int NK_EDIT_INACTIVE = 2;

  /// !< edit widget is not active and is not being modified
  static const int NK_EDIT_ACTIVATED = 4;

  /// !< edit widget went from state inactive to state active
  static const int NK_EDIT_DEACTIVATED = 8;

  /// !< edit widget went from state active to state inactive
  static const int NK_EDIT_COMMITED = 16;
}

abstract class nk_style_colors {
  static const int NK_COLOR_TEXT = 0;
  static const int NK_COLOR_WINDOW = 1;
  static const int NK_COLOR_HEADER = 2;
  static const int NK_COLOR_BORDER = 3;
  static const int NK_COLOR_BUTTON = 4;
  static const int NK_COLOR_BUTTON_HOVER = 5;
  static const int NK_COLOR_BUTTON_ACTIVE = 6;
  static const int NK_COLOR_TOGGLE = 7;
  static const int NK_COLOR_TOGGLE_HOVER = 8;
  static const int NK_COLOR_TOGGLE_CURSOR = 9;
  static const int NK_COLOR_SELECT = 10;
  static const int NK_COLOR_SELECT_ACTIVE = 11;
  static const int NK_COLOR_SLIDER = 12;
  static const int NK_COLOR_SLIDER_CURSOR = 13;
  static const int NK_COLOR_SLIDER_CURSOR_HOVER = 14;
  static const int NK_COLOR_SLIDER_CURSOR_ACTIVE = 15;
  static const int NK_COLOR_PROPERTY = 16;
  static const int NK_COLOR_EDIT = 17;
  static const int NK_COLOR_EDIT_CURSOR = 18;
  static const int NK_COLOR_COMBO = 19;
  static const int NK_COLOR_CHART = 20;
  static const int NK_COLOR_CHART_COLOR = 21;
  static const int NK_COLOR_CHART_COLOR_HIGHLIGHT = 22;
  static const int NK_COLOR_SCROLLBAR = 23;
  static const int NK_COLOR_SCROLLBAR_CURSOR = 24;
  static const int NK_COLOR_SCROLLBAR_CURSOR_HOVER = 25;
  static const int NK_COLOR_SCROLLBAR_CURSOR_ACTIVE = 26;
  static const int NK_COLOR_TAB_HEADER = 27;
  static const int NK_COLOR_KNOB = 28;
  static const int NK_COLOR_KNOB_CURSOR = 29;
  static const int NK_COLOR_KNOB_CURSOR_HOVER = 30;
  static const int NK_COLOR_KNOB_CURSOR_ACTIVE = 31;
  static const int NK_COLOR_COUNT = 32;
}

abstract class nk_style_cursor {
  static const int NK_CURSOR_ARROW = 0;
  static const int NK_CURSOR_TEXT = 1;
  static const int NK_CURSOR_MOVE = 2;
  static const int NK_CURSOR_RESIZE_VERTICAL = 3;
  static const int NK_CURSOR_RESIZE_HORIZONTAL = 4;
  static const int NK_CURSOR_RESIZE_TOP_LEFT_DOWN_RIGHT = 5;
  static const int NK_CURSOR_RESIZE_TOP_RIGHT_DOWN_LEFT = 6;
  static const int NK_CURSOR_COUNT = 7;
}

abstract class nk_font_coord_type {
  static const int NK_COORD_UV = 0;

  /// !< texture coordinates inside font glyphs are clamped between 0-1
  static const int NK_COORD_PIXEL = 1;
}

final class nk_font extends ffi.Struct {
  external ffi.Pointer<nk_font> next;

  external nk_user_font handle;

  external nk_baked_font info;

  @ffi.Float()
  external double scale;

  external ffi.Pointer<nk_font_glyph> glyphs;

  external ffi.Pointer<nk_font_glyph> fallback;

  @nk_rune()
  external int fallback_codepoint;

  external nk_handle texture;

  external ffi.Pointer<nk_font_config> config;
}

final class nk_baked_font extends ffi.Struct {
  @ffi.Float()
  external double height;

  /// !< height of the font
  @ffi.Float()
  external double ascent;

  /// !< font glyphs ascent and descent
  @ffi.Float()
  external double descent;

  /// !< font glyphs ascent and descent
  @nk_rune()
  external int glyph_offset;

  /// !< glyph array offset inside the font glyph baking output array
  @nk_rune()
  external int glyph_count;

  /// !< number of glyphs of this font inside the glyph baking array output
  external ffi.Pointer<nk_rune> ranges;
}

final class nk_font_glyph extends ffi.Struct {
  @nk_rune()
  external int codepoint;

  @ffi.Float()
  external double xadvance;

  @ffi.Float()
  external double x0;

  @ffi.Float()
  external double y0;

  @ffi.Float()
  external double x1;

  @ffi.Float()
  external double y1;

  @ffi.Float()
  external double w;

  @ffi.Float()
  external double h;

  @ffi.Float()
  external double u0;

  @ffi.Float()
  external double v0;

  @ffi.Float()
  external double u1;

  @ffi.Float()
  external double v1;
}

final class nk_font_config extends ffi.Struct {
  external ffi.Pointer<nk_font_config> next;

  /// !< NOTE: only used internally
  external ffi.Pointer<ffi.Void> ttf_blob;

  /// !< pointer to loaded TTF file memory block.  * \note not needed for nk_font_atlas_add_from_memory and nk_font_atlas_add_from_file.
  @nk_size()
  external int ttf_size;

  /// !< size of the loaded TTF file memory block * \note not needed for nk_font_atlas_add_from_memory and nk_font_atlas_add_from_file.
  @ffi.UnsignedChar()
  external int ttf_data_owned_by_atlas;

  /// !< used inside font atlas: default to: 0
  @ffi.UnsignedChar()
  external int merge_mode;

  /// !< merges this font into the last font
  @ffi.UnsignedChar()
  external int pixel_snap;

  /// !< align every character to pixel boundary (if true set oversample (1,1))
  @ffi.UnsignedChar()
  external int oversample_v;

  @ffi.UnsignedChar()
  external int oversample_h;

  /// !< rasterize at high quality for sub-pixel position
  @ffi.Array.multi([3])
  external ffi.Array<ffi.UnsignedChar> padding;

  @ffi.Float()
  external double size;

  /// !< baked pixel height of the font
  @ffi.Int32()
  external int coord_type;

  /// !< texture coordinate format with either pixel or UV coordinates
  external nk_vec2 spacing;

  /// !< extra pixel spacing between glyphs
  external ffi.Pointer<nk_rune> range;

  /// !< list of unicode ranges (2 values per range, zero terminated)
  external ffi.Pointer<nk_baked_font> font;

  /// !< font to setup in the baking process: NOTE: not needed for font atlas
  @nk_rune()
  external int fallback_glyph;

  /// !< fallback glyph to use if a given rune is not found
  external ffi.Pointer<nk_font_config> n;

  external ffi.Pointer<nk_font_config> p;
}

abstract class nk_font_atlas_format {
  static const int NK_FONT_ATLAS_ALPHA8 = 0;
  static const int NK_FONT_ATLAS_RGBA32 = 1;
}

final class nk_font_atlas extends ffi.Struct {
  external ffi.Pointer<ffi.Void> pixel;

  @ffi.Int()
  external int tex_width;

  @ffi.Int()
  external int tex_height;

  external nk_allocator permanent;

  external nk_allocator temporary;

  external nk_recti custom;

  @ffi.Array.multi([7])
  external ffi.Array<nk_cursor> cursors;

  @ffi.Int()
  external int glyph_count;

  external ffi.Pointer<nk_font_glyph> glyphs;

  external ffi.Pointer<nk_font> default_font;

  external ffi.Pointer<nk_font> fonts;

  external ffi.Pointer<nk_font_config> config;

  @ffi.Int()
  external int font_num;
}

/// ==============================================================
///
/// MEMORY BUFFER
///
/// ===============================================================*/
/// /**
/// \page Memory Buffer
/// A basic (double)-buffer with linear allocation and resetting as only
/// freeing policy. The buffer's main purpose is to control all memory management
/// inside the GUI toolkit and still leave memory control as much as possible in
/// the hand of the user while also making sure the library is easy to use if
/// not as much control is needed.
/// In general all memory inside this library can be provided from the user in
/// three different ways.
///
/// The first way and the one providing most control is by just passing a fixed
/// size memory block. In this case all control lies in the hand of the user
/// since he can exactly control where the memory comes from and how much memory
/// the library should consume. Of course using the fixed size API removes the
/// ability to automatically resize a buffer if not enough memory is provided so
/// you have to take over the resizing. While being a fixed sized buffer sounds
/// quite limiting, it is very effective in this library since the actual memory
/// consumption is quite stable and has a fixed upper bound for a lot of cases.
///
/// If you don't want to think about how much memory the library should allocate
/// at all time or have a very dynamic UI with unpredictable memory consumption
/// habits but still want control over memory allocation you can use the dynamic
/// allocator based API. The allocator consists of two callbacks for allocating
/// and freeing memory and optional userdata so you can plugin your own allocator.
///
/// The final and easiest way can be used by defining
/// NK_INCLUDE_DEFAULT_ALLOCATOR which uses the standard library memory
/// allocation functions malloc and free and takes over complete control over
/// memory in this library.
final class nk_memory_status extends ffi.Struct {
  external ffi.Pointer<ffi.Void> memory;

  @ffi.UnsignedInt()
  external int type;

  @nk_size()
  external int size;

  @nk_size()
  external int allocated;

  @nk_size()
  external int needed;

  @nk_size()
  external int calls;
}

abstract class nk_buffer_allocation_type {
  static const int NK_BUFFER_FRONT = 0;
  static const int NK_BUFFER_BACK = 1;
  static const int NK_BUFFER_MAX = 2;
}

abstract class nk_text_edit_type {
  static const int NK_TEXT_EDIT_SINGLE_LINE = 0;
  static const int NK_TEXT_EDIT_MULTI_LINE = 1;
}

abstract class nk_text_edit_mode {
  static const int NK_TEXT_EDIT_MODE_VIEW = 0;
  static const int NK_TEXT_EDIT_MODE_INSERT = 1;
  static const int NK_TEXT_EDIT_MODE_REPLACE = 2;
}

final class nk_command_scissor extends ffi.Struct {
  external nk_command header;

  @ffi.Short()
  external int x;

  @ffi.Short()
  external int y;

  @ffi.UnsignedShort()
  external int w;

  @ffi.UnsignedShort()
  external int h;
}

final class nk_command_line extends ffi.Struct {
  external nk_command header;

  @ffi.UnsignedShort()
  external int line_thickness;

  external nk_vec2i begin;

  external nk_vec2i end;

  external nk_color color;
}

final class nk_command_curve extends ffi.Struct {
  external nk_command header;

  @ffi.UnsignedShort()
  external int line_thickness;

  external nk_vec2i begin;

  external nk_vec2i end;

  @ffi.Array.multi([2])
  external ffi.Array<nk_vec2i> ctrl;

  external nk_color color;
}

final class nk_command_rect extends ffi.Struct {
  external nk_command header;

  @ffi.UnsignedShort()
  external int rounding;

  @ffi.UnsignedShort()
  external int line_thickness;

  @ffi.Short()
  external int x;

  @ffi.Short()
  external int y;

  @ffi.UnsignedShort()
  external int w;

  @ffi.UnsignedShort()
  external int h;

  external nk_color color;
}

final class nk_command_rect_filled extends ffi.Struct {
  external nk_command header;

  @ffi.UnsignedShort()
  external int rounding;

  @ffi.Short()
  external int x;

  @ffi.Short()
  external int y;

  @ffi.UnsignedShort()
  external int w;

  @ffi.UnsignedShort()
  external int h;

  external nk_color color;
}

final class nk_command_rect_multi_color extends ffi.Struct {
  external nk_command header;

  @ffi.Short()
  external int x;

  @ffi.Short()
  external int y;

  @ffi.UnsignedShort()
  external int w;

  @ffi.UnsignedShort()
  external int h;

  external nk_color left;

  external nk_color top;

  external nk_color bottom;

  external nk_color right;
}

final class nk_command_triangle extends ffi.Struct {
  external nk_command header;

  @ffi.UnsignedShort()
  external int line_thickness;

  external nk_vec2i a;

  external nk_vec2i b;

  external nk_vec2i c;

  external nk_color color;
}

final class nk_command_triangle_filled extends ffi.Struct {
  external nk_command header;

  external nk_vec2i a;

  external nk_vec2i b;

  external nk_vec2i c;

  external nk_color color;
}

final class nk_command_circle extends ffi.Struct {
  external nk_command header;

  @ffi.Short()
  external int x;

  @ffi.Short()
  external int y;

  @ffi.UnsignedShort()
  external int line_thickness;

  @ffi.UnsignedShort()
  external int w;

  @ffi.UnsignedShort()
  external int h;

  external nk_color color;
}

final class nk_command_circle_filled extends ffi.Struct {
  external nk_command header;

  @ffi.Short()
  external int x;

  @ffi.Short()
  external int y;

  @ffi.UnsignedShort()
  external int w;

  @ffi.UnsignedShort()
  external int h;

  external nk_color color;
}

final class nk_command_arc extends ffi.Struct {
  external nk_command header;

  @ffi.Short()
  external int cx;

  @ffi.Short()
  external int cy;

  @ffi.UnsignedShort()
  external int r;

  @ffi.UnsignedShort()
  external int line_thickness;

  @ffi.Array.multi([2])
  external ffi.Array<ffi.Float> a;

  external nk_color color;
}

final class nk_command_arc_filled extends ffi.Struct {
  external nk_command header;

  @ffi.Short()
  external int cx;

  @ffi.Short()
  external int cy;

  @ffi.UnsignedShort()
  external int r;

  @ffi.Array.multi([2])
  external ffi.Array<ffi.Float> a;

  external nk_color color;
}

final class nk_command_polygon extends ffi.Struct {
  external nk_command header;

  external nk_color color;

  @ffi.UnsignedShort()
  external int line_thickness;

  @ffi.UnsignedShort()
  external int point_count;

  @ffi.Array.multi([1])
  external ffi.Array<nk_vec2i> points;
}

final class nk_command_polygon_filled extends ffi.Struct {
  external nk_command header;

  external nk_color color;

  @ffi.UnsignedShort()
  external int point_count;

  @ffi.Array.multi([1])
  external ffi.Array<nk_vec2i> points;
}

final class nk_command_polyline extends ffi.Struct {
  external nk_command header;

  external nk_color color;

  @ffi.UnsignedShort()
  external int line_thickness;

  @ffi.UnsignedShort()
  external int point_count;

  @ffi.Array.multi([1])
  external ffi.Array<nk_vec2i> points;
}

final class nk_command_image extends ffi.Struct {
  external nk_command header;

  @ffi.Short()
  external int x;

  @ffi.Short()
  external int y;

  @ffi.UnsignedShort()
  external int w;

  @ffi.UnsignedShort()
  external int h;

  external nk_image img;

  external nk_color col;
}

final class nk_command_custom extends ffi.Struct {
  external nk_command header;

  @ffi.Short()
  external int x;

  @ffi.Short()
  external int y;

  @ffi.UnsignedShort()
  external int w;

  @ffi.UnsignedShort()
  external int h;

  external nk_handle callback_data;

  external nk_command_custom_callback callback;
}

typedef nk_command_custom_callback
    = ffi.Pointer<ffi.NativeFunction<nk_command_custom_callbackFunction>>;
typedef nk_command_custom_callbackFunction = ffi.Void Function(
    ffi.Pointer<ffi.Void> canvas,
    ffi.Short x,
    ffi.Short y,
    ffi.UnsignedShort w,
    ffi.UnsignedShort h,
    nk_handle callback_data);
typedef Dartnk_command_custom_callbackFunction = void Function(
    ffi.Pointer<ffi.Void> canvas,
    int x,
    int y,
    int w,
    int h,
    nk_handle callback_data);

final class nk_command_text extends ffi.Struct {
  external nk_command header;

  external ffi.Pointer<nk_user_font> font;

  external nk_color background;

  external nk_color foreground;

  @ffi.Short()
  external int x;

  @ffi.Short()
  external int y;

  @ffi.UnsignedShort()
  external int w;

  @ffi.UnsignedShort()
  external int h;

  @ffi.Float()
  external double height;

  @ffi.Int()
  external int length;

  @ffi.Array.multi([2])
  external ffi.Array<ffi.Char> string;
}

abstract class nk_command_clipping {
  static const int NK_CLIPPING_OFF = 0;
  static const int NK_CLIPPING_ON = 1;
}

abstract class nk_draw_list_stroke {
  static const int NK_STROKE_OPEN = 0;

  /// < build up path has no connection back to the beginning
  static const int NK_STROKE_CLOSED = 1;
}

abstract class nk_panel_set {
  static const int NK_PANEL_SET_NONBLOCK = 240;
  static const int NK_PANEL_SET_POPUP = 244;
  static const int NK_PANEL_SET_SUB = 246;
}

abstract class nk_window_flags {
  static const int NK_WINDOW_PRIVATE = 2048;

  /// < special window type growing up in height while being filled to a certain maximum height
  static const int NK_WINDOW_DYNAMIC = 2048;

  /// < sets window widgets into a read only mode and does not allow input changes
  static const int NK_WINDOW_ROM = 4096;

  /// < prevents all interaction caused by input to either window or widgets inside
  static const int NK_WINDOW_NOT_INTERACTIVE = 5120;

  /// < Hides window and stops any window interaction and drawing
  static const int NK_WINDOW_HIDDEN = 8192;

  /// < Directly closes and frees the window at the end of the frame
  static const int NK_WINDOW_CLOSED = 16384;

  /// < marks the window as minimized
  static const int NK_WINDOW_MINIMIZED = 32768;

  /// < Removes read only mode at the end of the window
  static const int NK_WINDOW_REMOVE_ROM = 65536;
}

const int nk_false = 0;

const int nk_true = 1;

const double NK_UNDEFINED = -1.0;

const int NK_UTF_INVALID = 65533;

const int NK_UTF_SIZE = 4;

const int NK_INPUT_MAX = 16;

const int NK_MAX_NUMBER_BUFFER = 64;

const double NK_SCROLLBAR_HIDING_TIMEOUT = 4.0;

const String NK_FILE_LINE =
    'C:\\Users\\ISAQUE~1.SAN\\AppData\\Local\\Temp\\9d015f03\\temp_for_macros.hpp:10';

const double NK_WIDGET_DISABLED_FACTOR = 0.5;

const int NK_TEXTEDIT_UNDOSTATECOUNT = 99;

const int NK_TEXTEDIT_UNDOCHARCOUNT = 999;

const int NK_VERTEX_LAYOUT_END = 3;

const int NK_MAX_LAYOUT_ROW_TEMPLATE_COLUMNS = 16;

const int NK_CHART_MAX_SLOT = 4;

const int NK_WINDOW_MAX_NAME = 64;

const int NK_BUTTON_BEHAVIOR_STACK_SIZE = 8;

const int NK_FONT_STACK_SIZE = 8;

const int NK_STYLE_ITEM_STACK_SIZE = 16;

const int NK_FLOAT_STACK_SIZE = 32;

const int NK_VECTOR_STACK_SIZE = 16;

const int NK_FLAGS_STACK_SIZE = 32;

const int NK_COLOR_STACK_SIZE = 32;

const int NK_VALUE_PAGE_CAPACITY = 60;

const double NK_PI = 3.1415927410125732;

const double NK_PI_HALF = 1.5707963705062866;

const int NK_MAX_FLOAT_PRECISION = 2;
